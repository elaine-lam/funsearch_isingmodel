#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': 0.07122021604938274}
#island_id: 2
#version_generated: 2
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    # Calculate the total spin based on magnetism and energy
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k, site_nbr in enumerate(site_nbrs):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 4
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  return(priorities)




#score: {'data2D.txt': 0.07122021604938274}
#island_id: 2
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    # Calculate the total spin based on magnetism and energy
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k, site_nbr in enumerate(site_nbrs):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 4
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  return(priorities)




#score: {'data2D.txt': -0.001662191358024692}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -abs(total_spin) + h[i//N][i%N]
    priorities[i][1] = abs(total_spin) + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.003076697530864198}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        priorities[i][k] = total_spin - h[i//N][i%N]
      else:
        priorities[i][k] = total_spin + h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.24699305555555537}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][1] = -total_spin - h[i//N][i%N]
    priorities[i][0] = -priorities[i][1]
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001631018518518519}
#island_id: 1
#version_generated: 2
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on site magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.031172993827160513}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for k in [2,3]:
      total_spin += np.sum(J[[k],i//N,i//N])
    total_spin /= 4
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin + np.sum(J[[2,3],i//N,i//N]), -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin + np.sum(J[[2,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i][0] += np.prod(J[[0,1,2,3],i//N,i//N])
     priorities[i][1] -= np.prod(J[[0,1,2,3],i//N,i//N])
    else:
     priorities[i][0] -= np.prod(J[[0,1,2,3],i//N,i//N])
     priorities[i][1] += np.prod(J[[0,1,2,3],i//N,i//N])
  return(priorities)




#score: {'data2D.txt': -0.0021044753086419763}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction sum
    interaction_sum = np.sum(J[[0,3],i//N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_sum, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + interaction_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.1462020061728397}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interaction
    total_spin = h[site_nbr][i%N]
    for k in [0,1,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[[0,3],i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[[0,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] -= np.prod(J[[0,1,3],i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] += np.prod(J[[0,1,3],i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.13548688271604956}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for k in [2,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1/np.sqrt(2)
      else:
        total_spin -= 1/np.sqrt(2)
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[[0,3],i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[[0,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] -= np.prod(J[[0,1,3],i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] += np.prod(J[[0,1,3],i//N,i//N])
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += sum(J[k,i//N,i%N] for k in range(4))
      priorities[i][1] -= sum(J[k,i//N,i%N] for k in range(4))
    else:
      priorities[i][0] -= sum(J[k,i//N,i%N] for k in range(4))
      priorities[i][1] += sum(J[k,i//N,i%N] for k in range(4))
    
    if h[site_nbr2][i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate site priorities based on interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the spin priority considering the nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the magnetism contribution
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+N-1)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.3309180555555546}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin * np.exp(-np.sum(J[:,i//N,:]*h[:,i%N])) 
    priorities[i][1] = total_spin * np.exp(np.sum(J[:,i//N,:]*h[:,i%N]))
  
  return(priorities)




#score: {'data2D.txt': -0.009956635802469136}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site-wise magnetism and neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = np.exp(total_spin) / (np.exp(total_spin) + np.exp(-total_spin))
    priorities[i][1] = 1 - priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.18908132716049394}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias for sites with no neighbors
    if i % N == 0 or i % N == N-1 or (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(0, total_spin)
      priorities[i][1] = min(0, total_spin)
    else:
      priorities[i][0] = min(0, -total_spin)
      priorities[i][1] = max(0, -total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.199283487654321}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
    # Calculate the priority based on the total spin
    if total_spin > 0.5:
      priorities[i][1] *= 2
    elif total_spin < -0.5:
      priorities[i][0] *= 2
    
  return priorities




#score: {'data2D.txt': 0.10365787037037048}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
  # Normalize the priorities
  priorities /= np.linalg.norm(priorities, axis=1)[:,None]
  
  return priorities




#score: {'data2D.txt': 0.03151219135802463}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)) - np.sum(h), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4)) - np.sum(h)]
    
  # Normalize the priorities
  priorities /= np.linalg.norm(priorities, axis=1)[:,None]
  
  return priorities




#score: {'data2D.txt': 0.16313719135802496}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[::2,i//N,i//N]), total_spin + np.sum(J[1::2,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.002899228395061729}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if np.sum(J[:,i//N,i//N]) < 0: 
      priorities[i] = [-total_spin + np.sum(-J[0::2,i//N,i//N]), total_spin + np.sum(-J[1::2,i//N,i//N])]
    else:
      priorities[i] = [total_spin + np.sum(J[0::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.005316820987654321}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    magnetism = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i//N] > 0:
        magnetism += 1
      else:
        magnetism -= 1
    
    # Calculate priority based on magnetism and interaction
    if magnetism > 0:
      priorities[i] = [magnetism + np.sum(J[0::2,i//N,i//N]), -magnetism + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-magnetism + np.sum(J[0::2,i//N,i//N]), magnetism + np.sum(J[1::2,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16313719135802496}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[0::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[0::2,i//N,i//N]), total_spin + np.sum(J[1::2,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.25736126543209853}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    total_spin += np.sum(J[:,i%N,i//N])
    
    # Prioritize spin based on magnetism, energy, and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin - 3]
    else:
      priorities[i] = [-total_spin - 1, total_spin + 3]
  
  return(priorities)




#score: {'data2D.txt': -0.0033297839506172843}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    neighbor_interactions = 0
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    priorities[i][0] = total_spin + neighbor_interactions
    priorities[i][1] = -total_spin - neighbor_interactions
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
  
  return(priorities)




#score: {'data2D.txt': -0.0012057098765432099}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the interactions with the four nearest neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.04342052469135802}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the interaction with the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0027711419753086424}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(h[i//N][i:i+N]) - i/N, -total_spin]
    else:
      priorities[i] = [-total_spin + N*np.sum(h[i//N][i:i+N]) - i, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.2957699074074068}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [1 - np.exp(-total_spin), -np.exp(total_spin)]
    else:
      priorities[i] = [-1 + np.exp(total_spin), np.exp(-1 + total_spin)]
  return(priorities)




#score: {'data2D.txt': -0.0008177469135802467}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = np.tanh(total_spin) * 10
    priorities[i][1] = -np.tanh(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.08264151234567901}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spins = np.zeros((N,N))

  # Calculate the total spin of each site based on its magnetism and neighbor interactions
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      J_sum = J[:, i, :].sum()
      for k in [0, 1]:
        if J[k,i,j] > 0:
          total_spin += J[k,k,i]
        else:
          total_spin -= J[k,k,i]
      total_spins[i,j] = total_spin / (J_sum + 2)

  # Calculate the priority based on the total spin of each site
  for i in range(N**2):
    priorities[i] = [total_spins[i//N][i%N], -total_spins[i//N][i%N]]

  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate magnetism at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.32729861111111025}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Count neighbors with same spin and opposite spin
    same_spin_count = 0
    opp_spin_count = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Count interactions with sites above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        if h[j][i%N] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        if h[i//N][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Count interactions with sites diagonally above and below (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Calculate priority based on interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [same_spin_count, -opp_spin_count]
    else:
      priorities[i] = [-same_spin_count, opp_spin_count]
  
  return(priorities)




#score: {'data2D.txt': 0.16580972222222246}
#island_id: 2
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.14306342592592614}
#island_id: 2
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Consider the site's own spin in case of tie
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.05705015432098766}
#island_id: 2
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the site's own spin in case of tie
    if total_spin > 0.5:
      priorities[i][0] += 1
    elif total_spin < -0.5:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.04013935185185186}
#island_id: 1
#version_generated: 2
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for site_nbr in site_nbrs:
      if J[3,i%N,site_nbr] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.13823163580246933}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+1)%N) if i%N == 0 else (i % N)
    total_spin = h[site_nbr1][i%N] + J[3, i%N, i//N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002361882716049383}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the sum of all interactions from this site
    total_spin += np.sum(J[:,i//N,i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11251898148148162}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1270094135802471}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr1 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr1][j]
        priorities[i][1] -= h[site_nbr1][j]
      else:
        priorities[i][0] -= h[site_nbr1][j]
        priorities[i][1] += h[site_nbr1][j]
    
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the total magnetism at each site
  h_sum = h.sum(axis=1)
  
  # Iterate over all sites
  for i in range(N**2):
    # Get the row and column indices of the current site
    i_row, i_col = divmod(i, N)
    
    # Calculate the total magnetism at this site, including its neighbors
    total_spin = h_sum[i_row] + J[:,i_row,i_col].sum()
    
    # Calculate the priority for each spin direction (1 and -1)
    priorities[i][0] = abs(total_spin)  # -1 is more likely if there are many negative interactions
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.02166064814814815}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    
    for k in [0, 1]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin[i] += 1
      else:
        total_spin[i] -= 1
      
      priorities[i][0] += J[k,i%N,i//N]
      priorities[i][1] -= J[k,i%N,i//N]
    
    # Normalize by the number of interacting neighbors
    priorities[i][0] /= (np.sum(J[:,i//N,:].flatten()) + 1)
    priorities[i][1] /= (np.sum(J[:,i//N,:].flatten()) + 1)
  
  return(priorities)




#score: {'data2D.txt': 0.33164953703703604}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with next neighbor sites
      for l in [2,3]:
        if (l == 2 and i % N != 0) or (l == 3 and i % N != N-1):
          if J[l,i%N,i//N] > 0:
            total_spin += 1
          else:
            total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 4)
    
    # Calculate priority based on magnetism and neighbor interactions
    if total_spin > 0.5:
      priorities[i] = [total_spin - h[i//N][i%N], total_spin]
    else:
      priorities[i] = [total_spin, total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.3389890432098755}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum(h[site_nbr][j] for j in range(N)) / N
    neighbor_alignment = sum(J[k,i%N,i//N] * (-1 if J[k,i%N,i//N] < 0 else 1) for k in range(4))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_alignment, -total_spin - neighbor_alignment]
    else:
      priorities[i] = [-total_spin - neighbor_alignment, total_spin + neighbor_alignment]
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
  
  # Reorder the priority based on the total spin and energy
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = sorted(priorities[i])
    else:
      priorities[i] = sorted(priorities[i], reverse=True)
  
  return(priorities)




#score: {'data2D.txt': 0.16840077160493838}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16722083333333349}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N]) * h[site_nbr][i%N]

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.1821489197530865}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += J[3,i%N,j]
        priorities[i][1] -= J[3,i%N,j]
      else:
        priorities[i][0] -= J[3,i%N,j]
        priorities[i][1] += J[3,i%N,j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total spin with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate priority with nearest neighbors
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate priority with next nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16640416666666694}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0791992283950618}
#island_id: 3
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
    
    # Add the effect of the site's own interaction with its neighbors
    if i % N > 0:
      priorities[i, 0] -= J[1, i%N, i//N]
      priorities[i, 1] += J[1, i%N, i//N]
    if i % N < N - 1:
      priorities[i, 0] -= J[0, i%N, i//N]
      priorities[i, 1] += J[0, i%N, i//N]
    if (i // N) % 2 == 0:
      priorities[i, 0] -= J[1, i//N, i%N]
      priorities[i, 1] += J[1, i//N, i%N]
    else:
      priorities[i, 0] -= J[0, i//N, i%N]
      priorities[i, 1] += J[0, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.3440853395061718}
#island_id: 3
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + 2 * h[i//N][i%N]
      priorities[i][0] = total_spin
    else:
      priorities[i][0] = -total_spin + 2 * abs(h[i//N][i%N])
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
    else:
      priorities[i] = [-total_spin, -total_spin]
 
  return(priorities)




#score: {'data2D.txt': 0.002077932098765432}
#island_id: 1
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  for i in range(N**2):
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0942760802469137}
#island_id: 1
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(3):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += 2*h[site_nbr][i%N]
        priorities[i][1] -= 2*h[site_nbr][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr][i%N]
        priorities[i][1] += 2*h[site_nbr][i%N]
    
    for j in range(N):
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[(j-1)%N][i//N]
        priorities[i][1] -= h[(j-1)%N][i//N]
      else:
        priorities[i][0] -= h[(j-1)%N][i//N]
        priorities[i][1] += h[(j-1)%N][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.00126466049382716}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin + h[site_nbr][i%N]
  
  return priorities




#score: {'data2D.txt': -0.004388734567901235}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': 0.0002807098765432099}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    neighbor_interactions = 0
    
    # Calculate magnetism contribution
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k][i//N, i%N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Calculate priority based on magnetism and interaction
    priorities[i] = [total_spin + neighbor_interactions, -total_spin + neighbor_interactions]
  
  return(priorities)




#score: {'data2D.txt': 0.05398935185185188}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Additional adjustment based on the interaction with diagonal neighbors
    site_nbr_diagonal = (i % N + ((i//N-2)%2 - 1)) % N
    if i % N > 0:
      priorities[i][0] += J[3, i//N, i%N]
    else:
      priorities[i][1] -= J[3, i//N, i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.06162947530864202}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Adjust the priority based on the interaction with diagonal neighbors
  for i in range(N**2):
    site_nbr_diagonal = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_diagonal][i%N] > 0:
      priorities[i][1] -= J[3, i//N, i%N]
    else:
      priorities[i][0] += J[3, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.053111265432098785}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
        2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Additional adjustment based on the interaction with diagonal neighbors
    site_nbr_diagonal = (i % N + ((i//N-2)%2 - 1)) % N
    if i % N > 0:
      priorities[i][0] += J[3, i//N, i%N]
    else:
      priorities[i][1] -= J[3, i//N, i%N]
    
  # Calculate the priority based on the sum of the magnetism and interaction with nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
        2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.04353101851851851}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher absolute value of magnetism
    if abs(h[i//N][i%N]) > abs(h[site_nbr][i%N]):
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0012726851851851849}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.0569729938271605}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0038356481481481484}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Reorder the priority based on the total spin and energy
    if h[i//N][i%N] > 0:
      priorities[i] = sorted(priorities[i])
    else:
      priorities[i] = sorted(priorities[i], reverse=True)
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Reorder the priority based on the total spin and energy
    if h[i//N][i%N] > 0:
      priorities[i] = np.array(sorted(priorities[i])).reshape(-1,2)
    else:
      priorities[i] = np.array(sorted(priorities[i], reverse=True)).reshape(-1,2)
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
    
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total_spin based on nearest neighbors
    total_spin = 0
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust total_spin based on magnetism at the site
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009285493827160493}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        for j in range(N):
          if h[site_nbrs[j]][i%N] > 0:
            priorities[i][0] += h[site_nbrs[j]][i%N]
            priorities[i][1] -= h[site_nbrs[j]][i%N]
          else:
            priorities[i][0] -= h[site_nbrs[j]][i%N]
            priorities[i][1] += h[site_nbrs[j]][i%N]
      else:
        for j in range(N):
          if h[site_nbrs[j]][i%N] > 0:
            priorities[i][0] -= h[site_nbrs[j]][i%N]
            priorities[i][1] += h[site_nbrs[j]][i%N]
          else:
            priorities[i][0] += h[site_nbrs[j]][i%N]
            priorities[i][1] -= h[site_nbrs[j]][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_col = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_col][j]
      else:
        total_spin -= h[site_nbr_col][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
      site_nbrs.append(site_nbr)
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2768421296296292}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -np.abs(total_spin) - h[i//N][i%N]
    priorities[i][1] = np.abs(total_spin) + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0012967592592592588}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin**2 * np.tanh(total_spin) 
    priorities[i][1] = total_spin**2 * np.tanh(-total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.0023671296296296296}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 4)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.06960848765432101}
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[i//N][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N-1)%2 - 1)) % N

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -3.070987654320912e-05}
#island_id: 1
#version_generated: 2
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
     site_nbr1 = (i % N + ((j-1)%2 - 1)) % N
     site_nbr2 = (i // N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       total_spin += h[site_nbr1][j] + J[3,i%N,j]
     else:
       total_spin -= h[site_nbr1][j] + J[3,i%N,j]
    
    priorities[i][0] = min(priorities[i][0], -priorities[i][1])
    priorities[i][1] = max(-priorities[i][0], priorities[i][1])
  
  return(priorities)




#score: {'data2D.txt': -0.009849845679012348}
#island_id: 1
#version_generated: 2
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][total_spin>0] = [abs(total_spin), -abs(total_spin)]
    
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09304922839506181}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.0012405864197530864}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the interactions with neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the site's magnetism
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Calculate the priority based on the site's interactions with its nearest neighbors
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate the priority based on the site's interactions with its next nearest neighbors
    for k in range(2):
      if i % N > 0:
        if J[k,i%N-1,i//N] > 0:
          priorities[i][0] += h[site_nbr][i%N-1]
          priorities[i][1] -= h[site_nbr][i%N-1]
        else:
          priorities[i][0] -= h[site_nbr][i%N-1]
          priorities[i][1] += h[site_nbr][i%N-1]
      if i % N < N - 1:
        if J[k,i%N+1,i//N] > 0:
          priorities[i][0] += h[site_nbr][i%N+1]
          priorities[i][1] -= h[site_nbr][i%N+1]
        else:
          priorities[i][0] -= h[site_nbr][i%N+1]
          priorities[i][1] += h[site_nbr][i%N+1]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # sum up interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.20125848765432114}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif i%N == 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+1)%N] > 0:
      total_spin += 1
    elif i%N == N-1:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.33199367283950515}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in [0, 1, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site magnetism and neighbor interactions
  site_magnetisms = h.flatten()
  neighbor_interactions = (J[:, :, :].sum(axis=0) + 1)
  
  # Iterate over each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total magnetism at this site
    total_magnetism = site_magnetisms[i] + neighbor_interactions[i//N].dot(h[site_nbr])
    
    # Calculate priority based on magnetism and interactions
    priorities[i] = [total_magnetism - h[i//N][i%N], total_magnetism + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.04959706790123461}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.0631498456790124}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
    # Additional improvement: consider the majority vote of neighbors
    neighbor_votes = [neighbor > 0 for neighbor in neighbors]
    if sum(neighbor_votes) > len(neighbor_votes) / 2:
      priorities[i] += np.array([1, -1])
  return(priorities)




#score: {'data2D.txt': -0.014500771604938276}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
  # Calculate a secondary priority based on the total magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.012826080246913616}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
    # Add the magnetism of the site to the priority
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.04357978395061728}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on their local energy
    site_energy = h[site_nbr][i%N] * (h[i//N][i%N] > 0) - total_spin
    if site_energy > 0:
      priorities[i][1] += 1
    elif site_energy < 0:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.04344336419753086}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on the number of aligned neighbors
    aligned_neighbors = sum(neighbor_spins)
    if aligned_neighbors > 0:
      priorities[i][1] += 1
    elif aligned_neighbors < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.19855848765432105}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0,0]
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin[1] -= 1
    else:
      total_spin[0] += 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Normalize by the number of neighbors
    total_spin[0] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    total_spin[1] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[0], -total_spin[1]]
    else:
      priorities[i] = [-total_spin[1], total_spin[0]]
  
  return(priorities)




#score: {'data2D.txt': 0.11373533950617293}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(3):
      j = i//N + ((k-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(3):
      j = i//N + ((k-1)%2 - 1)
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16610015432098788}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1022430555555557}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    # Add a penalty term for sites with large magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.04365077160493827}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0014699074074074074}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    return(priorities)




#score: {'data2D.txt': 0.0019214506172839504}
#island_id: 2
#version_generated: 2
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that are closer to the boundary and more stable
    site_edge = int((i % (N*N)) ** 0.5)
    if site_edge > 0:
      edge_dist = min(site_edge, N - site_edge)
      priorities[i][1] += edge_dist
    
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
      else:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with up to 4 nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * 2 - N
      priorities[i][1] = -(total_spin * 2 - N)
    else:
      priorities[i][0] = -(total_spin * 2 - N)
      priorities[i][1] = total_spin * 2 - N
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_priority = [total_spin, -total_spin]
    site_magnetism = h[i//N][i%N]
    
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        if h[(i % N + ((k-1)%2 - 1)) % N][i%N] > 0:
          spin_priority[1] -= 1
        else:
          spin_priority[0] += 1
      else:
        if h[(i % N + ((k-1)%2 - 1)) % N][i%N] > 0:
          spin_priority[0] -= 1
        else:
          spin_priority[1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        spin_priority[1] -= 1
      else:
        spin_priority[0] += 1
    
    priorities[i] = spin_priority
  
  return(priorities)




#score: {'data2D.txt': -0.0007010802469135806}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N)
    site_nbr_col = ((i//N) % N)
    
    total_spin = 0
    for k in range(4):
      if k == 0:
        total_spin += J[k,i%N,i//N]
      elif k == 1:
        total_spin += J[k,(i-1)%N,site_nbr_row]
      elif k == 2:
        total_spin += J[k,i%N,(i//N-1)%N]
      else:
        total_spin += J[k,(i+1)%N,site_nbr_col]
    
    # Add magnetism term
    total_spin += h[i//N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1384973765432101}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Calculate the priority based on the distance from the boundary
  for i in range(N**2):
    x, y = (i % N), (i // N)
    dist_to_boundary = min(x, y, N - x, N - y)
    priorities[i][0] += 2 * dist_to_boundary / N
    priorities[i][1] -= 2 * dist_to_boundary / N
  
  return(priorities)




#score: {'data2D.txt': -0.0011359567901234571}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort sites based on their priority
  sorted_indices = np.argsort(priorities[:, 0])
  sorted_priorities = priorities[sorted_indices]
  
  return(sorted_priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.03011620370370369}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + len([j for j in range(4) if J[j,i//N,i%N]]))
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Calculate the priority based on the distance from the boundary
  for i in range(N**2):
    x, y = (i % N), (i // N)
    dist_to_boundary = min(x, y, N - x, N - y)
    priorities[i][0] += 4 * dist_to_boundary / N
    priorities[i][1] -= 4 * dist_to_boundary / N
  
  return(priorities)




#score: {'data2D.txt': 0.11390324074074087}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the number of nearest neighbors in the same state
    for k in range(4):
      neighbor_site_nbr = ((i % N + (k-1)%2) % N + ((i//N-1)%2 - 1)) % N
      if h[neighbor_site_nbr][(i%N + k)%N] == h[i//N][i%N]:
        priorities[i][0] += 1
        priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1145109567901236}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the number of nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i % N != k // 2 and (i // N) != (k - 1) // 2:
        priorities[i][0] += 2 * total_spin / 3
        priorities[i][1] -= 2 * total_spin / 3
  
  return(priorities)




#score: {'data2D.txt': 0.14858410493827182}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to account for the boundary
    x, y = (i % N), (i // N)
    if x == 0 or y == 0 or x == N-1 or y == N-1:
      priorities[i][0] += 3
      priorities[i][1] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.0004723765432098761}
#island_id: 2
#version_generated: 2
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0012967592592592597}
#island_id: 2
#version_generated: 2
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + len([j for j in range(N) if J[3,i//N,j] < 0]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + len([j for j in range(N) if J[3,i//N,j] > 0])]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += len([j for j in neighbor_spins if j > 0])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= len([j for j in neighbor_spins if j < 0])
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += len([j for j in range(N) if J[3,i//N,j] < 0])
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= len([j for j in range(N) if J[3,i//N,j] > 0])
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += len([j for j in range(N) if h[j//N][j%N] > 0])
    else:
      priorities[i][0] -= len([j for j in range(N) if h[j//N][j%N] < 0])
  
  return(priorities)




#score: {'data2D.txt': -0.1718915123456791}
#island_id: 2
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] > 0), -total_spin - sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] < 0)]
    else:
      priorities[i] = [-total_spin - sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] > 0), total_spin + sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] < 0)]
    
  return(priorities)




#score: {'data2D.txt': -0.0017131172839506142}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    total_spin += np.sum(J[:,i//N,i//N])
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.009499228395061728}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N])
    
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
      
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    # Add site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16448225308641998}
#island_id: 2
#version_generated: 2
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum([1 if J[k,i%N,i//N]>0 else -1 for k in range(4)])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum([1 if J[k,i%N,i//N]<0 else -1 for k in range(4)])
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.16840077160493838}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19888163580246918}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19583719135802471}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N - 1
    l = i%N
    if J[2, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    j = i//N + 1
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19706620370370376}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.15204645061728414}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.14029058641975328}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = []
    for k in range(4):  
      if J[k, i//N, i%N] > 0:
        neighbors.append(1)
      else:
        neighbors.append(-1)
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + sum(J[::, i//N, i%N]), -spin]
    else:
      priorities[i] = [-spin, spin + sum(J[::, i//N, i%N])]
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.12143287037037051}
#island_id: 0
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i%N], -total_spin + J[1, i//N, i%N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i%N], total_spin + J[3, i//N, i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    # Add bias term to prioritize -1 spin if h[i//N][i%N] > 0
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - N, -total_spin - N]
    else:
      priorities[i] = [-total_spin + N, total_spin + N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.11073472222222233}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    spin_h = h[i//N][i%N]
    
    for k in range(4):
      jnbr = (i // N + ((k-1)%2 - 1)) % N
      if J[k,i//N,jnbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin + spin_h
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0014699074074074074}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    return(priorities)




#score: {'data2D.txt': 0.043781944444444436}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.16766280864197558}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0012615740740740745}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum(np.abs(neighbor_spins))
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum(np.abs(neighbor_spins))
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.032313117283950615}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority of each spin
    if total_spin > 0.5:
      priorities[i][1] += 3
    elif total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have higher magnetism
    if h[site_nbr][i%N] > 0 and total_spin > 0.25:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and total_spin < -0.25:
      priorities[i][0] -= 2
    
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1156964506172841}
#island_id: 1
#version_generated: 2
#generate time09:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': -0.0012245370370370368}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = J[3,i//N,i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -J[3,i//N,i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.count_nonzero(neighbor_spins)
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.count_nonzero(neighbor_spins)

  return(priorities)




#score: {'data2D.txt': 0.16766280864197558}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.14854645061728414}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on the interactions with their neighbors
    neighbor_interactions = [J[0,i%N,i//N], J[1,i%N,i//N], J[2,i%N,i//N], J[3,i%N,i//N]]
    if sum(neighbor_interactions) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_interactions) < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.05008287037037037}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.12791435185185202}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    spin_direction = np.sign(np.sum(neighbor_spins))
    if spin_direction > 0:
      priorities[i][1] += 2
    elif spin_direction < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]>0]), 
               -total_spin - sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]<0])]
    else:
      priorities[i] = [-total_spin - sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]>0]), 
               total_spin + sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]<0])]
    
  return(priorities)




#score: {'data2D.txt': 0.043781944444444436}
#island_id: 2
#version_generated: 2
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16575601851851876}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][0] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum(np.abs(h[site_nbr]))
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum(np.abs(h[site_nbr]))

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001486574074074074}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006193364197530864}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if J[0,i//N,i//N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if total_spin > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.183339351851852}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same row (if exists)
    if i % N < N - 1:
      j = i//N
      if J[0, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)) + (int(i % N < N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.183339351851852}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same row (if exists)
    if i % N < N - 1:
      j = i//N
      if J[0, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)) + (int(i % N < N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.05971126543209882}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(J[:,i%N,:], axis=0)[l]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.07022854938271607}
#island_id: 2
#version_generated: 2
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate magnetism-based priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += abs(total_spin)
      priorities[i][1] -= abs(total_spin)
    else:
      priorities[i][0] -= abs(total_spin)
      priorities[i][1] += abs(total_spin)
  
  # Calculate interaction-based priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_interactions = [J[0,i%N,i//N], J[1,(i+1)%N,i//N], J[2,i%N,(i+N-1)%N], J[3,(i+N-1)%N,i//N]]
    
    if sum(neighbor_interactions) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_interactions) < 0:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.05008287037037037}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    neighbor_energy = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_energy += 1
      else:
        neighbor_energy -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_energy, -total_spin - neighbor_energy]
    else:
      priorities[i] = [-total_spin - neighbor_energy, total_spin + neighbor_energy]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.12793811728395077}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
  return(priorities)




#score: {'data2D.txt': -0.27832638888888905}
#island_id: 1
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum(h[i//N][i%N])
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.04221311728395062}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = np.sum(h[i//N])
    
    priorities[i] = [total_spin + magnetism, -total_spin - magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.15648533950617302}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + ((i+N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N] + h[site_nbr3][i%N] + h[site_nbr4][i//N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,(i+N-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0014427469135802472}
#island_id: 1
#version_generated: 2
#generate time10:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Initialize total spin based on magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with next-nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Sort priorities by total spin
    priorities[i] = np.sort(priorities[i])
  
  return(priorities)




#score: {'data2D.txt': 0.16501589506172862}
#island_id: 1
#version_generated: 2
#generate time10:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.008586882716049384}
#island_id: 2
#version_generated: 2
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
    
    # Check for the case where the magnetism at site is high and energy is low, prioritize the spin with lower entropy
    if h[i//N][i%N] > 0.5 and total_spin < -0.1:
      if np.random.rand() < 0.5:
        priorities[i][0] -= 4
      else:
        priorities[i][1] += 4
    
    # Check for the case where the magnetism at site is low and energy is high, prioritize the spin with higher entropy
    elif h[i//N][i%N] < -0.5 and total_spin > 0.1:
      if np.random.rand() < 0.5:
        priorities[i][0] += 4
      else:
        priorities[i][1] -= 4
  
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum([abs(p) for p in neighbor_spins])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum([abs(p) for p in neighbor_spins])
    
  return(priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # Prioritize spins based on magnetism and interactions
    if h[site_nbr][i % N] > 0:
      priorities[i][1] += abs(total_spin)
    else:
      priorities[i][0] += abs(total_spin)
  
  return (priorities)




#score: {'data2D.txt': 0.15370756172839525}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
    # Add magnetism and interaction information for each site
    if h[site_nbr][i % N] > 0:
      priorities[i][1] -= 2 * np.sum(neighbors_spin)
    else:
      priorities[i][0] -= 2 * np.sum(neighbors_spin)
  return (priorities)




#score: {'data2D.txt': -0.3429427469135792}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] += abs(total_spin) * (total_spin > 0) + 2
      priorities[i][1] -= abs(total_spin) * (total_spin < 0) - 2
    else:
      priorities[i][0] -= abs(total_spin) * (total_spin < 0) - 2
      priorities[i][1] += abs(total_spin) * (total_spin > 0) + 2
      
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(0, total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -max(0, total_spin)
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and the site magnetism
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])) + abs(h[site_nbr][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and their strengths
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.024325771604938297}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    total_spin /= np.sum([int(J[0, i%N, l]) + int(J[1, i%N, l]) + int(J[2, i%N, l]) + int(J[3, i%N, l]) for l in range(N)])

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.22146126543209874}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate magnetism at each site
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10403287037037046}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priority based on magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.035832870370370355}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]

  # Combine interactions with magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1398489197530865}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.10403287037037046}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])) * N
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])) * N
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0006538580246913579}
#island_id: 1
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin-1]
    else:
      priorities[i] = [-total_spin-1, total_spin+1]
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 2
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 2
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    priorities[i][0] = max(-1, min(1, total_spin))  # prioritize -1 if spin is close to -1 and vice versa
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.02115385802469136}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.10365416666666676}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
    
    # Add a correction term based on the number of neighbors
    num_neighbors = len(neighbors)
    priorities[i][0] += (num_neighbors - sum([J[j,i//N,i%N] for j in range(4)])) / 2
    priorities[i][1] -= priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.09228379629629638}
#island_id: 1
#version_generated: 2
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 2
      priorities[i][1] += 2
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11428132716049395}
#island_id: 1
#version_generated: 2
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.11441219135802481}
#island_id: 1
#version_generated: 2
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site interactions and magnetism
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,j] > 0:
        priorities[i][0] += h[site][j]
        priorities[i][1] -= h[site][j]
      else:
        priorities[i][0] -= h[site][j]
        priorities[i][1] += h[site][j]
  
  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.009270524691358023}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= sum(np.abs(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])) * N
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])) * N
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.3390458333333323}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0]) - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.3009668209876545}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0] or [-x for x in [J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0]])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.22308996913580237}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    num_neighbors = 4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i%8<4))
    total_spin /= num_neighbors
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14239521604938285}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      j, l = i//N + k, k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19795262345679016}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if j < N - 1 or ((i % N == 0 or i % N == N - 1)):
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16599336419753097}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += h[j][i%N]
      else:
        total_spin -= h[j][i%N]
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += h[i//N][l]
      else:
        total_spin -= h[i//N][l]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0010128086419753087}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total spin based on J and h
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    num_neighbors = sum([1 for k in [0, 1, 2] if i//N + ((k-1)%2 - 1) % N >= 0 and i//N + ((k-1)%2 - 1) % N < N])
    priorities[i] = [-total_spin/num_neighbors, total_spin/num_neighbors]
  
  return(priorities)




#score: {'data2D.txt': 0.16632453703703712}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
        
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
        
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': -0.002005709876543209}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    for k in [0,2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    n_neighbors = 4 if i % N > 0 or i % N == N - 1 else 3
    priorities[i] = [total_spin + total_spin/n_neighbors, -total_spin - total_spin/n_neighbors]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction from all four neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priority based on site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.07096990740740745}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with the site's own magnetism
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interactions with the site's own spin
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum the interactions from the four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust based on site magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.001962191358024691}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_top = (i - N) % N
    site_nbr_bot = (i + N) % N
    site_nbr_left = i % N
    site_nbr_right = (i // N * N + (i % N + 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0037131172839506175}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in [0,1]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.02346929012345679}
#island_id: 1
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += np.sum(h[i//N][:]) + np.sum([J[3,j,i//N] for j in range(N)])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.14643966049382717}
#island_id: 1
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_val = h[site_nbr][i%N] + J[0,i%N,i//N]
    else:
      h_val = h[site_nbr][i%N] - J[0,i%N,i//N]

    if J[1,i%N,i//N] > 0:
      h_val += J[1,i//N,i%N]
    else:
      h_val -= J[1,i//N,i%N]

    if J[2,i//N,i%N] > 0:
      h_val += J[2,i//N,i%N]
    else:
      h_val -= J[2,i//N,i%N]

    if J[3,(i+1)%N,i//N] > 0:
      h_val += J[3,(i+1)%N,i//N]
    elif i % N != (N-1):
      h_val -= J[3,i%N,i//N]
    
    priorities[i][0] = -h_val
    priorities[i][1] = h_val
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16709645061728406}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.2179081790123457}
#island_id: 3
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism as a priority
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 2 - J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.000672993827160493}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, (i+1)%N] > 0:
      total_spin += 1
    elif J[0, i%N, (i+1)%N] < 0:
      total_spin -= 1
    
    if J[1, i%N, ((i-1)%N+N)%N] > 0:
      total_spin += 1
    elif J[1, i%N, ((i-1)%N+N)%N] < 0:
      total_spin -= 1
    
    if J[2, (i//N)%N, i%N] > 0:
      total_spin += 1
    elif J[2, (i//N)%N, i%N] < 0:
      total_spin -= 1
    
    if J[3, ((i-1)%N+N)//N, i%N] > 0:
      total_spin += 1
    elif J[3, ((i-1)%N+N)//N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017390432098765443}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009427469135802467}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
      
  return(priorities)




#score: {'data2D.txt': 5.910493827160484e-05}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[k,i%N,i//N] for k in range(4))
      priorities[i][1] -= sum(J[k,i%N,i//N] for k in range(4))
    else:
      priorities[i][0] -= sum(J[k,i%N,i//N] for k in range(4))
      priorities[i][1] += sum(J[k,i%N,i//N] for k in range(4))
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[3,i%N,j] for j in range(N))
      priorities[i][1] -= sum(J[3,i%N,j] for j in range(N))
    else:
      priorities[i][0] -= sum(J[3,i%N,j] for j in range(N))
      priorities[i][1] += sum(J[3,i%N,j] for j in range(N))
  
  return(priorities)




#score: {'data2D.txt': -0.01202145061728395}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbrs = []
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((i % N + ((k-1)%2 - 1)) % N)
      else:
        site_nbrs.append(-1)
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        site_nbrs.append(site_nbr)
      else:
        site_nbrs.append(-1)
    if h[i//N][i%N] > 0:
      for spin in site_nbrs:
        total_spin += h[spin][i%N]
      priorities[i] = [total_spin, -total_spin]
    else:
      for spin in site_nbrs:
        total_spin -= h[spin][i%N]
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.05661404320987656}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]

    if J[2,(i+1)%N,i//N] > 0:
      priorities[i][0] += h[(i+1)%N][i%N]
      priorities[i][1] -= h[(i+1)%N][i%N]
    else:
      priorities[i][0] -= h[(i+1)%N][i%N]
      priorities[i][1] += h[(i+1)%N][i%N]

    if J[3,(i+N)%N//N,i%N] > 0:
      priorities[i][0] += h[(i+N)%N//N][(i%N+N)%N]
      priorities[i][1] -= h[(i+N)%N//N][(i%N+N)%N]
    else:
      priorities[i][0] -= h[(i+N)%N//N][(i%N+N)%N]
      priorities[i][1] += h[(i+N)%N//N][(i%N+N)%N]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin from magnetism and nearest neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0008415123456790122}
#island_id: 0
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for d in [(i//N-1, i%N), (i//N+1, i%N)]:
      if 0 <= d[0] < N:
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Add interaction with the site diagonally above and below (if exists)
    for d in [(i//N-1, (i%N+1) % N), (i//N+1, (i%N-1) % N)]:
      if 0 <= d[0] < N and 0 <= d[1] < N:
        if J[3, i%N, d[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i//N+1)%N > 0) + int((i%N+1) % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': -0.00027268518518518516}
#island_id: 0
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin = np.zeros((N*N, 1))

  # Calculate the total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[i] = np.sum([J[k, i%N, j] for k in range(4) for j in [(k+1)%2, (k-2)%2]])
      total_spin[i] += np.sum([J[3, i%N, j] for j in [(i//N-1)%N, (i//N+1)%N]] if 0 <= (i//N-1) < N and 0 <= (i%N-1) < N else [] if 0 <= (i//N+1) < N and 0 <= (i%N+1) % N < N else [])
    else:
      total_spin[i] = -np.sum([J[k, i%N, j] for k in range(4) for j in [(k+1)%2, (k-2)%2]])
      total_spin[i] -= np.sum([J[3, i%N, j] for j in [(i//N-1)%N, (i//N+1)%N]] if 0 <= (i//N-1) < N and 0 <= (i%N-1) < N else [] if 0 <= (i//N+1) < N and 0 <= (i%N+1) % N < N else [])

  # Assign priorities based on the total spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin[i]
      priorities[i][1] = -total_spin[i]
    else:
      priorities[i][0] = -total_spin[i]
      priorities[i][1] = total_spin[i]

  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]

  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Compute magnetism and interaction sums
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin[i][j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin[i//N][i%N][0] += 1
        total_spin[i//N][i%N][1] -= 1
      else:
        total_spin[i//N][i%N][0] -= 1
        total_spin[i//N][i%N][1] += 1
    
    # Normalize by the number of neighbors
    for j in range(2):
      total_spin[i//N][i%N][j] /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N][i%N][0], -total_spin[i//N][i%N][1]]
    else:
      priorities[i] = [-total_spin[i//N][i%N][0], total_spin[i//N][i%N][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0020319444444444443}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    total_spin += np.sum(np.sign(J[:,i%N,i//N]) * (np.abs(J[:,i%N,i//N])))
    total_spin /= 2 + np.sum(np.abs(J[:,i%N,i//N]))
    
    # Add magnetism term and normalize by the number of neighbors
    total_spin += h[i//N][i%N]
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.06548163580246916}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(2):
     site_nbr = (i % N + ((k)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
     site_nbr = (i % N + ((j)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       priorities[i][0] += h[site_nbr][j]
       priorities[i][1] -= h[site_nbr][j]
     else:
       priorities[i][0] -= h[site_nbr][j]
       priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.0006479938271604933}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in [(i//N-1)%N if i%N > 0 else N-1, (i//N+1)%N if i%N < N-1 else 0,
         ((i-1)//N)%N if i % N > 0 else N-1, (i+1)//N if i % N < N-1 else 0]:
      site_nbr = k*N + (i % N)
      total_spin += J[0,k//N,i//N] * h[k//N][i%N]
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.05039120370370371}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    mag = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if h[site_nbr][i%N] > 0:
        mag += 1
      else:
        mag -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - mag, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + mag]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + sum(J[:,i//N,i//N]) + abs(h[site_nbr][i%N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.13388101851851872}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    # Add a bonus for aligning with the local magnetism if it's high enough
    if abs(mag) > 0.5:
      total_spin += mag
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and the magnetism at this site
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])) + np.abs(h[site_nbr][i%N]))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on J and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(total_spin)
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.16381836419753115}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
  
  return(priorities)




#score: {'data2D.txt': 0.20244336419753103}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.00038996913580246844}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i//N].flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00019336419753086353}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if J[0, i//N, i//N] == J[2, i//N, i//N]:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-np.abs(total_spin), total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08056558641975314}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][0] = -priorities[i][1]
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.19540756172839527}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.20244336419753103}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 1
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(J[:,i//N,i//N])
      priorities[i][1] = -total_spin - sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -total_spin - sum(J[:,i//N,i//N])
      priorities[i][1] = total_spin + sum(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.1072547839506174}
#island_id: 1
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N]
      priorities[i][1] -= 2*h[site_nbr][i%N]
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N]
      priorities[i][1] += 2*h[site_nbr][i%N]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.15516404320987676}
#island_id: 1
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    total_spin_row = h[site_nbr_row][i%N]
    total_spin_col = J[3,i//N,i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_row + total_spin_col, -total_spin - total_spin_row - total_spin_col]
    else:
      priorities[i] = [-total_spin - total_spin_row - total_spin_col, total_spin + total_spin_row + total_spin_col]
    
  return(priorities)




#score: {'data2D.txt': 0.006115277777777777}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
      
  return(priorities)




#score: {'data2D.txt': -0.0006757716049382714}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
  
  # Sort the priorities for each site based on their absolute value
  priorities = priorities[np.argsort(np.abs(priorities[:,0])),:]
  
  return(priorities)




#score: {'data2D.txt': 0.16381836419753115}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    # Calculate the total spin
    total_spin = h[site_nbr][i%N]

    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 2 * np.count_nonzero(J[:, i//N, i%N] == J[j, i//N, i%N])
      else:
        total_spin -= 2 * np.count_nonzero(J[:, i//N, i%N] == J[j, i//N, i%N])
    
    # Normalize by the number of neighbors
    total_spin /= 8
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.11549737654320998}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.11549737654320998}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.1661365740740742}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [0, 3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.166851388888889}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.12932916666666688}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(h[i//N][i%N])
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + abs(h[i//N][i%N])
  
  return(priorities)




#score: {'data2D.txt': 0.18157577160493849}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
    
    # Add the interaction with the next site
    next_site_nbr = (i+1) % N
    if i%N == N - 1:
      next_site_nbr = 0
    next_site_magnetism = h[next_site_nbr//N][next_site_nbr%N]
    priorities[i][0] += abs(next_site_magnetism)
    priorities[i][1] -= abs(next_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.19540756172839527}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.030540277777777774}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(abs(J[k,i%N,i//N]) for k in range(4))
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + sum(abs(J[k,i%N,i//N]) for k in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.19991188271604937}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,(k+2)%2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: priorities[i][0] += total_spin
    if i % N == 0 or i % N == N - 1: priorities[i][1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0] + total_spin/2, -priorities[i][1] - total_spin/2]
    else:
      priorities[i] = [-priorities[i][0] - total_spin/2, priorities[i][1] + total_spin/2]
  
  return(priorities)




#score: {'data2D.txt': -0.14354490740740752}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = 0
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum /= 4
    if i % N == 0 or i % N == N - 1: total_spin_sum /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + 1, -total_spin_sum - 1]
    else:
      priorities[i] = [-total_spin_sum - 1, total_spin_sum + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.16507916666666678}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/3, -total_spin_sum - total_spin_sum/3]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/3, total_spin_sum + total_spin_sum/3]
  
  return(priorities)




#score: {'data2D.txt': 0.17828996913580272}
#island_id: 1
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_col = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_row = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
    if J[2,i//N,i//N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[3,i//N,N-1-i%N] > 0:
      priorities[i][0] += h[i//N][N-1-i%N]
      priorities[i][1] -= h[i//N][N-1-i%N]
    else:
      priorities[i][0] -= h[i//N][N-1-i%N]
      priorities[i][1] += h[i//N][N-1-i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.010661265432098766}
#island_id: 1
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr2][i%N]
    
    priorities[i][0] = total_spin * 0.5
    priorities[i][1] = -total_spin * 0.5
    
  return(priorities)




#score: {'data2D.txt': 0.16525478395061755}
#island_id: 1
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.07039336419753092}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    # Add interaction with the site to the left and right (if exists)
    if i % N != 0:
      j = i % N - 1
      left, right = J[1, i%N, :2]
      total_spin += left.sum()
      total_spin /= (4 + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33865015432098666}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    # Calculate the priority based on the magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - len([k for k in range(4) if J[k, i%N, l] < 0]), total_spin + len([k for k in range(4) if J[k, i%N, l] > 0])]
    else:
      priorities[i] = [-total_spin + len([k for k in range(4) if J[k, i%N, l] > 0]), -total_spin - len([k for k in range(4) if J[k, i%N, l] < 0])]
  
  return(priorities)




#score: {'data2D.txt': -0.33362978395061627}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.056942129629629655}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority = np.array([-total_spin, total_spin]) * (h[i//N][i%N] > 0)
    
    priorities[i] = priority
  
  for j in range(N):
    for i in range(N**2):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16545941358024718}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.16574398148148173}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_col][i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_neighbors = np.sum(np.abs(J[:,i%N,i//N]))
    total_spin /= (2 + total_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism to priority
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09154182098765441}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    site_magnetism = h[i//N][i%N]
    
    spin_priority = (site_magnetism + total_spin) / 2
    
    priorities[i][1] = spin_priority
    priorities[i][0] = -spin_priority
    
  return(priorities)




#score: {'data2D.txt': -0.08351682098765431}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    site_magnetism = h[i//N][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        site_magnetism += 1
      else:
        site_magnetism -= 1
        
    priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
    priorities[i][0] = -priorities[i][1]
    
  return(priorities)




#score: {'data2D.txt': 0.03718472222222224}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][0] = -priorities[i][1] - total_spin
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][1] = -priorities[i][0] + total_spin
   
  return(priorities)




#score: {'data2D.txt': 0.08133256172839512}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2 - J[1,i//N,i//N]
      priorities[i][0] = -priorities[i][1]
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2 + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.1625751543209879}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i // N) % N
    site_nbr_col = i % N
    if J[3,site_nbr_col,site_nbr_row] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin from magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Assign spin based on priority
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1980516975308642}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982109567901235}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17393194444444451}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = ((i//N+k-2)%N), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for j in range(2):
      if i//N > 0:
        l = i//N - 1
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
        l = i//N + 1
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Sum up the interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism at the site
    total_spin += h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priorities based on magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11477114197530879}
#island_id: 1
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0 and J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    elif J[0,i%N,i//N] < 0 and J[3,i%N,i//N] < 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.11256959876543224}
#island_id: 1
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] /= 4
    priorities[i][1] /= 4
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.11216496913580261}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i] = [total_spin, -total_spin]
      else:
        priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = ((i//N + ((k-1)%2 - 1)) % N) * N + (i%N)
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Update priorities based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0018492283950617293}
#island_id: 3
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
  return(priorities)




#score: {'data2D.txt': 0.09523441358024706}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a further bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] += abs(h[i//N][i%N]) * 2
    else:
      priorities[i][1] -= abs(h[i//N][i%N]) * 2
    
  return(priorities)




#score: {'data2D.txt': 0.11584243827160508}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = i // N
    site_nbr_col = i % N
    
    for j in range(N):
      if J[3,site_nbr_col,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017007716049382718}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in [0,1,2]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]

    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.2301239197530864}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally up and left (if exists)
    if i % N > 0 and i//N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[3, i%N-1, i//N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally up and right (if exists)
    if i % N < N-1 and i//N > 0:
      j = i//N - 1
      l = i%N + 1
      if J[3, i%N+1, i//N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally down and left (if exists)
    if i % N > 0 and i//N < N-1:
      j = i//N + 1
      l = i%N - 1
      if J[3, i%N-1, i//N+1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally down and right (if exists)
    if i % N < N-1 and i//N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[3, i%N+1, i//N+1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (8 - int(i//N > 0) - int((i%N-1)%2 == 0) - int((i%N+1)%2 == 0) - int(i//N < N-1) - int((i%N-1)%2 == 0) - int((i%N+1)%2 == 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias for sites with no neighbors
    if i % N == 0 or i % N == N-1 or (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.1872470679012347}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and adjust for boundary conditions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Adjust for boundary conditions
      if k == 0 and i//N > 0: 
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if k == 2 or k == 3: 
        j = i//N + ((k-2)%2 - 1)
        l = i%N
        if J[k, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Add a bias for sites with no neighbors
  for i in range(N**2):
    if (i % N == 0 or i % N == N-1) and (i//N) % N != 0 and (i//N) % N != N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
      
    if (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.25
      priorities[i][1] -= 0.25
        
  return(priorities)




#score: {'data2D.txt': 0.07263441358024697}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.07079089506172843}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spins that align with local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin-1]
    else:
      priorities[i] = [-total_spin-1, total_spin+1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11559922839506186}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * (h[site_nbr][i%N] == h[i//N][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0018492283950617293}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 * N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1048091049382717}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] > 0:
        total_spin -= 1
      elif (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] < 0:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0006692901234567905}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i//N,N-1-(i%N)] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 1
    
  return(priorities)




#score: {'data2D.txt': -0.0007711419753086419}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  # Sort the priority list by spin value
  priorities = priorities[np.argsort(priorities[:,0])]
  
  return priorities




#score: {'data2D.txt': -0.03794737654320987}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': 0.11632885802469149}
#island_id: 1
#version_generated: 2
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[0,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with other sites on the same row and column
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Adjust priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11150694444444458}
#island_id: 1
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr1 = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr1][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism and interaction
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.005365586419753086}
#island_id: 3
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + int(i % N == 0)) * abs(h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 - int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Additional consideration for the priority
    if np.sum(neighbors_spin) > 0:
      priorities[i][1] += 1
    elif np.sum(neighbors_spin) < 0:
      priorities[i][0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Sum up interactions from 4 nearest neighbors
    for j in range(4):
      total_spin += J[j,i//N,i%N]
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0036350308641975313}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum([J[k,i//N,i%N] * (h[(i+k)%N][k]%N) for k in range(4)])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2.0
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0023782407407407402}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][j] > 0:
        total_spin += J[3,i%N,j]
      else:
        total_spin -= J[3,i%N,j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11042916666666679}
#island_id: 3
#version_generated: 2
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        total_spin -= 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1048091049382717}
#island_id: 3
#version_generated: 2
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
     if J[k,i%N,i//N] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    for k in [2, 3]:
     if (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] > 0:
      total_spin -= 1
     elif (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] < 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin from magnetism and nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N] * h[site_nbr][i%N]
    
    # Calculate priority based on magnetism and nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0022674382716049387}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priority based on magnetism and interactions
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [h[site_nbr][i%N], -h[site_nbr][i%N]]
    else:
      priorities[i] = [-h[site_nbr][i%N], h[site_nbr][i%N]]
    
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        priorities[i][0] += J[k, i//N, i%N]
        priorities[i][1] -= J[k, i//N, i%N]
      else:
        priorities[i][0] -= J[k, i//N, i%N]
        priorities[i][1] += J[k, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_1 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr_2 = (i % N + ((i//N-1)%2 - 1)) % N
    if i%N > 0:
      total_spin += h[site_nbr_1][i%N]
      total_spin -= h[site_nbr_2][i%N]
    
    if i//N < N-1:
      site_nbr = (i % N + ((i//N+1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10953719135802481}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_list = []
    
    # Sum interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      site_nbr_list.append((i % N + ((k-1)%2 - 1)) % N)
    
    # Sum magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interactions with next nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        site_nbr_list.append(site_nbr)
      else:
        total_spin -= h[site_nbr][j]
    
    # Determine priority for each possible spin assignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.03256558641975308}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = sum(J[:,i//N,i%N]) - 2 * J[3,i//N,i%N]
      priorities[i] = [total_spin, -total_spin]
    else:
      total_spin = sum(J[:,i//N,i%N]) + 2 * J[3,i//N,i%N]
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.01840200617283945}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  # Calculate total spin at each site
  total_spin_sum = np.zeros(2)
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.3359726851851842}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above
    k = 0
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    k = 2
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.000977623456790119}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    neighbor_contributions = []
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        contribution = np.sign(J[k,i%N,l]) * np.sign(h[site_nbr][i%N])
        neighbor_contributions.append(contribution)
    
    for k in [0, 2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        contribution = np.sign(J[k,i%N,l]) * np.sign(h[site_nbr][i%N])
        neighbor_contributions.append(contribution)
    
    total_spin += sum(neighbor_contributions)
    total_spin_sum[0] += sum(x for x in neighbor_contributions if x > 0) / len(neighbor_contributions)
    total_spin_sum[1] += sum(x for x in neighbor_contributions if x < 0) / len(neighbor_contributions)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 7.299382716049382e-05}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = 0
    
    # Add neighbor interactions
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Normalize by the number of neighbors
    priorities[i][0] = total_spin_sum + h[site_nbr][i%N]
    priorities[i][1] = -total_spin_sum - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0003649691358024707}
#island_id: 1
#version_generated: 2
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[s][i%N] if J[k,i%N,i//N]>0 else -h[s][i%N] for s,k in zip(site_nbrs, [3]+list(range(4))))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add the interaction from neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (np.count_nonzero(J[:,i//N,i%N]) + 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k+2,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i] = [h[site_nbr][i%N], -h[site_nbr][i%N]]
  
  # Add interactions with nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i] += np.sum(J[:,i//N,i%N], axis=0)
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16626990740740763}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_top = (i % N + ((N-1)%2 - 1)) % N
    site_nbr_bottom = (i % N + ((0)%2 - 1)) % N
    if J[3,i%N,N-1-i//N] > 0:
      total_spin += h[site_nbr_top][i%N]
      total_spin -= h[site_nbr_bottom][i%N]
    else:
      total_spin -= h[site_nbr_top][i%N]
      total_spin += h[site_nbr_bottom][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time11:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        for j in range(N):
          if i == j*N + site_nbrs[j]:
            priorities[i][0] += h[site_nbrs[j]][j]
            priorities[i][1] -= h[site_nbrs[j]][j]
      else:
        for j in range(N):
          if i == j*N + site_nbrs[j]:
            priorities[i][0] -= h[site_nbrs[j]][j]
            priorities[i][1] += h[site_nbrs[j]][j]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11292361111111124}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Add site magnetism term
    total_spin += h[i//N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.0
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.10487638888888899}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i + ((3)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Add diagonal interactions
    site_nbr3 = (i + ((4)%2 - 1)) % N
    if J[3,i//N,i%N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[3,i//N,i%N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.3373822530864187}
#island_id: 0
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above
    k = 0
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    k = 2
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    k = 3
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    k = 1
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction spin from left and right
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate interaction spin from top and bottom
    for k in range(N):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[3,i%N,k] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    # Set priority based on magnetism and interaction spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 1
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin_sum = np.sum(J[:,i%N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + site_spin_sum, -total_spin - site_spin_sum]
    else:
      priorities[i] = [-total_spin - site_spin_sum, total_spin + site_spin_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.16527083333333356}
#island_id: 1
#version_generated: 2
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Magnetism contribution from site's own magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with next-nearest neighbors (if applicable)
    site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    # Update priorities
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16623780864197557}
#island_id: 1
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr_row][i%N]
    total_spin -= h[site_nbr_col][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
    
    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]

    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin

  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
    
    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16241712962962987}
#island_id: 2
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Swap spin values if total_spin is close to 0
    if np.abs(total_spin) < 0.5:
      priorities[i] = [total_spin, -total_spin]
    elif h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Swap spin order if there is no net magnetism
    if abs(total_spin) < 1e-6:
      priorities[i] = [total_spin, -total_spin]
    elif h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    priorities[i][0] = -abs(total_spin)  # Priority for spin up
    priorities[i][1] = abs(total_spin)     # Priority for spin down
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin_value = -1 if total_spin < 0 else 1
    priorities[i] = [total_spin, 0]
    
  return(priorities)




#score: {'data2D.txt': 0.22919058641975318}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
    
    # Apply nearest neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += J[1,i%N,i//N]
      priorities[i][1] -= J[1,i%N,i//N]
    elif J[3,i%N,i//N] < 0:
      priorities[i][0] += J[3,i%N,i//N]
      priorities[i][1] -= J[3,i%N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  # Add interactions between next nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Improve spin assignments based on current assignment
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i // N % 2 == (i % N + k) % 2:
        priorities[i][1] -= 1
      elif J[k,i%N,i//N] < 0 and i // N % 2 != (i % N + k) % 2:
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16771527777777787}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in range(2):
      j = (i//N + ((k-1)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate priority
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': -0.0005606481481481476}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Normalize by the number of neighbors
    priorities[i][0] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    priorities[i][1] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
  
  return(priorities)




#score: {'data2D.txt': 0.1980516975308642}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.10791990740740752}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16137145061728422}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i] = [total_spin, -total_spin]
    else:
      total_spin = -h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1737368827160496}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,(i+1)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if J[2,(i+N)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if J[3,(i+1)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017473765432098767}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      site_nbr = ((i//N + (k%2 - 1)) % N) * N + (i%N + (k//2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0012526234567901238}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]

  # Sorting the spins based on their energy values
  sorted_indices = np.argsort(priorities, axis=1)
  for i in range(N**2):
    priorities[i] = priorities[i][sorted_indices[i]]

  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [(total_spin + np.sum(neighbors_spin)) * 2, -(total_spin + np.sum(neighbors_spin))]
    else:
      priorities[i] = [-(total_spin + np.sum(neighbors_spin)), (total_spin + np.sum(neighbors_spin)) * 2]
  return (priorities)




#score: {'data2D.txt': -0.3431294753086409}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] += np.sum(neighbors_spin) ** 2
      priorities[i][1] -= np.sum(neighbors_spin) ** 2
    else:
      priorities[i][0] -= np.sum(neighbors_spin) ** 2
      priorities[i][1] += np.sum(neighbors_spin) ** 2
  
  return priorities




#score: {'data2D.txt': 5.540123456790158e-05}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[0, i // N, i % N] * h[site_nbr][i % N]
    total_spin = h[i // N][i % N] + neighbors_spin
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2193884259259259}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.34276959876543106}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += J[2, i%N, l]
      else:
        total_spin -= J[2, i%N, l]
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += J[0, i%N, l]
      else:
        total_spin -= J[0, i%N, l]
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.197765277777778}
#island_id: 1
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # sum the magnetism of all neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # assign higher priority to sites with larger magnetism or more interacting neighbors
    if total_spin > 0 and np.sum([J[k,i%N,i//N] for k in range(4)]) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif total_spin < 0 and np.sum([J[k,i%N,i//N] for k in range(4)]) < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.16518225308641996}
#island_id: 1
#version_generated: 2
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-i%N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.026023302469135808}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if J[3,i//N,i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.00010694444444444484}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
      else:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[site_nbr][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
      else:
        if h[site_nbr][j] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin * 2
    priorities[i][1] = -total_spin * 2
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
        
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust priorities at the boundary sites
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      j = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0, 1), (1, 3), (2, 3), (3, 1)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for neighboring sites and adjust priority
    if i > N:
      site_nbr = (i - N) % N
      total_spin += h[site_nbr][i%N]
    elif i < N*N-N:
      site_nbr = (i + N) % N
      total_spin -= h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust boundary sites' priorities
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    site_state = h[i//N][i%N]
    
    if site_state > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.12433750000000014}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = 0
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        neighbor_sum += 1
      else:
        neighbor_sum -= 1
    total_spin += neighbor_sum/4
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and distance from border sites
    neighbor_count = len(neighbors)
    if i % N == 0 or i % N == N-1 or (i // N) % N == 0 or (i // N) % N == N-1:
      neighbor_count -= 2
    
    total_spin /= neighbor_count
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14076867283950636}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (-1,0), (0,-1)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N, i*N+(i//N+1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
 
  return(priorities)




#score: {'data2D.txt': 0.11547731481481495}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on the total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total spin at each site considering nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate magnetism contribution from neighboring sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 2.237654320987448e-05}
#island_id: 1
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif J[1,i%N,(i-1)%N] < 0:
      total_spin -= 1
    
    if J[2,i%N,(i+1)%N] > 0:
      total_spin += 1
    elif J[2,i%N,(i+1)%N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.2236711419753086}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2236711419753086}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22321496913580244}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.06527608024691361}
#island_id: 0
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    priorities[i][0] = total_spin / (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11553688271604948}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [0, 1] + [(k+1)%2 for k in range(3)]
    for j in neighbors:
      if J[j,i%N,(j+1)%2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.33063626543209784}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      j, l = i//N + k, k
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add diagonal interactions
    for k in [2, 3]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Normalize by the number of neighbors
    total_spin /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + (k-1)%2, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]

    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.23836249999999995}
#island_id: 1
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_bias = 0
    if h[i//N][i%N] > 0:
      spin_bias = -1
    else:
      spin_bias = 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]*h[site_nbr][j]
    
    priorities[i] = [total_spin, total_spin*spin_bias]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33579182098765337}
#island_id: 0
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2, 3]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][total_spin>0] = -sum(np.array([abs(J[j,i//N,i//N]) for j in range(4)])) + abs(total_spin)
    priorities[i][total_spin<0] = sum(np.array([abs(J[j,i//N,i//N]) for j in range(4)]))
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      j = i // N
      if J[k, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority
    priority = [total_spin, -total_spin]
    
    priorities[i] = priority
  
  return(priorities)




#score: {'data2D.txt': -0.004007253086419754}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term to prioritize sites with higher magnetism
    if abs(total_spin) > N//4:
      if h[i//N][i%N] > 0:
        priorities[i][0] -= (abs(total_spin) - N//4)
      else:
        priorities[i][1] += (abs(total_spin) - N//4)
    
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin + h[i//N][i%N]
    priorities[i][1] = -total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.002278858024691359}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      j = (k + 2*i%2) % N
      total_spin += J[k,i//N,j]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.025498919753086418}
#island_id: 1
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(np.sign(J[:,i//N,i//N]))
      priorities[i][1] = -total_spin - np.sum(np.sign(1-J[:,i//N,i//N]))
    else:
      priorities[i][0] = -total_spin - np.sum(np.sign(J[:,i//N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.sign(1-J[:,i//N,i//N]))
    
  return(priorities)




#score: {'data2D.txt': 0.16262885802469157}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N//N-1] > 0:
      priorities[i][0] += h[site_nbr][N//N-1]
      priorities[i][1] -= h[site_nbr][N//N-1]
    else:
      priorities[i][0] -= h[site_nbr][N//N-1]
      priorities[i][1] += h[site_nbr][N//N-1]
  
  return(priorities)




#score: {'data2D.txt': -0.273673919753086}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = np.sum([J[k,i%N,i//N] * h[(site_nbr+k)%N][k%N] for k in range(4)])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism and adjust spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[i//N][i%N]
      priorities[i][1] = -total_spin - h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + h[i//N][i%N]
      priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.12994429012345693}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin - J[0,i//N,i//N]]
    else:
      priorities[i] = [-total_spin - J[0,i//N,i//N], total_spin + J[0,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.11256959876543224}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.009599845679012346}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11429429012345692}
#island_id: 1
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0019047839506172869}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at each site
    spin_bias = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        spin_bias += J[k][i%N][l]
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        spin_bias += J[k][i%N][l]
    
    # Normalize by the number of neighbors
    if i//N > 0: spin_bias /= N
    if i % N == 0 or i % N == N - 1: spin_bias /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [spin_bias + spin_bias/2, -spin_bias - spin_bias/2]
    else:
      priorities[i] = [-spin_bias - spin_bias/2, spin_bias + spin_bias/2]
  
  return(priorities)




#score: {'data2D.txt': 0.1149436728395063}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = (i//N + ((k-1)%2 - 1)) % N
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin_sum += J[k,i%N,l] * h[j][i%N]
    
    # Normalize by the number of neighbors
    if i//N > 0: 
      priorities[i][0] += total_spin_sum / 4
      priorities[i][1] -= total_spin_sum / 4
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_sum/2
      priorities[i][1] -= total_spin_sum/2
    else:
      priorities[i][0] -= total_spin_sum/2
      priorities[i][1] += total_spin_sum/2
  
  return(priorities)




#score: {'data2D.txt': -0.00132175925925926}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interactions with the site above, below, left and right
    for k in range(4):
     j = i//N + ((k-1)%2 - 1)
     if j >= 0 and j < N:
      l = (k+1)%2
      total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    n_neighbors = sum(1 for _ in range(4) if i//N + ((i%N+k-1)%2 - 1) % N == site_nbr)
    priorities[i] = [total_spin/n_neighbors, -(total_spin+1)/n_neighbors]
  
  return(priorities)




#score: {'data2D.txt': 0.0045078703703703695}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = (k+1)%2, ((k-2)%2 - 1)
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = (site_nbr + N) % N
    if i//N < N - 1:
      if J[2, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    j = (site_nbr + N) % N
    if i//N < N - 1 or i%N in [0, N-1]:
      if J[3, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    j = (i//N*N + i%N) % N
    if i % N < N - 1:
      if J[1, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N < N-1) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19743904320987662}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above diagonally (if exists)
    if i % N == 0 or i % N == N - 1 and i//N > 0:
      j = i//N - 1
      if J[3, 0 if i % N == 0 else N-1, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19755416666666673}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.17700972222222236}
#island_id: 0
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0

    # Add magnetism and nearest neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 3
    else:
      total_spin -= 3

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Add interactions with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Add interactions with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Normalize by the number of neighbors
    total_spin /= 5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.002411882716049382}
#island_id: 0
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i%N,i//N], axis=0)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust the boundary sites
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': -0.012104166666666668}
#island_id: 2
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total magnetism and interactions for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbor_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_spin += 1
      else:
        neighbor_spin -= 1
    
    # Calculate priority based on magnetism, interactions and neighbors' spin
    priorities[i][0] = total_spin + neighbor_spin/2
    priorities[i][1] = -total_spin - neighbor_spin/2
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
  
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
  
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a penalty for having different spins in neighboring sites
    site_spin = np.where(J[:, :, i//N] > 0, -1, 1).flatten()[site_nbr]
    if site_spin == h[site_nbr][i%N]:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.3427356481481471}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.34275262345678903}
#island_id: 0
#version_generated: 2
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  return(priorities)




#score: {'data2D.txt': -0.0011652777777777783}
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = len([k for k in range(4) if J[k, i%N, :].sum() < 0]) - len([k for k in range(4) if J[k, i%N, :].sum() > 0])
    else:
      total_spin = len([k for k in range(4) if J[k, i%N, :].sum() > 0]) - len([k for k in range(4) if J[k, i%N, :].sum() < 0])

    priorities[i][1] = -total_spin
    priorities[i][0] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.14076867283950636}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11532453703703717}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(-1, 2):
      for j in range(-1, 2):
        if (k != 0 and j != 0) or abs(k)+abs(j)>1:
          continue
        if J[k + 1, i%N, i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0010739197530864222}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      total_spin += J[k[0], i%N, site_nbr]
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
 
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3297538580246904}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 2 * J[k[0], i%N, site_nbr]
      else:
        total_spin -= 2 * J[k[0], i%N, site_nbr]
    
    # Normalize by the number of neighbors
    total_spin /= (len(neighbors) + 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize the opposite spin when it's high
    if priorities[i][1] > 0.5:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      site_nbr = ((i//N + (k%2 - 1)) % N) * N + (i%N + (k//2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += 1
        site_nbr_sum -= 1
      else:
        total_spin -= 1
        site_nbr_sum += 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + abs(total_spin))
    site_nbr_sum /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.17819398148148172}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Add magnetism and neighbor interactions
    for k in [(0,i//N,i%N),(1,N-1-i//N,i%N),(2,i//N,0),(3,i//N,N-1-i%N)]:
      if J[k[0],k[1],k[2]] > 0:
        site_nbrs.append(1)
      else:
        site_nbrs.append(-1)
    
    # Normalize by the number of neighbors
    total_spin = np.sum(site_nbrs) / len(site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.16603842592592616}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of interactions
    total_spin /= (2 + (h[site_nbr][i%N] > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3390458333333323}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i//N + (k%2 - 1)) % N * N + (i%N + (k//2 - 1)) % N 
                for k in range(4)]
    site_nbrs_weights = [J[k,i//N,i%N] if J[k,i//N,i%N] > 0 else -J[k,i//N,i%N]
                        for k in range(4)]
    
    total_spin = sum(site_nbrs_weights)
    # Normalize by the number of neighbors
    total_spin /= len(site_nbrs_weights)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11702669753086434}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Compute total spin based on site interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Adjust total spin based on magnetism and nearest neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(h[site_nbr])
      priorities[i][1] = -total_spin - np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    
    total_spin = h[site_nbr_row][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.165265277777778}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add contributions from horizontal and vertical neighbors
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add contribution from diagonal neighbor (if exists)
    if i % N < N // 2:  # check if diagonal neighbor exists
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priorities based on magnetism at site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001289043209876543}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[k,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site interactions and magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on site magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return priorities




#score: {'data2D.txt': -0.0011791666666666663}
#island_id: 1
#version_generated: 2
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.33460077160493734}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33460077160493734}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.03704861111111115}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Iterate over each site
  for i in range(N**2):
    total_spin_sum = 0
    # Add interactions with nearest neighbors
    for k in [(i-1)%N if i%N != 0 else N-1, (i+1)%N if i%N != N-1 else 0]:
      j = k % N + ((k//N-1)%2 - 1) * N
      if J[0,k,N-1-i%N] > 0:
        total_spin_sum += 1
      else:
        total_spin_sum -= 1
    # Add magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + 1, -total_spin_sum - 1]
    else:
      priorities[i] = [-total_spin_sum - 1, total_spin_sum + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.018259413580246867}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  # Initialize neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k][i%N][l]
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k][i%N][l]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)) + abs(h[site_nbr][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] *= -1

  return(priorities)




#score: {'data2D.txt': -0.11470540123456803}
#island_id: 1
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    elif magnetism < 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i // N].flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.342745524691357}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # calculate additional term based on site's own spin
    if h[i // N][i % N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Prioritize spins with larger absolute value of the magnetism
  for i in range(N**2):
    if np.abs(priorities[i][1]) > np.abs(priorities[i][0]):
      priorities[i] = [priorities[i][1], -priorities[i][1]]
  
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.22671929012345685}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add an additional term that favors the same spin as the site above
    if i % N > 0:
      if h[(i-1)//N][(i-1)%N] > 0 and h[i//N][i%N] > 0:
        priorities[i][1] += 1
      elif h[(i-1)//N][(i-1)%N] < 0 and h[i//N][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add an additional term that favors the same spin as the site to the left
    if i % N > 0:
      if h[(i-1)//N][(i-1)%N] > 0 and h[i//N][i%N] > 0:
        priorities[i][1] += 1
      elif h[(i-1)//N][(i-1)%N] < 0 and h[i//N][i%N] > 0:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.0013797839506172838}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    
    # Calculate the total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N] + np.sum(neighbors)
    
    # Calculate priority for each possible spin value
    if total_spin > 0:
      priorities[i] = [total_spin - J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
      
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and neighbor interactions
    total_spin = h[site_nbr][i%N]
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Add a bias towards the site's own magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1620356481481484}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr_left = (i % N - 1 + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + 1 + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_up][i%N]
      priorities[i][1] -= h[site_nbr_up][i%N]
    else:
      priorities[i][0] -= h[site_nbr_up][i%N]
      priorities[i][1] += h[site_nbr_up][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_down][i%N]
      priorities[i][1] -= h[site_nbr_down][i%N]
    else:
      priorities[i][0] -= h[site_nbr_down][i%N]
      priorities[i][1] += h[site_nbr_down][i%N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.04053657407407407}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if sum(J[k,i%N,j] for k, j in zip([3], site_nbrs)) > 0:
      priorities[i][0] += sum(h[j][i%N] for j in site_nbrs)
      priorities[i][1] -= sum(h[j][i%N] for j in site_nbrs)
    else:
      priorities[i][0] -= sum(h[j][i%N] for j in site_nbrs)
      priorities[i][1] += sum(h[j][i%N] for j in site_nbrs)
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    site_nbr_neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.04450416666666667}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.sum(J[:,site_nbr,i//N])
      priorities[i][1] -= np.sum(J[1:,site_nbr,i//N])
    else:
      priorities[i][0] -= np.sum(J[1:,site_nbr,i//N])
      priorities[i][1] += np.sum(J[:,site_nbr,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.3368229938271595}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
  
  # Improve the algorithm by considering the global magnetism
  global_magnetism = np.sum(h)
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] += [global_magnetism, -global_magnetism]
    else:
      priorities[i] += [-global_magnetism, global_magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i][0] = spin_bias
      priorities[i][1] = -spin_bias
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i][0] = -spin_bias
      priorities[i][1] = spin_bias
  return(priorities)




#score: {'data2D.txt': 0.20269583333333338}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int(i//N < N//2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21019614197530864}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left and right (if exists)
    if i%N > 0:
      j = i//N
      if J[3, i%N-1, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[2, i%N, i%N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 + int(i//N > 0) + int(i//N < N//2) + int(i%N > 0) + int(i%N < N-1))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.1371208333333335}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        if h[j][l] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
      else:
        if h[j][l] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          
  return(priorities)




#score: {'data2D.txt': 0.18250725308641982}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int(i//N < N//2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09038688271604947}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.013313117283950618}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.5
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.07541188271604941}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    total_magnetism = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        total_magnetism += h[site_nbr][i%N]
      else:
        total_spin -= 1
        total_magnetism -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= 4
    total_magnetism /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+total_magnetism, -total_spin+total_magnetism]
    else:
      priorities[i] = [-total_spin+total_magnetism, total_spin+total_magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.0062541666666666666}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.147665277777778}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.0771467592592593}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[0:i//N+1,i//N]), -total_spin + np.sum(J[1:i//N+1,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[2:i//N+1,i//N]), total_spin + np.sum(J[3:i//N+1,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.exp(total_spin + np.sum(J[:,i//N,i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.exp(-total_spin - np.sum(J[:,i//N,i//N]))
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.09038688271604947}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    
    # Add a term to favor the same spin as neighboring sites
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][h[site_nbr][i%N] > 0] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.06419830246913585}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[[0,1],i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[[0,1],i//N,i//N])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0033665123456790126}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (4 + np.sum(np.abs(h.flatten())))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    up_spin = 0
    down_spin = 0
    left_spin = 0
    right_spin = 0
    
    # Calculate the spin contributions from each neighbor
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if k == 0: 
          up_spin += 1
        elif k == 1: 
          right_spin += 1
        elif k == 2: 
          down_spin += 1
        else: 
          left_spin += 1
      else:
        if k == 0: 
          up_spin -= 1
        elif k == 1: 
          right_spin -= 1
        elif k == 2: 
          down_spin -= 1
        else: 
          left_spin -= 1
    
    # Calculate the total spin and assign priorities based on it
    if h[i//N][i%N] > 0:
      priorities[i] = [up_spin + right_spin + down_spin + left_spin, -(up_spin + right_spin + down_spin + left_spin)]
    else:
      priorities[i] = [-up_spin - right_spin - down_spin - left_spin, up_spin + right_spin + down_spin + left_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.33873533950617185}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    num_neighbors = np.count_nonzero(J[:,i%N,i//N])
    if num_neighbors > 0:
      total_spin /= (2 * num_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Iterate over each site in the grid
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Set priorities based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.12571805555555574}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1613186728395064}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.12582453703703717}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          total_spin_up += 1
        else:
          total_spin_down -= 1
      else:
        if h[site_nbr][i%N] > 0:
          total_spin_down -= 1
        else:
          total_spin_up += 1
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up + 1, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down + 1]
  
  return(priorities)




#score: {'data2D.txt': -0.06056157407407407}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
    for j in range(4):
      site_nbr2 = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] += total_spin / 4
    priorities[i][1] -= total_spin / 4
  
  return(priorities)




#score: {'data2D.txt': 0.2242226851851853}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.19855169753086427}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    for k in [2,3]:
      j = (i//N + ((k-2)%2 - 1)) % N
      if J[k,i%N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19957824074074076}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    if i//N > 0:
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i//N - 1) * N + ((i%N+1)%N)
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below, taking into account edge cases
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.20052824074074077}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    for k in range(2):
      j = (i//N + ((k-1)%2 - 1)) % N
      if i//N > 0:
        if J[k,i%N,i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33865015432098666}
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
     j = i//N - 1
     above, below = J[3, i%N, :2]
     total_spin += above.sum()
     total_spin /= (4 + int(i//N > 0))
    
    # Calculate the priority based on the magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin - len([k for k in range(4) if J[k, i%N, l] < 0]), total_spin + len([k for k in range(4) if J[k, i%N, l] > 0])]
    else:
     priorities[i] = [-total_spin + len([k for k in range(4) if J[k, i%N, l] > 0]), -total_spin - len([k for k in range(4) if J[k, i%N, l] < 0])]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin_up += 1
        total_spin_down -= 1
      else:
        total_spin_up -= 1
        total_spin_down += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down]
  
  return(priorities)




#score: {'data2D.txt': -0.13874243827160512}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interaction = 0
    magnetism = h[i//N][i%N]
    
    if J[0,i%N,i//N] > 0:
      interaction += 1
    else:
      interaction -= 1
    
    if i % N < N-1 and J[1,i%N,i//N] > 0:
      interaction += 1
    elif i % N < N-1 and J[1,i%N,i//N] <= 0:
      interaction -= 1
    
    if i // N < N-1 and J[2,i//N,i%N] > 0:
      interaction += 1
    elif i // N < N-1 and J[2,i//N,i%N] <= 0:
      interaction -= 1
    
    if (i+1) % N < N and (i+N) % N < N*N and J[3,(i+1)%N,i//N] > 0:
      interaction += 1
    elif (i+1) % N < N and (i+N) % N < N*N and J[3,(i+1)%N,i//N] <= 0:
      interaction -= 1
    
    if magnetism > 0:
      priorities[i][0] = -interaction
      priorities[i][1] = interaction
    else:
      priorities[i][0] = interaction
      priorities[i][1] = -interaction
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Check the magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin+1]
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term and sum the interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
    
    priorities[i][0] = total_spin + h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.001706327160493827}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] += 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.08174182098765438}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute the interaction with the left and right neighbors
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if i % N != 0: 
      site_nbr = (i-1)%N
      if J[0,i%N,site_nbr//N] > 0:
        total_spin += h[site_nbr][site_nbr%N]
      else:
        total_spin -= h[site_nbr][site_nbr%N]

    # Compute the interaction with the top and bottom neighbors
    if i // N != 0: 
      site_nbr = (i - N) % (N*N)
      if J[1,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    # Compute the interaction with the top-left and bottom-right neighbors
    if i % N != 0 and i // N != 0: 
      site_nbr = (i - N - 1) % (N*N)
      if J[2,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    # Compute the interaction with the top-right and bottom-left neighbors
    if i % N != N - 1 and i // N != 0: 
      site_nbr = (i - N + 1) % (N*N)
      if J[3,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = ((i + (N-1)) % N)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.07918101851851858}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + J[0, i//N, i%N]]
  
  return priorities




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.12847638888888907}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_up = 1
    else:
      priority_up = -1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        priority_nbr = 1
      else:
        priority_nbr = -1

      priorities[i][0] += h[site_nbr][i%N] + priority_up * J[3, i%N, (i+1)%N] + J[k, i%N, l] * priority_nbr
      if h[i//N][i%N] > 0:
        priorities[i][1] -= 1 - 2 * priority_up * priority_nbr
      else:
        priorities[i][1] += 1 - 2 * priority_up * priority_nbr

  return(priorities)




#score: {'data2D.txt': 0.22053749999999994}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N - 1
    l = i%N
    if i//N > 0 and J[2, i%N, i%N] > 0:
      total_spin += 1
    elif i//N > 0:
      total_spin -= 1
    
    j = i//N - 1
    l = (i%N + 1) % N
    if i//N > 0 and i % N < N-1 and J[3, i%N, l] > 0:
      total_spin += 1
    elif i//N > 0 and i % N < N-1:
      total_spin -= 1
    
    j = i//N - 1
    l = (i%N - 1) % N
    if i//N > 0 and i % N < N-1 and J[2, i%N, l] > 0:
      total_spin += 1
    elif i//N > 0 and i % N < N-1:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 6.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.05670416666666667}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum(J[:,i//N,i%N]) + 1, -np.sum(J[:,i//N,i%N]) - 1]
    else:
      priorities[i] = [-np.sum(J[:,i//N,i%N]), np.sum(J[:,i//N,i%N])]
  
  return(priorities)




#score: {'data2D.txt': 0.06911898148148155}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    up_spin = 0
    down_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          up_spin += 1
        else:
          up_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          up_spin += 1
        else:
          up_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          down_spin += 1
        else:
          down_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + up_spin - down_spin, -total_spin - up_spin + down_spin]
    else:
      priorities[i] = [-total_spin - up_spin + down_spin, total_spin + up_spin - down_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(1 if J[k,i%N,i//N] > 0 else -1 for k in range(4))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.004379166666666667}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i%N,i//N] * (h[i//N][i%N] > 0) - J[1,i%N,i//N] * (h[i//N][i%N] < 0)
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 1.0030864197531186e-05}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin = 1
    elif J[0,i%N,i//N] < 0:
      total_spin = -1
    else:
      total_spin = np.tanh(J[1,i%N,i//N]*h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.045272376543209904}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
    
    # Add a bias term based on the current magnetization
    if np.sum(priorities[:i]) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif np.sum(priorities[:i]) < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.07995231481481486}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 4
    priorities[i][0] = total_spin * sum([J[k,i%N,i//N] for k in range(4)]) / (1.0 * sum(h[i//N]))
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34273410493827056}
#island_id: 0
#version_generated: 2
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a bonus for aligning with the spins of neighboring sites
    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[float('-inf'), float('inf')] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.34273873456790016}
#island_id: 0
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the average spin of neighbors
    avg_spin = np.mean(neighbors_spin)
    if avg_spin > 0:
      priorities[i][1] += avg_spin
    else:
      priorities[i][0] -= avg_spin
  
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3-i%N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16467577160493851}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i-1)%N if i % N != 0 else N-1, (i+1)%N if i % N != N-1 else 0]
    
    for j in site_nbrs:
      if J[3,i%N,j] > 0:
        total_spin += h[j][i%N]
        priorities[i][0] += h[j][i%N]
        priorities[i][1] -= h[j][i%N]
      else:
        total_spin -= h[j][i%N]
        priorities[i][0] -= h[j][i%N]
        priorities[i][1] += h[j][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0006436728395061725}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': -0.004466203703703703}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate the magnetism
    mag = np.sign(total_spin)
    
    # Calculate the priority based on the site interactions and magnetism
    priorities[i] = [total_spin - mag, -total_spin + mag]
  
  return(priorities)




#score: {'data2D.txt': 0.007536574074074074}
#island_id: 1
#version_generated: 2
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbr_sum += h[(i + ((k-1)%2 - 1)) % N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr_sum += h[(i + ((j-1)%2 - 1)) % N][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    site_nbr_sum /= 4.0
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        priorities[i][k] += site_nbr_sum
      else:
        priorities[i][k] -= site_nbr_sum
  
  return(priorities)




#score: {'data2D.txt': -0.0012908950617283954}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias / (2 * np.abs(spin_bias)), -(spin_bias / (2 * np.abs(spin_bias)))]
    else:
      spin_bias = -np.sum(neighbors_spin) - J[2, i//N, i//N]
      priorities[i] = [-(spin_bias / (2 * np.abs(spin_bias))), spin_bias / (2 * np.abs(spin_bias))]
  
  return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
      for j in range(2):
        if h[i//N][i%N] > 0 and j == 1 or h[i//N][i%N] < 0 and j == 0:
          spin_bias += np.sum(neighbors_spin)
          priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    site_nbr = (i // N + ((i%N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.14108225308641995}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(h[:(i//N)+1,(i)%N])
      priorities[i][1] = -total_spin + np.sum(h[:(i//N)+1,(i)%N])
    else:
      priorities[i][0] = -total_spin + np.sum(h[:(i//N)+1,(i)%N])
      priorities[i][1] = total_spin - np.sum(h[:(i//N)+1,(i)%N])
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1.5, -(total_spin + 1.5)]
    else:
      priorities[i] = [-(total_spin - 1.5), total_spin + 1.5]
  
  return priorities




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': -0.338945524691357}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += J[j, i//N, i%N]
      else:
        total_spin -= J[j, i//N, i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.338945524691357}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += J[j, i//N, i%N]
      else:
        total_spin -= J[j, i//N, i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_neighbors = np.count_nonzero(J[:,i%N,i//N])
    total_spin /= (2 * total_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.30459336419753014}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_neighbors = np.count_nonzero(J[:,i%N,i//N])
    if total_neighbors == 0:
      total_spin /= (2 * np.count_nonzero(J[0,:,i//N]))
    else:
      total_spin /= total_neighbors
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04645447530864198}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - sum([J[k,i%N,i//N] for k in [0, 1]]), 
               -total_spin + sum([J[k,i%N,i//N] for k in [0, 1]])]
    else:
      priorities[i] = [-total_spin + sum([J[k,i%N,i//N] for k in [0, 1]]), 
               total_spin - sum([J[k,i%N,i//N] for k in [0, 1]])]
  
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.20476959876543233}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]

  # Additional improvement: If the site has more positive interactions, prioritize 1
  for i in range(N**2):
    pos_interactions = np.sum([J[k,i%N,i//N] > 0 for k in range(4)])
    if pos_interactions > 1:
      priorities[i][0] += (pos_interactions - 1) / 4.0
      priorities[i][1] -= (pos_interactions - 1) / 4.0

  return(priorities)




#score: {'data2D.txt': 0.0729418209876544}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  # Normalize by the number of neighbors in the row
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N]
      priorities[i][1] += J[1,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.2242226851851853}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = []
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append(site_nbr)
    
    # Normalize by the number of neighbors and magnetism
    neighbor_count = len(set([j % N for j in site_nbrs]))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin / (2 * neighbor_count + abs(total_spin)), -total_spin / (2 * neighbor_count + abs(total_spin))]
    else:
      priorities[i] = [-total_spin / (2 * neighbor_count + abs(total_spin)), total_spin / (2 * neighbor_count + abs(total_spin))]
  
  return priorities




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = h[i//N][i%N]
    for k in range(4):
      site_nbr = (i // N + ((k-1)%2 - 1)) % N * N + (i % N)
      site_nbrs.append((site_nbr, J[k, i//N, i%N]))
    
    site_nbrs.sort(key=lambda x: abs(x[1]))
    for _,spin in site_nbrs:
      total_spin += spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.014080092592592592}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    site_nbrs = [(i // N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_interactions = [J[k, i//N, i%N] for k in range(4)]
    total_spin += sum(site_interactions)
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * len([k for k in site_interactions if k != 0]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.3427199074074064}
#island_id: 0
#version_generated: 2
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Calculate the priority based on the majority of neighbors
    neighbor_spin = np.where(neighbors_spin > 0, 1, -1).sum()
    if neighbor_spin > 0:
      priorities[i][1] += 3
    elif neighbor_spin < 0:
      priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': 0.0537054012345679}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  # Add an additional term to prioritize spins that align with the majority of their neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_spin = np.sum(J[:,i%N,i//N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.16135570987654346}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i%N]), -total_spin + np.sum(J[:,i//N,i%N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i%N]), total_spin + np.sum(J[:,i//N,i%N])]
  
  return(priorities)




#score: {'data2D.txt': 0.09926157407407418}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin at each site based on magnetism and interaction
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[:, i//N, i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[:, i//N, i%N])]
  
  return(priorities)




#score: {'data2D.txt': -0.0031671296296296295}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = J[0,site_nbr,i//N] - J[1,site_nbr,i//N]
    else:
      total_spin = J[2,site_nbr,i//N] - J[3,site_nbr,i//N]
    
    priorities[i][0] = total_spin + 2*h[i%N][i//N]
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.000942438271604938}
#island_id: 2
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(J[:,i//N,i//N])
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': -0.011984722222222221}
#island_id: 2
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.5
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      neighbor_total_spin = 0
      for k in range(4):
        site_nbr = (i % N + ((k-1)%2 - 1)) % N
        neighbor_total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      
      if neighbor_total_spin > threshold:
        priorities[i] = [-1, 1]
      else:
        priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site][i%N]
        priorities[i][1] -= h[site][i%N]
      else:
        priorities[i][0] -= h[site][i%N]
        priorities[i][1] += h[site][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.03866651234567904}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  return(priorities)




#score: {'data2D.txt': -0.006605709876543209}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      spin_bias = 1
    else:
      spin_bias = -1
      
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += spin_bias * (J[k,i%N,i//N] - h[site_nbr][i%N])
        priorities[i][1] -= spin_bias * (J[k,i%N,i//N] - h[site_nbr][i%N])
      else:
        priorities[i][0] -= spin_bias * (J[k,i%N,i//N] + h[site_nbr][i%N])
        priorities[i][1] += spin_bias * (J[k,i%N,i//N] + h[site_nbr][i%N])
    
  return(priorities)




#score: {'data2D.txt': 0.21453348765432118}
#island_id: 2
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(np.array([J[k,i//N,i//N]/4 for k in range(4)]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(np.array([J[k,i//N,i//N]/4 for k in range(4)]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.18130015432098787}
#island_id: 2
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
    
  return(priorities)




#score: {'data2D.txt': -0.002830401234567901}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin - 2 * np.sum(neighbors_spin)
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin + 2 * np.sum(neighbors_spin)

  return (priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # Sort the neighbors based on their spins
    sorted_neighbors = np.argsort(neighbors_spin)
    sorted_neighbors_spin = neighbors_spin[sorted_neighbors]
    
    # Update the priority based on the neighbor's spin
    if sorted_neighbors_spin[0] > 0:
      priorities[i][1] -= 2 * len(sorted_neighbors_spin)
    else:
      priorities[i][0] += 2 * len(sorted_neighbors_spin)

  return (priorities)




#score: {'data2D.txt': -0.002361882716049383}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities=np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=(i%N+((i//N-1)%2-1))%N
    neighbors_spin=J[:,i//N,i%N].flatten()
    total_spin=h[site_nbr][i%N]+np.sum(neighbors_spin)
    
    if h[i//N][i%N]>0:
      priorities[i]=[total_spin+np.sum(neighbors_spin),-total_spin+np.sum(neighbors_spin)]
    else:
      priorities[i]=[-total_spin+np.sum(neighbors_spin),total_spin+np.sum(neighbors_spin)]

  return priorities




#score: {'data2D.txt': -0.0015020061728395061}
#island_id: 2
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k,i//N,i//N] * (1 if h[site_nbr][i%N] > 0 else -1) for k in range(4))
    priorities[i][0] = total_spin + sum(J[:,i//N,i//N]) / len(J)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    magnetism = h[i//N][i%N]
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if magnetism > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (magnetism) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (magnetism) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.020227006172839505}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin) - total_spin, -(abs(neighbor_spin) - total_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin) + total_spin, (abs(neighbor_spin) - total_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.0537054012345679}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
  
  return(priorities)




#score: {'data2D.txt': -0.020227006172839505}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(total_spin), -abs(total_spin)]
    else:
      priorities[i] += [-abs(total_spin), abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': -0.03358132716049383}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] = total_spin + abs(total_spin)
      priorities[i][0] = -total_spin
    else:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + abs(total_spin)
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i//N,i%N])
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += abs(neighbor_spin)
      priorities[i][0] -= abs(neighbor_spin)
    else:
      priorities[i][1] -= abs(neighbor_spin)
      priorities[i][0] += abs(neighbor_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.1019236111111112}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      j,l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.020300771604938275}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    # Adjust priority based on site interactions and magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    # Apply a non-linear transformation to improve prioritization
    transformed_spin = (np.tanh(2*total_spin) - np.tanh(-2*total_spin)) / (np.tanh(2) - np.tanh(-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [transformed_spin, -transformed_spin]
    else:
      priorities[i] = [-transformed_spin, transformed_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
    
    # Check for neighboring sites with the same spin and adjust the priority accordingly
    site_nbrs_with_same_spin = [(j, neighbor[1]) for j, neighbor in enumerate(site_nbrs) if flip==neighbor[1]]
    for j, spin in site_nbrs_with_same_spin:
      priorities[i][0] += J[3,i%N,j//N]
    
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))

    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2

  return(priorities)




#score: {'data2D.txt': -0.012875771604938272}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k, i%N, i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))

    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
      # Add a penalty term proportional to the number of neighbors with the same spin
      priorities[i][0] -= sum(1 for neighbor in site_nbrs if neighbor[1]==flip)
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2

  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
  
  return(priorities)




#score: {'data2D.txt': 0.16086558641975332}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + h[i//N][i%N]) / (1.0 * sum(h[i//N])) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.18130015432098787}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        site_nbr_sum -= h[site_nbr][i%N]
      else:
        total_spin -= 1
        site_nbr_sum += h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + site_nbr_sum
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0011816358024691355}
#island_id: 2
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbrs = []
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append((site_nbr, k))
    for i in range(4):
      for j in range(i+1, 4):
        if site_nbrs[i][0] == site_nbrs[j][0]:
          total_spin += J[site_nbrs[i][1],i//N,i//N] - J[site_nbrs[j][1],i//N,i//N]
    # Normalize by the number of neighbors
    total_spin /= 4.0
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16100601851851876}
#island_id: 2
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N]) * h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1.0 / (1.0 * sum(h[site_nbr])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin) - np.sum(J[:,i//N,i//N]) + 1.0 / (1.0 * sum(h[site_nbr]))
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_spin = -total_spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, priority_spin]
    else:
      priorities[i] = [priority_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09142947530864205}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] = total_spin + h[site_nbr][i%N]
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
    # Prioritize -1 spin when the total spin is negative
    if priorities[i][0] < 0:
      priorities[i][::-1]
    
  return(priorities)




#score: {'data2D.txt': -0.08272731481481486}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
    # Add the priority based on the number of neighbors with positive interaction
    total_spin_neighbors = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i % N != (k-1)%N and i // N != ((k-1)//2) - 1:
        total_spin_neighbors += 1
      elif J[k,i%N,i//N] < 0 and i % N != (k-1)%N and i // N != ((k-1)//2) - 1:
        total_spin_neighbors -= 1
    
    priorities[i][0] += total_spin_neighbors
    priorities[i][1] -= total_spin_neighbors
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1123300925925927}
#island_id: 1
#version_generated: 2
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if i < N:
      site_nbr = (i % N + ((N-1)%2 - 1)) % N
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,N-1] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    
    if i >= N*(N-1):
      site_nbr = (i % N + ((0)%2 - 1)) % N
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,0,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = np.array([total_spin, -total_spin])
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.08024675925925936}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is strong, prioritize opposite spin
    if h[i//N][i%N] > 0.5 or (h[i//N][i%N] < -0.5 and np.random.rand() < 0.1):
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_spin_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_spin_sum += 1
      else:
        neighbor_spin_sum -= 1
    total_spin = h[site_nbr][i%N] + neighbor_spin_sum
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.15409120370370386}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (site_nbr1 + 1) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    
    if h[site_nbr2][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]
      priorities[i][1] -= J[3,i//N,i%N]
    
    if i % N != 0:
      site_nbr = (i-1) % N
      if h[site_nbr1][i//N] > 0:
        priorities[i][0] += J[1,i//N,i%N]
        priorities[i][1] -= J[1,i//N,i%N]
    
    if i < N**2 - N:
      site_nbr = (i+N) % N
      if h[site_nbr1][i//N] > 0:
        priorities[i][0] += J[2,i//N,i%N]
        priorities[i][1] -= J[2,i//N,i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': 0.009644598765432093}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  # Add magnetism to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.10863317901234576}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority for each spin value
    if total_spin > 0:
      priorities[i][1] += np.sum(np.sign(J[:,i//N,i%N]))
      priorities[i][0] -= np.sum(np.sign(J[:,i//N,i%N]))
    else:
      priorities[i][0] += np.sum(np.sign(J[:,i//N,i%N]))
      priorities[i][1] -= np.sum(np.sign(J[:,i//N,i%N]))
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      if J[k,i%N,(i//N)%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0006791666666666671}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0: total_spin += 1
        elif k == 1: total_spin -= 1
        elif k == 2: total_spin += 1
        else: total_spin -= 1
      else:
        if k == 0: total_spin -= 1
        elif k == 1: total_spin += 1
        elif k == 2: total_spin -= 1
        else: total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.008968364197530866}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism contribution
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -total_spin - 1
    else:
      priorities[i][0] = -total_spin - 1
      priorities[i][1] = total_spin + 1
    
  return(priorities)




#score: {'data2D.txt': -0.00310354938271605}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
      
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.01884367283950617}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 2 * (h[site_nbr][k] > 0) - 1
      else:
        total_spin -= 2 * (h[site_nbr][k] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.041253549382716054}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      spin_magnetism = -1
    else:
      spin_magnetism = 1
    neighbors_spin = np.sum(J[:,i%N,i//N], axis=0)
    if neighbors_spin > 0:
      priority_1 = total_spin + spin_magnetism
      priority_2 = -total_spin - spin_magnetism
    else:
      priority_1 = total_spin - spin_magnetism
      priority_2 = -total_spin + spin_magnetism
    priorities[i] = [priority_1, priority_2]
  return(priorities)




#score: {'data2D.txt': -0.00903780864197531}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_magnetism = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        if k==0 or k==1: # top and left neighbors
          spin_magnetism -= 1
        elif k==2: # right neighbor
          spin_magnetism += 1
      else:
        total_spin -= 1
        if k==0 or k==1: # top and left neighbors
          spin_magnetism += 1
        elif k==2: # right neighbor
          spin_magnetism -= 1
    priorities[i] = [total_spin+spin_magnetism*h[site_nbr][i%N], -total_spin-spin_magnetism*h[site_nbr][i%N]]
  return(priorities)




#score: {'data2D.txt': -0.10742793209876544}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      site_nbr_nn = ((k+3)%2)*((i%N+((i//N-1)%2 - 1)) % N)
      total_spin += 2 * (J[k,i//N,i%N] > 0) * (h[site_nbr_nn][k] > 0) - 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.004043364197530864}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 2 * (h[site_nbr][k] > 0) - 1
      else:
        total_spin -= 2 * (h[site_nbr][k] > 0) + 1
    for k in range(4):
      if J[k,i%N,(i-1)%N] > 0:
        total_spin += 2 * (h[i//N][k] > 0) - 1
      else:
        total_spin -= 2 * (h[i//N][k] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.06028935185185188}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      site_nbr_neighbors = [(site_nbr + ((k-1)%2 - 1)) % N, (site_nbr + ((k-3)%2 - 1)) % N]
      for neighbor in site_nbr_neighbors:
        if J[0,i%N,neighbor] > 0:
          total_spin += 2 * (h[neighbor][i%N] > 0) - 1
        else:
          total_spin -= 2 * (h[neighbor][i%N] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.012977314814814817}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i%N,i//N]) * (h[site_nbr][i//N] > 0) - 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.19795262345679016}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if j < N - 1 or ((i % N == 0 or i % N == N - 1)):
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1990402777777778}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.013054475308641976}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    total_magnetism = h[i%N][i//N]
    
    if h[i%N][i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      total_magnetism += h[site_nbr][i%N]
    
    priorities[i][0] = total_spin + total_magnetism
    priorities[i][1] = -total_spin + total_magnetism
    
  return(priorities)




#score: {'data2D.txt': 0.16013225308642}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.15036558641975334}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i-1)%N - 1)) % N
    site_nbr_right = (i % N + ((i+1)%N - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr_left][i%N]
      total_spin -= h[site_nbr_right][i%N]
    else:
      total_spin -= h[site_nbr_left][i%N]
      total_spin += h[site_nbr_right][i%N]
    
    if J[1,i//N,i//N] > 0:
      total_spin += h[i%N, site_nbr_left]
      total_spin -= h[i%N, site_nbr_right]
    else:
      total_spin -= h[i%N, site_nbr_left]
      total_spin += h[i%N, site_nbr_right]
    
    if J[2,i//N,(i-1)%N] > 0:
      total_spin += h[i//N, (i-1)%N]
      total_spin -= h[i//N, i%N]
    else:
      total_spin -= h[i//N, (i-1)%N]
      total_spin += h[i//N, i%N]
    
    if J[3,i//N,(i+1)%N] > 0:
      total_spin += h[i//N, (i+1)%N]
      total_spin -= h[i//N, i%N]
    else:
      total_spin -= h[i//N, (i+1)%N]
      total_spin += h[i//N, i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.18069490740740768}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Add interactions with next-nearest neighbors (if N is even)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if N%2 == 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001260956790123457}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = sum(J[k,i//N,i%N]*h[(i+k)%N][j] for j,k in [(j,(3+j)//2) for j in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 0
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    interaction_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        interaction_sum -= 1
      else:
        total_spin -= 1
        interaction_sum += 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_sum, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + interaction_sum]
    
    return(priorities)




#score: {'data2D.txt': 0.1019365740740742}
#island_id: 0
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(np.abs(J[:,i//N,i//N]))
      priorities[i][1] -= np.prod(np.abs(J[:,i//N,i//N]))
    else:
      priorities[i][0] -= np.prod(np.abs(J[:,i//N,i//N]))
      priorities[i][1] += np.prod(np.abs(J[:,i//N,i//N]))
  return(priorities)




#score: {'data2D.txt': 0.18292021604938294}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N]) + J[3,i//N,i//N]) / 4
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N]) + J[3,i//N,i//N]) / 4)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': -0.296551080246913}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  # Add a bonus term to favor the same spin as the site's magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16435540123456818}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][i%N] - h[i//N][i%N])]
  return(priorities)




#score: {'data2D.txt': 0.08103688271604943}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetism = (site_nbr + ((site_nbr-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interaction with next nearest neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_interaction = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_interaction += 1
      else:
        total_interaction -= 1
    site_nbr_interaction = (site_nbr + ((site_nbr-1)%2 - 1)) % N
    if J[0,site_nbr,i//N] > 0:
      priorities[i][0] += total_interaction
      priorities[i][1] -= total_interaction
    else:
      priorities[i][0] -= total_interaction
      priorities[i][1] += total_interaction

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0 and i % N == site_nbr or k == 1 and i // N == site_nbr: 
          if h[i//N][i%N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
        elif k == 2 and (i+1)%N == site_nbr or k == 3 and i//N == (site_nbr-1)%N: 
          if h[i//N][i%N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
        else: 
          if J[k,i%N,i//N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
      else:
        if k == 0 and i % N == site_nbr or k == 1 and i // N == site_nbr: 
          if h[i//N][i%N] > 0:
            total_spin_down += 1
          else:
            total_spin_up += 1
        elif k == 2 and (i+1)%N == site_nbr or k == 3 and i//N == (site_nbr-1)%N: 
          if h[i//N][i%N] > 0:
            total_spin_down += 1
          else:
            total_spin_up += 1
        else: 
          if J[k,i%N,i//N] < 0:
            total_spin_up += 1
          else:
            total_spin_down += 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down]

  return(priorities)




#score: {'data2D.txt': -0.21704120370370372}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.01048348765432099}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.005611265432098765}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if total_spin > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if total_spin > 0:
      priorities[i] = [np.sum(J[:,i//N,i//N]) + N - 1, -N]
    elif total_spin < 0:
      priorities[i] = [-np.sum(J[:,i//N,i//N]), np.sum(J[:,i//N,i//N]) + N - 1]
    else:
      priorities[i] = [N-1, -N]
  return(priorities)




#score: {'data2D.txt': 0.024733179012345678}
#island_id: 1
#version_generated: 2
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if sum(J[3,i%N,j] > 0 for j in range(N)) > 0:
      priorities[i][0] += sum(h[s][i%N] for s in site_nbrs)
      priorities[i][1] -= sum(h[s][i%N] for s in site_nbrs)
    else:
      priorities[i][0] -= sum(h[s][i%N] for s in site_nbrs)
      priorities[i][1] += sum(h[s][i%N] for s in site_nbrs)
    
  return(priorities)




#score: {'data2D.txt': 0.002804783950617285}
#island_id: 1
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N

    total_spin = h[site_nbr_row][i%N] + sum(J[k, i%N, site_nbr_row] for k in range(4)) + sum(J[3, j, i//N] for j in range(N))

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return priorities




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.02373719135802469}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_count = [0,0]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        spin_count[0] += 1
      else:
        total_spin -= 1
        spin_count[1] += 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -spin_count[1]]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.0015850308641975313}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[i//N,k]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][2] - h[i//N][1]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][2] - h[i//N][1])]
  return(priorities)




#score: {'data2D.txt': -0.0032084876543209875}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum((J[k,i//N,i//N]-h[site_nbr][i%N]) for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum((J[k,i//N,i//N]-h[site_nbr][i%N]) for k in range(4))]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in [0,1]: # Up and right neighbors
      if J[k,i%N,i//N] > 0:
        total_spin_up += 1
      else:
        total_spin_up -= 1
    for k in [2,3]: # Down and left neighbors
      if J[k,i%N,i//N] > 0:
        total_spin_down += 1
      else:
        total_spin_down -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up + total_spin_down, -total_spin_up - total_spin_down]
    else:
      priorities[i] = [-total_spin_up - total_spin_down, total_spin_up + total_spin_down]
  return(priorities)




#score: {'data2D.txt': 0.16317052469135826}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  for i in range(N):
   site_nbr = (i % N + ((N-1)%2 - 1)) % N
   if J[3,i,N-1] > 0:
    priorities[i*N+i][0] += h[site_nbr][N-1]
    priorities[i*N+i][1] -= h[site_nbr][N-1]
   else:
    priorities[i*N+i][0] -= h[site_nbr][N-1]
    priorities[i*N+i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the site's magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16480293209876568}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0018933641975308639}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction terms
    interaction_terms = np.sum(J[:,i//N,i%N])
    
    if interaction_terms > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.12924490740740754}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin_sum = np.zeros(2)
    
    # Add interaction with the site above
    j = (i // N - 1) % N + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (1) % 2
      if J[l, i % N, 0] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below
    j = (i // N + 1) % N + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (3) % 2
      if J[l, i % N, 0] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site to the left
    j = (i % N - 1) + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (3) % 2
      if J[1, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site to the right
    j = (i % N + 1) + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (1) % 2
      if J[3, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site above-left
    j = (i // N - 1) % N + ((i // N - 2) % 2 - 1) * N
    k = (1) % 2
    if j >= 0 and j < N:
      l = (3) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site above-right
    j = (i // N - 1) % N + ((i // N - 2) % 2 - 1) * N + N
    k = (3) % 2
    if j >= 0 and j < N:
      l = (1) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below-left
    j = (i // N + 1) % N + ((i // N - 2) % 2 - 1) * N
    k = (3) % 2
    if j >= 0 and j < N:
      l = (1) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below-right
    j = (i // N + 1) % N + ((i // N - 2) % 2 - 1) * N + N
    k = (1) % 2
    if j >= 0 and j < N:
      l = (3) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Normalize by the number of neighbors
    if i // N > 0: total_spin_sum[0] /= (N - 1)
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] /= (N - 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum[0] + total_spin_sum[1]/2, -total_spin_sum[0] - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin_sum[0] - total_spin_sum[1]/2, total_spin_sum[0] + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.13536959876543223}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    if i//N > 0:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j < N**2:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    if i % N > 0:
      l = (3)%2
      if J[1,i%N,(i-1)%N+((i//N-1)%2 - 1)] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j < N:
      l = (1)%2
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: priorities[i][0] += total_spin
    if i % N == 0 or i % N == N - 1: priorities[i][1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][1]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.296551080246913}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])

  # Add a term to the priority based on the sign of the magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.27273410493827177}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N]) + 
                 J[1,i//N,i%N] + J[2,i//N,(i+1)%N]) / 5
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N]) + 
                  J[1,i//N,i%N] + J[2,i//N,(i+1)%N])) / 5
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': -0.09857361111111113}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    total_spin += h[site_nbr][i%N]
    
    if np.sum(J[:, i//N, i%N]) > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.26627669753086436}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': -4.589488082613272e+277}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014251543209876543}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.00543719135802469}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin = (total_spin >= 0).astype(int)
    
    priorities[i][0] = -site_spin
    priorities[i][1] = site_spin
  
  return(priorities)




#score: {'data2D.txt': -0.11641558641975308}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on site interactions (J)
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.2582631172839508}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Add priority based on total spin
  for i in range(N**2):
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.215968364197531}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on interaction strength
    if np.sum(J[:,i//N,i%N]) > 0:
      priorities[i][0] += np.sum(J[:,i//N,i%N]) / 4
      priorities[i][1] -= np.sum(J[:,i//N,i%N]) / 4
    else:
      priorities[i][0] -= np.sum(J[:,i//N,i%N]) / 4
      priorities[i][1] += np.sum(J[:,i//N,i%N]) / 4
  
  return(priorities)




#score: {'data2D.txt': -0.036693672839506176}
#island_id: 2
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on magnetism of neighboring sites
    for j in range(N):
      if h[(i//N)%N][j] > 0:
        priorities[i][0] += 0.5
        priorities[i][1] -= 0.5
      else:
        priorities[i][0] -= 0.5
        priorities[i][1] += 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.16568070987654346}
#island_id: 1
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.05701404320987656}
#island_id: 3
#version_generated: 2
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

    # Add interaction with nearest neighbors to the priority
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.12982762345679028}
#island_id: 3
#version_generated: 2
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in [0,1,2]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.2193884259259259}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0014455246913580293}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on spin correlations
    site_corr = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_corr += 1
      else:
        site_corr -= 1
    priorities[i][0] += site_corr / 2
    priorities[i][1] -= site_corr / 2
    
  return(priorities)




#score: {'data2D.txt': 0.28366064814814834}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.03843564814814815}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Additional priority based on nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k % 2 == 0:
          priorities[i][0] += J[k, i//N, i%N]
        else:
          priorities[i][1] -= J[k, i//N, i%N]
      else:
        if k % 2 == 0:
          priorities[i][0] -= J[k, i//N, i%N]
        else:
          priorities[i][1] += J[k, i//N, i%N]
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.2505248456790125}
#island_id: 2
#version_generated: 2
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k, i//N, i%N]
      else:
        total_spin -= J[k, i//N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Add priority based on total spin
  for i in range(N**2):
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Calculate the magnetism at this site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate the interaction with nearest neighbors
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority for this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.2660927469135805}
#island_id: 2
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_spins = [h[s] for s in site_nbrs]
    total_spin += np.sum([J[k, i//N, i%N]*s for k, s in zip(range(4), site_spins)])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2094155864197533}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Compute total magnetism and interactions for each site
  total_spin = np.zeros(N*N)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin[i] += 1
      else:
        total_spin[i] -= 1
    
    # Add magnetism to the priority
    priorities[i][0] = total_spin[i]
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin[i]
    else:
      priorities[i][1] = total_spin[i]

  return(priorities)




#score: {'data2D.txt': 0.16004768518518542}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnet = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interactions with neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16004768518518542}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  # Add magnetism to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interaction with nearest neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': 0.11822978395061744}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1644643518518521}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += sum(h[site_nbrs[j]][i%N] for j in range(k))
        priorities[i][1] -= sum(h[site_nbrs[j]][i%N] for j in range(k))
      else:
        priorities[i][0] -= sum(h[site_nbrs[j]][i%N] for j in range(k))
        priorities[i][1] += sum(h[site_nbrs[j]][i%N] for j in range(k))
  return(priorities)




#score: {'data2D.txt': -0.0011248456790123455}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': -0.34248070987654217}
#island_id: 0
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
    
    # calculate the absolute difference of neighboring spins
    diff_neighbors = np.abs(np.diff(neighbors_spin)).sum()
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += diff_neighbors * 2
      priorities[i][1] -= diff_neighbors * 2
    else:
      priorities[i][0] -= diff_neighbors * 2
      priorities[i][1] += diff_neighbors * 2
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    # Calculate total spin considering magnetism and neighbor interactions
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:, i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:, i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.03190509259259259}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add a bonus term based on the number of neighboring spins
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k, i//N, i%N]
      else:
        priorities[i][0] -= J[k, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.015297993827160494}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i][0] = total_spin + N*h[i//N][i%N]
      priorities[i][1] = -total_spin
    elif h[i//N][i%N] > 0:
      priorities[i][0] = -N*h[i//N][i%N]
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = N*h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': -0.004717129629629629}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[site_nbr][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[site_nbr][i%N]]
  return(priorities)




#score: {'data2D.txt': -0.28802145061728346}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin - 2*np.sum(J[:,i//N,i%N])]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15335293209876558}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_bias = h[site_nbr][i%N]
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + spin_bias, -total_spin - spin_bias]
    else:
      priorities[i] = [-total_spin - spin_bias, total_spin + spin_bias]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + magnetism, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': -0.07695787037037041}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][i%N] - h[i//N][i%N])]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = np.flip(priorities[i])
  return(priorities)




#score: {'data2D.txt': 0.16435540123456818}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = 0
    total_spin_right = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0 or (k==1 and i%N!=0) or (k==2 and i//N!=i//N-1) or (k==3 and i%N!=N-1):
          total_spin_left += 1
        else:
          total_spin_right += 1
      else:
        if k == 0 or (k==1 and i%N!=0) or (k==2 and i//N!=i//N-1) or (k==3 and i%N!=N-1):
          total_spin_left -= 1
        else:
          total_spin_right -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_left + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin_right]
    else:
      priorities[i] = [-total_spin_left, total_spin_right + (h[site_nbr][i%N] - h[i//N][i%N])]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin from J and magnetism
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the site interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0670405864197531}
#island_id: 1
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for i in range(N**2) for j in range(N)]
  
  for i in range(N**2):
    total_spin = h[site_nbrs[i]][i%N]
    
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.29417854938271626}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Check if the spins can be aligned
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[:,i%N]) / 3
    else:
      total_spin = -(np.sum(h[:,i%N]) / 3)
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.04140354938271607}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  # Compute the priority difference
  for i in range(N**2):
    priorities[i][1] -= priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.2793763888888891}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N] + np.sum(J[:, i//N, i%N]) * total_spin
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N] - np.sum(J[:, i//N, i%N]) * total_spin
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.28366064814814834}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.28509120370370394}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.3427186728395051}
#island_id: 0
#version_generated: 2
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's nearest neighbors' spins
    for j in range(4):
      if J[j, i//N, i//N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.2172254629629629}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = -1
    else:
      total_spin = 1
      
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
     j, l = i//N + k - 1, i%N
     if J[k,i%N,l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
     j = i//N - 1 + k
     l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
     if J[3, i%N, l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 9
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
   
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.22647422839506168}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (7 + np.count_nonzero(h[i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.12044552469135816}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h_site - sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.06214768518518519}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h_site - sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.13712608024691378}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3) for k in range(N)])
      priorities[i][0] = total_spin
      priorities[i][1] -= len([j for j in range(3) if J[j, i % N, i // N]>0])
    else:
      total_spin -= sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3) for k in range(N)])
      priorities[i][0] = -total_spin
      priorities[i][1] += len([j for j in range(3) if J[j, i % N, i // N]>0])
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_k = (k+N-1)%N
      if J[k,i%N,i//N] > 0:
        h_k = h[site_k][i%N]
      else:
        h_k = -h[site_k][i%N]

      priorities[i][0] += h_site + h_k
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.22411064814814807}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + ((k-1)%2 - 1), (k+1)%2
      if J[k,i%N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for k in range(2):
      j, l = i//N + (k+1)%2, i%N - (k-1)%2
      if J[2*i%2,k,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.222611574074074}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1:
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-2 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-2 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22303842592592585}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2228100308641976}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': -0.07532854938271609}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin - 1]
    else:
      priorities[i] = [-total_spin - 1, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': -0.0018313271604938272}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    total_spin += h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.2178668209876543}
#island_id: 0
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j = i//N + k - 1
      l = i%N
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if j > 0 and l < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 6
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16575663580246935}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((0)%2 - 1)) % N
    
    if h[site_nbr_left][i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if h[site_nbr_right][i%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16501250000000023}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate spin interactions from the left and right
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate spin interactions from the top and bottom
    site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if i != 0 and i < N**2-N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3,i%N,(i-1)%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.008915277777777775}
#island_id: 2
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      site_nbr_k = (site_nbr + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr_k][i%N]
    
    priorities[i][0] = h[site_nbr][i%N] + total_spin
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0004291666666666669}
#island_id: 2
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(4):
      if k == 0 and i % N != 0:
        h_site += J[k,i%N,i//N]*h[(site_nbr + N)%N][i%N]
      elif k == 1 and (i // N) * N + i % N - 1 < N**2 - N:
        h_site += J[k,i%N,i//N]*h[site_nbr][((i+N-1)%N)]
      elif k == 2 and (i // N) * N + i % N + 1 >= 0:
        h_site += J[k,i%N,i//N]*h[site_nbr][((i-1)%N)]
      else:
        h_site += J[k,i%N,i//N]*h[(site_nbr+N-1)%N][(i+1)%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add second nearest neighbor interactions (if any)
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Normalize by the number of neighbors
    total_neighbors = 4 if i % N == 0 or i % N == N-1 else 8
    for j in range(2):
      priorities[i][j] /= total_neighbors
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.30986898148148123}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i % N
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,i//N,site_nbr_row] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i%N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i%N+1)%N - 1)) % N
    if J[0,i//N,site_nbr_left] > 0:
      total_spin += 1
    elif J[0,i//N,site_nbr_right] > 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    site_nbr_up = (i // N + ((i % N-1)%2 - 1)) % N
    site_nbr_down = (i // N + ((i % N+1)%N - 1)) % N
    if J[3,i//N,site_nbr_up] > 0:
      total_spin += 1
    elif J[3,i//N,site_nbr_down] > 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16043842592592614}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.3427356481481471}
#island_id: 0
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's own spin
    if neighbors_spin.mean() > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's magnetism if it is strong
    if abs(h[i//N][i%N]) > 1.5:
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0013779320987654317}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    # Calculate the total spin at this site
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    # Calculate the priorities for each spin state
    if total_spin >= 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin - 2 * (h[site_nbr][i%N] > 0) - 1 * (np.sum(neighbors_spin) < 0)
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 2 * (h[site_nbr][i%N] > 0) + 1 * (np.sum(neighbors_spin) < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.28601126543209826}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
  
  return(priorities)




#score: {'data2D.txt': -0.018455092592592606}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1 if h[i//N][i%N] * h[site_nbr][i%N] < 0 else -1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1 if h[i//N][i%N] * h[site_nbr][i%N] > 0 else 1

  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0012770061728395064}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-site_energy)
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = 1 - np.exp(site_energy)

  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add more energy terms from J
    for j in range(3):
        if i//N != 0 and (i-1)%N == j:
            site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
            site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
            site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.1649069444444446}
#island_id: 1
#version_generated: 2
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add interactions with nearest neighbors
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,1,3]]
    for j in site_nbrs:
      if J[0,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with diagonally neighboring sites
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [4,5]]
    for j in site_nbrs:
      if J[3,i//N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.006232561728395062}
#island_id: 1
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      neighbors_spin = 0
      for k in range(4):
        neighbors_spin += J[k,i%N,i//N]
      priorities[i][0] = neighbors_spin
      priorities[i][1] = -neighbors_spin
      
    else:
      neighbors_spin = 0
      for k in range(4):
        neighbors_spin -= J[k,i%N,i//N]
      priorities[i][0] = -neighbors_spin
      priorities[i][1] = neighbors_spin
  
  return(priorities)




#score: {'data2D.txt': 0.1661791666666669}
#island_id: 1
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%N - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr_left][i%N]
      total_spin -= h[site_nbr_right][i%N]
    else:
      total_spin -= h[site_nbr_left][i%N]
      total_spin += h[site_nbr_right][i%N]
    
    site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%N - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[i%N,site_nbr_up]
      total_spin -= h[i%N,site_nbr_down]
    else:
      total_spin -= h[i%N,site_nbr_up]
      total_spin += h[i%N,site_nbr_down]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.012360339506172806}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[l,i%N,0] * h[site_nbr][j]
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[l,i%N,0] * h[site_nbr][j]
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[1,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[3,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.3427368827160483}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)
    
    # Add a bonus for aligning with the majority of the neighbors
    if np.sum(neighbors_spin) > 0:
      priorities[i][1] += np.sum(neighbors_spin)
    else:
      priorities[i][0] += np.sum(neighbors_spin)

  return(priorities)




#score: {'data2D.txt': -0.007752314814814814}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0, i//N, i//N] > 0:
      total_spin += J[0, i//N, i//N]
      priorities[i] = [-total_spin + 2 * np.exp(-total_spin), total_spin - 2 * np.exp(total_spin)]
    else:
      total_spin -= J[1, i//N, i//N]
      priorities[i] = [total_spin - 2 * np.exp(total_spin), -total_spin + 2 * np.exp(-total_spin)]

  return(priorities)




#score: {'data2D.txt': 0.34275262345678903}
#island_id: 0
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + J[0, i//N, i//N]
      priorities[i][1] = -total_spin + J[1, i//N, i//N]
    else:
      priorities[i][0] = -total_spin + J[2, i//N, i//N]
      priorities[i][1] = total_spin + J[3, i//N, i//N]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  return(priorities)




#score: {'data2D.txt': 0.1853757716049385}
#island_id: 0
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  # Add a bonus for aligning with the nearest neighbor in each direction
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-np.sum(priorities[i//N*N:(i//N+1)*N, 0]))
      priorities[i][0] -= 2 * np.exp(np.sum(priorities[i//N*N:(i//N+1)*N, 1]))
    else:
      priorities[i][0] += 2 * np.exp(-np.sum(priorities[i//N*N:(i//N+1)*N, 1]))
      priorities[i][1] -= 2 * np.exp(np.sum(priorities[i//N*N:(i//N+1)*N, 0]))

  return(priorities)




#score: {'data2D.txt': -0.28239922839506126}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Sort the sites based on their spin energy
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = sorted((priorities[i][0], priorities[i][1]), reverse=True)
    else:
      priorities[i][0], priorities[i][1] = sorted((priorities[i][0], priorities[i][1]))

  return(priorities)




#score: {'data2D.txt': 0.09345385802469144}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]<0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]<0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.21528811728395067}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': -0.11744706790123469}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate priority based on magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.16393040123456815}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    neighbor_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        neighbor_spin -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        neighbor_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_spin, -total_spin - neighbor_spin]
    else:
      priorities[i] = [-total_spin - neighbor_spin, total_spin + neighbor_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on site and neighbor spin values
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][1] = -total_spin
    priorities[i][0] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.03003595679012347}
#island_id: 2
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    # Calculate site energy based on interactions with neighbors
    site_energy = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Adjust priority based on magnetism and site energy
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy * (1 + abs(h_site))
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy * (1 + abs(h_site))
      priorities[i][1] = -h_site

  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
      
  # Additional processing to improve the algorithm
  for i in range(N2):
    if priorities[i][1] == 1:
      if priorities[i-1][1] == -1 and priorities[(i+1)%N2][1] == 1:
        priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0009121913580246917}
#island_id: 2
#version_generated: 2
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    total_energy = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if total_energy > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -h_site
    
  return(priorities)




#score: {'data2D.txt': -0.043136265432098767}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority = [total_spin, -total_spin]
    
    priorities[i] = [priority[0] + sum(h[j][i%N] for j in range(N) if J[3,i%N,j] > 0), 
             -priority[1] - sum(h[j][i%N] for j in range(N) if J[3,i%N,j] < 0)]
  
  return(priorities)




#score: {'data2D.txt': -0.008888117283950617}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = np.array([total_spin, -total_spin])
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    if J[2,i//N,i%N] > 0:
      priority_total[0] += 1
      priority_total[1] -= 1
    else:
      priority_total[0] -= 1
    
    priorities[i] = priority_total
  return(priorities)




#score: {'data2D.txt': 0.03229490740740742}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin and adjust priorities
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] -= h[site_nbr][i%N]
    
    # Add priority based on magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= 2*total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= h[site_nbr][j]
    
    # Calculate and set final priorities
    if h[i//N][i%N] > 0:
      priorities[i][1] += -total_spin
    else:
      priorities[i][0] += total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.07260972222222228}
#island_id: 3
#version_generated: 2
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.06469305555555557}
#island_id: 3
#version_generated: 2
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + 3 * (J[0,i//N,i//N]+J[2,i//N,i//N])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - 3 * (J[1,i//N,i//N]+J[3,i//N,i//N])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - 3 * (J[0,i//N,i//N]+J[2,i//N,i//N])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + 3 * (J[1,i//N,i//N]+J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.000839043209876543}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Sort the priorities for each site
  priorities = priorities[np.argsort(priorities[:,0])]
  
  return priorities




#score: {'data2D.txt': 0.1585282407407409}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions
    total_spin += sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
    
    # Normalize by the number of neighbors
    total_spin /= 8
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
      priorities[i][0] = total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
    else:
      priorities[i][0] = -total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
      priorities[i][1] = total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.11403688271604952}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add an additional term based on the magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data2D.txt': 0.0004365740740740744}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin_flip_energy = np.sum(np.where(J[:,i//N,i//N]>0, -np.sign(h[i//N][i%N]), np.sign(h[i//N][i%N])))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = spin_flip_energy
      priorities[i][0] = -spin_flip_energy
    else:
      priorities[i][0] = spin_flip_energy
      priorities[i][1] = -spin_flip_energy
  
  return(priorities)




#score: {'data2D.txt': 0.16416959876543233}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr2 = (i % N + ((3-i%2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.10498750000000007}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_bias = 2*h[i//N][i%N]
    priorities[i][0] = total_spin + spin_bias
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.11176466049382727}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-2)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0008217592592592592}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = -np.abs(h_site)
    priorities[i][1] = np.abs(h_site)

  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site=h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002140895061728397}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][k] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': 0.14140354938271624}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with next-nearest-neighbor sites
    site_nbr_nn = (site_nbr + ((i//N+1)%2 - 1)) % N
    if J[0,i%N,(i//N+1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11502052469135816}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2 * (i % N + i // N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22069398148148162}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([total_spin])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([total_spin])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11736959876543222}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[i//N][i%N]
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': -0.07079089506172843}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Add magnetism to the priority
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.0007677469135802473}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([h[k][i%N] for k in range(N) if k != i//N])
      priorities[i][0] = J[0,i//N,i%N]*spin_sum + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([h[k][i%N] for k in range(N) if k != i//N])
      priorities[i][0] = -J[0,i//N,i%N]*spin_sum - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024331790123456793}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.001073611111111111}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    for k in range(4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
     else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0801541666666667}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    energy = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[i//N][i%N]
    
    if energy > 0:
      priorities[i][0] = -energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = energy
      priorities[i][1] = -h_site
    
    # Add the magnetism contribution to the priority
    priorities[i][0] += h_site
    
  return(priorities)




#score: {'data2D.txt': -0.005752623456790124}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
    
    # Add a trick to break the symmetry: assign higher priority to +1 spin if site energy is positive, and to -1 spin if site energy is negative
    if site_energy > 0:
      priorities[i][0] -= 0.01
    elif site_energy < 0:
      priorities[i][1] -= 0.01
  
  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy=h[i//N][i%N]+sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
      
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
      
  return(priorities)




#score: {'data2D.txt': 0.1175260802469137}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = 2*h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0394587962962963}
#island_id: 2
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add additional spin flip priority based on the energy difference between two neighboring sites
    if i % N > 0 and J[1,i%N,(i-N-1)//N] > 0:
      site_energy_diff = sum([J[k,i%N,(i-N-1)//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if J[2,i%N,(i-1)//N] > 0 and i % N < N-1:
      site_energy_diff += sum([J[k,i%N,(i+1)//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if J[3,i%N,i//N] > 0 and i // N < N-1:
      site_energy_diff += sum([J[k,(i+N-1)%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if site_energy_diff > 0:
      priorities[i][0] += site_energy_diff
      priorities[i][1] = 1
    else:
      priorities[i][0] -= site_energy_diff
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.003649845679012346}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -total_spin + h[site_nbr][i%N]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = total_spin - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr1][i%N]
    else:
      h_site = -h[site_nbr1][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.04920169753086421}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-2*h_site) / (np.exp(-2*h_site) + np.exp(2*h_site))
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = 1 - np.exp(-2*h_site) / (np.exp(-2*h_site) + np.exp(2*h_site))

  return(priorities)




#score: {'data2D.txt': 0.189416512345679}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-2*site_energy)
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -np.exp(-2*site_energy)

  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.1437229938271607}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_spins = []
    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        neighbor_spins.append(1)
      else:
        neighbor_spins.append(-1)
    total_spin += sum(neighbor_spins)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:, i//N, i%N]), -total_spin + np.sum(J[1:, i//N, i%N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:1, i//N, i%N]), total_spin + np.sum(J[1:, i//N, i%N])]
    
  return(priorities)




#score: {'data2D.txt': 0.34273873456790016}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2  # increased the bonus from 1 to 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.08026620370370371}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus for aligning with the magnetism at the site
    priorities[i][1] += h[site_nbr][i%N]

    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        if h[neighbor_nbr][i%N] > 0:
          priorities[i][0] += 1
        else:
          priorities[i][1] -= 1
      else:
        if h[neighbor_nbr][i%N] > 0:
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = (np.where(J[0, :, i//N] > 0, 1, -1) 
              + np.where(J[1, :, i//N] > 0, 1, -1)
              + np.where(J[2, :, i//N] > 0, 1, -1)
              + np.where(J[3, :, i//N] > 0, 1, -1)).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.014329166666666669}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    # Calculate the magnetism term
    site_nbr_mag = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_mag][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.09469675925925933}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(N):
      if i//N != 0 and (i-N)%N == j:
        site_energy += J[2,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.08410478395061734}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add a bias term for the magnetism
    if h_site > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.2109483024691358}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22300972222222218}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j = i//N + k - 1
      if 0 <= j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for k in range(2):
      j = i//N + k - 1
      if 0 <= j < N:
        l = i%N - k
        if J[3-k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2109483024691358}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22015509259259253}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34289706790123353}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.23918101851851845}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  for i in range(N):
    for j in range(N//2+1):
      k = (i + ((j-1)%2 - 1)) % N
      priorities[k*N+j][0] += priorities[k*N+N-j-1][0]
      priorities[k*N+j][1] -= priorities[k*N+N-j-1][1]

  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.166851388888889}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for d in [(0,1), (-1,1)]:
      j = i//N + d[0]
      l = i%N + d[1]
      if 0 <= j < N and 0 <= l < N:
        total_spin += J[2 if d == (0,1) else 0, i%N, l] * h[j][l]
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(h==h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22303842592592585}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2055770061728395}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N:
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N and i%N > 0:
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N and i%N < N-1:
        if J[0, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = np.sum(np.where(h[site_nbr], 1, -1))
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.07888009259259265}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07260972222222228}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priorities based on total spin and magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.001845216049382715}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,N//2,N//2+1,N-1]]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': 0.16625015432098791}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[site_nbr][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[site_nbr][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': 0.059460339506172855}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.34074182098765327}
#island_id: 2
#version_generated: 2
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.00013410493827160496}
#island_id: 3
#version_generated: 2
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  # Sort the sites based on their priority
  priorities = priorities[np.argsort(np.sum(priorities,axis=1))]
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.3384337962962953}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[0,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif ((i//N+1)%2 == (site_nbr//N)%2) and (j-(i%N))**2 <= 1:
        site_energy += J[2,(i//N),(i%N)]*h[i//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34108842592592487}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(h[site_nbr][i%N])
      priorities[i][1] = 1
    else:
      priorities[i][0] = (h[site_nbr][i%N])
      priorities[i][1] = -1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
  
  return(priorities)




#score: {'data2D.txt': 0.34289706790123353}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34076219135802366}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
              for j in range(3) if i//N != 0 and (i-1)%N == j)
    site_energy += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
               for j in range(2) if i%N != N-1 and (i-1)%N == j)
    site_energy += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
               for j in range(2) if i//N == N-1 and (i-N)%N == j)

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Compute total spin energy considering nearest neighbors
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at the site
    total_spin += h[site_nbr][i%N]
    
    # Compute priority based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # consider nearest neighbors first
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # then magnetism at the site itself
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.059460339506172855}
#island_id: 3
#version_generated: 2
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Update priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[-1e6 if j%2==i else 1e6 for i in range(2)] for j in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.009964660493827162}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.34074182098765327}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.1986155864197533}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add the priority for the next sites to consider flipping
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,i//N,i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[0,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.0004603395061728403}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002964506172839509}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on interactions with nearest neighbors
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.3408961419753076}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
                  for j in range(3) if i//N != 0 and (i-1)%N == j)
      priorities[i][0] += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
                  for j in range(2) if i%N != N-1 and (i-1)%N == j)
      priorities[i][0] -= sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
                  for j in range(2) if i//N == N-1 and (i-N)%N == j)

    else:
      priorities[i][0] = -sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
                    for j in range(3) if i//N != 0 and (i-1)%N == j)
      priorities[i][0] -= sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
                    for j in range(2) if i%N != N-1 and (i-1)%N == j)
      priorities[i][0] += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
                    for j in range(2) if i//N == N-1 and (i-N)%N == j)

    priorities[i][1] = 1 if h[i//N][i%N] > 0 else -1

  return(priorities)




#score: {'data2D.txt': -0.0011557098765432104}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_plus = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
              for j in range(3) if i//N != 0 and (i-1)%N == j)
    energy_plus += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
              for j in range(2) if i%N != N-1 and (i-1)%N == j)
    energy_plus += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
              for j in range(2) if i//N == N-1 and (i-N)%N == j)
    
    energy_minus = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
               for j in range(3) if i//N != 0 and (i+1)%N == j)
    energy_minus += sum(J[1,i//N,i//N]*h[i//N][i%N] 
               for j in range(2) if i%N != N-1 and i//N == j)
    energy_minus += sum(J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N] 
               for j in range(2) if i//N == 0 and (i+1)%N == j)
    
    priorities[i][0] = -energy_plus + energy_minus
    priorities[i][1] = 1
    
  return(priorities)




#score: {'data2D.txt': 0.0012146604938271576}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    if J[0, i//N, i//N] > 0:
      total_spin -= 2 * h[site_nbr1][i%N]
    else:
      total_spin += 2 * h[site_nbr1][i%N]

    if J[1, (i-1)//N, i//N] > 0:
      total_spin -= 2 * h[site_nbr2][i%N]
    else:
      total_spin += 2 * h[site_nbr2][i%N]

    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34076219135802366}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
             for j in range(3) if i//N != 0 and (i-1)%N == j)
    total_spin += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
              for j in range(2) if i%N != N-1 and (i-1)%N == j)
    total_spin += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
              for j in range(2) if i//N == N-1 and (i-N)%N == j)

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.33322021604938173}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priorities[i][0] -= J[1,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priorities[i][0] += J[2,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priorities[i][0] -= J[3,(i-1)//N,i//N]
      priorities[i][1] = -1
    else:
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priorities[i][0] += J[1,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priorities[i][0] -= J[2,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priorities[i][0] += J[3,(i-1)//N,i//N]
      priorities[i][1] = 1
  
  return(priorities)




#score: {'data2D.txt': 0.3557831790123447}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 1
      for j in range(3):
        if (i-1)%N == j and i//N != 0:
          total_spin += J[1,i//N,j]*h[(i-1)//N][j]
        elif (i-N)%N == j and i//N == N-1:
          total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      total_spin = -1
      for j in range(3):
        if (i-1)%N == j and i//N != 0:
          total_spin -= J[1,i//N,j]*h[(i-1)//N][j]
        elif (i-N)%N == j and i//N == N-1:
          total_spin -= J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.00022793209876543225}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.07425262345679018}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07501033950617289}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.1650634259259262}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.07888009259259265}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0473686728395062}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014662037037037042}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04247083333333336}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002058796296296297}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])*h_site + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])*h_site - J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046535030864197566}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.08586280864197537}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(np.where(J[:,i//N,i//N]<0, 1, 0))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11150848765432106}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Calculate bias term based on local magnetism
    bias = h[i//N][i%N]
    
    # Prioritize spins that align with local magnetism
    priorities[i][1] = total_spin + bias
    priorities[i][0] = -total_spin - bias
  
  return(priorities)




#score: {'data2D.txt': 0.06562083333333336}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0025239197530864204}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_sum = sum([J[0,i%N,i//N]*((site_nbr + ((k-1)%2 - 1)) % N) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + nn_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0008646604938271608}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016791666666666663}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_h = h[nn_site][i%N]
      else:
        nn_h = -h[nn_site][i%N]

      nns.append(J[j,i//N,nn_site]*nn_h)
    if sum(nns) > 0:
      priorities[i][0] = h_site + max([n for n in nns])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nns])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00023719135802469115}
#island_id: 0
#version_generated: 2
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
      priorities[i][0] = (J_up - J_down)*h_site
      priorities[i][1] = -priorities[i][0]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
      priorities[i][0] = (J_up - J_down)*h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.3174069444444438}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
     nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     if J[j,i//N,nn_site] > 0:
       nns.append(J[j,i//N,nn_site])
     else:
       nns.append(-J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009353858024691358}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07501033950617289}
#island_id: 3
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': -0.004094290123456794}
#island_id: 3
#version_generated: 2
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.057388734567901264}
#island_id: 3
#version_generated: 2
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  # Since the Ising model is symmetric, we can reduce the number of calculations
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
  
  return(priorities)




#score: {'data2D.txt': 0.34066651234567796}
#island_id: 2
#version_generated: 2
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] = 1
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] = -1
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
  
  return(priorities)




#score: {'data2D.txt': 0.14475293209876564}
#island_id: 2
#version_generated: 2
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(h[site_nbr][i%N])
      priorities[i][1] = 1
    else:
      priorities[i][0] = (h[site_nbr][i%N])
      priorities[i][1] = -1
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_spin += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.0705106481481482}
#island_id: 3
#version_generated: 2
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
    # Additional improvement: swap the priority if necessary to minimize energy
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
  
  return(priorities)




#score: {'data2D.txt': 0.057388734567901264}
#island_id: 3
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
  # Since the Ising model is symmetric, we can reduce the number of calculations
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
    
  return(priorities)




#score: {'data2D.txt': 0.15929706790123482}
#island_id: 2
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    
    # Add the energy from nearest neighbors
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add the priority for flipping to the next sites
    if i % N > 0 and h[(i-1)//N][(i-1)%N] > 0:
      priorities[i][0] += J[0,(i-1)//N,i//N]
      priorities[i][1] -= 1
    elif i % N > 0 and h[(i-1)//N][(i-1)%N] < 0:
      priorities[i][0] -= J[0,(i-1)//N,i//N]
    
    if i // N < N - 1 and h[(i+1)//N][(i+1)%N] > 0:
      priorities[i][0] += J[3,(i+1)//N,i//N]
      priorities[i][1] -= 1
    elif i // N < N - 1 and h[(i+1)//N][(i+1)%N] < 0:
      priorities[i][0] -= J[3,(i+1)//N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.0123554012345679}
#island_id: 2
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    total_priority = -site_energy
    
    if h[i//N][i%N] > 0:
      total_priority -= 1
    else:
      total_priority += 1
    
    priorities[i][0] = total_priority
    priorities[i][1] = -1 if total_priority < 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.011683487654320987}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00023719135802469115}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -(J_up + J_down)*h_site

  return(priorities)




#score: {'data2D.txt': 0.0007646604938271605}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) + J[3,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)]) - J[3,i//N,i//N]
    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.01349212962962963}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h[i//N][i%N] > 0:
      spin_energy = J_up
    else:
      spin_energy = J_down

    priorities[i][0] = spin_energy * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 2*(h[site_nbr][i%N])
      priorities[i][1] = -total_spin - 2*(h[site_nbr][i%N])
    else:
      priorities[i][0] = -total_spin - 2*(h[site_nbr][i%N])
      priorities[i][1] = total_spin + 2*(h[site_nbr][i%N])
    
  return(priorities)




#score: {'data2D.txt': 0.29325694444444383}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if j == 0 and i//N != 0:
        total_spin += J[0,i//N,0]*h[(i-1)//N][0]
      elif j == 1 and i//N != 0:
        total_spin += J[1,i//N,j%2]*h[(i-1)//N][j%2]
      elif j == 2 and i//N != N-1:
        total_spin += J[2,(i-N)//N,i//N]*h[(i-N)//N][j%2]
      else:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][0]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.010125154320987654}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with all nearest neighbors
    for j in range(4):
      if j == 0 and i//N != 0:
        total_spin += J[j, i//N, i%N]*h[(i-1)//N][(i-1)%N]
      elif j == 1 and i%N != N-1:
        total_spin += J[j, i//N, i%N]*h[i//N][min(i%N+1, N-1)]
      elif j == 2 and i//N != N-1:
        total_spin += J[j, i//N, i%N]*h[max(0, i//N-1), i%N]
      elif j == 3 and (i-N)%N == 0 or (i+N)%N == N*N-1:
        total_spin += J[j, (i-N)//N if (i-N)%N == 0 else (i+N)//N, i%N]*h[(i-N)//N if (i-N)%N == 0 else (i+N)//N][min(i%N+1, N-1)]
    
    priorities[i][0] = -total_spin
    priorities[i][1] = 1 if total_spin > 0 else -1
  
  return(priorities)




#score: {'data2D.txt': 0.2026199074074076}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 1
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin += J[0,i//N,0]*h[(i-1)//N][0]
        elif j == 1 and i//N != 0:
          total_spin += J[1,i//N,j%2]*h[(i-1)//N][j%2]
        elif j == 2 and i//N < N-1:
          total_spin += J[2,(i-N)%N,i//N]*h[(i-N)//N][(i-1)%N]
        elif j == 3 and i//N == N-1:
          total_spin += J[3,(i-N)//N,N-1]*h[(i-N)//N][0]
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      total_spin = -1
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin -= J[0,i//N,0]*h[(i-1)//N][0]
        elif j == 1 and i//N != 0:
          total_spin -= J[1,i//N,j%2]*h[(i-1)//N][j%2]
        elif j == 2 and i//N < N-1:
          total_spin -= J[2,(i-N)%N,i//N]*h[(i-N)//N][(i-1)%N]
        elif j == 3 and i//N == N-1:
          total_spin -= J[3,(i-N)//N,N-1]*h[(i-N)//N][0]
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.16641342592592617}
#island_id: 3
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) 
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term based on the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
    
    # Consider the priority based on the current state of the spins
    if (h[i//N][i%N] > 0 and priorities[i][0] < priorities[i][1]) or (h[i//N][i%N] < 0 and priorities[i][0] > priorities[i][1]):
      # If this site is likely to be aligned with the majority, prioritize it
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
    elif (h[i//N][i%N] > 0 and priorities[i][0] > priorities[i][1]) or (h[i//N][i%N] < 0 and priorities[i][0] < priorities[i][1]):
      # If this site is likely to be anti-aligned with the majority, prioritize it
      if h[i//N][i%N] > 0:
        priorities[i][0] -= 1
      else:
        priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
    
    # Consider the priority of neighboring sites
    for j in range(2):
      site_nbr_2d = (i // N, i % N)
      site_nbr_1d = i // N * N + i % N
      
      if h[i//N][i%N] > 0:
        if priorities[site_nbr_1d][j] > priorities[i][j]:
          priorities[i][j] += (priorities[site_nbr_1d][j] - priorities[i][j])
        elif priorities[site_nbr_1d][j] < priorities[i][j]:
          priorities[i][j] -= (priorities[i][j] - priorities[site_nbr_1d][j])
      
      else:
        if priorities[site_nbr_1d][j] > priorities[i][j]:
          priorities[i][j] -= (priorities[site_nbr_1d][j] - priorities[i][j])
        elif priorities[site_nbr_1d][j] < priorities[i][j]:
          priorities[i][j] += (priorities[i][j] - priorities[site_nbr_1d][j])
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013794753086419744}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    if sum(nn_values) > 0:
      priorities[i][0] = h_site + max([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16518225308641996}
#island_id: 1
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.09454305555555564}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.15541219135802473}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_energies = [h[nn_site][i%N] if J[j,i//N,nn_site] > 0 else -h[nn_site][i%N] for j, nn_site in enumerate(nn_sites)]

    total_energy = sum(x*y for x,y in zip(nn_energies, [1 if h[i//N][i%N] > 0 else -1]*3)) + h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06266064814814815}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.1404871913580247}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy_sum = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy_sum += h[nn_site][i%N]
      else:
        nn_energy_sum -= h[nn_site][i%N]

    total_energy = h[i//N][i%N] + nn_energy_sum
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.05871990740740745}
#island_id: 3
#version_generated: 2
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    
    # Add a term that favors aligning spins with the site's magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07425262345679018}
#island_id: 3
#version_generated: 2
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07455416666666673}
#island_id: 3
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
        priorities[i][0] -= 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.041178240740740744}
#island_id: 3
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h)
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h)
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h)
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h)
  
  return(priorities)




#score: {'data2D.txt': 0.34288688271604834}
#island_id: 2
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 0
      for j in range(4):
        if i//N != 0 and (i-1)%N == j:
          total_spin -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
          total_spin += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
          total_spin -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      total_spin = 0
      for j in range(4):
        if i//N != 0 and (i-1)%N == j:
          total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
          total_spin -= J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
          total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      priorities[i][0] = total_spin
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.28277916666666625}
#island_id: 2
#version_generated: 2
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] = 1
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] = -1
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
    
    # Add a term for the site's own interaction
    if i % N > 0: 
      priorities[i][0] += J[0,(i-1)//N,i//N]*h[i//N][i%N]
    elif i % N == 0:
      priorities[i][0] -= J[3,(i+1)//N,i//N]*h[i//N][i%N]
    
    if i // N > 0: 
      priorities[i][0] += J[2,(i-1)//N,i//N]*h[i//N][i%N]
    elif i // N == 0:
      priorities[i][0] -= J[1,(i+1)//N,i//N]*h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1656881172839509}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + (1 + (i//N-1)%2 - 1)) % N
    
    if h[site_nbr_left][i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if h[site_nbr_right][i%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.007555092592592593}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if np.sum(J[:,i//N,i//N]) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions from all four neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.033701388888888885}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the priority based on the interactions with distant sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Add the priority based on the magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1875470679012347}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0,0.0] for _ in range(N*N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum([J[0,(i//N)%N,i//N]*h[(i//N)%N][j] if j%N != i%N else 0.5*J[1,(i//N)%N,i//N]*h[(i//N)%N][j] for j in range(N)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.2806344135802465}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.009791820987654323}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      priority_plus_one = 0
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priority_plus_one += J[2,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priority_plus_one += J[3,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priority_plus_one += J[1,(i-1)//N,i//N]

      priorities[i][0] = -priority_plus_one
      priorities[i][1] = 1
    else:
      priority_minus_one = 0
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priority_minus_one += J[2,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priority_minus_one += J[3,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priority_minus_one += J[1,(i-1)//N,i//N]

      priorities[i][0] = priority_minus_one
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_sites.append(nn_energy)

    total_energy = sum(nn_sites) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06733873456790126}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,site_nbr,i//N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
      
    priorities[i][0] = total_spin
    priorities[i][1] = -1 if total_spin < 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0019745370370370385}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0002964506172839509}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.057722685185185196}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    if h_site > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.07387021604938272}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2*total_spin

  # Add a correction term to avoid flipping spins unnecessarily
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if np.sum(J[:,i//N,i%N]) > 0:
      priorities[i][0] -= np.abs(np.sum(J[:,i//N,i%N]))/2
      priorities[i][1] += np.abs(np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] += np.abs(np.sum(J[:,i//N,i%N]))/2
      priorities[i][1] -= np.abs(np.sum(J[:,i//N,i%N]))

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3
      priorities[i][1] -= 2 * total_spin
    else:
      priorities[i][0] -= total_spin * 3
      priorities[i][1] += 2 * total_spin

  return(priorities)




#score: {'data2D.txt': -0.004933796296296297}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.05242700617283951}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        priorities[i][0] += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
        priorities[i][1] += 1
    priorities[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -total_energy if sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) < 0 else total_energy
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin[i//N][i%N][0] + 1
      priorities[i][1] = -(total_spin[i//N][i%N][0] + 1)
    else:
      priorities[i][0] = total_spin[i//N][i%N][0] - 1
      priorities[i][1] = -(total_spin[i//N][i%N][0] - 1)

  return(priorities)




#score: {'data2D.txt': 0.0008646604938271608}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0063804012345679}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.009256635802469135}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[1,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11721620370370385}
#island_id: 1
#version_generated: 2
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum(h[site_nbr2][j] for j in range(N))
      priorities[i][1] = -total_spin - sum(-h[site_nbr2][j] for j in range(N))
    else:
      priorities[i][0] = -total_spin + sum(h[site_nbr2][j] for j in range(N))
      priorities[i][1] = total_spin - sum(h[site_nbr2][j] for j in range(N))
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.003023302469135803}
#island_id: 3
#version_generated: 2
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      if J[0,i%N,i//N] > 0:
        h_site = h[site_nbr][i%N]
      else:
        h_site = -h[site_nbr][i%N]

      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        h_site = -h[site_nbr][i%N]
      else:
        h_site = h[site_nbr][i%N]

      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions from neighboring sites
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at the site itself
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': 0.13293009259259275}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][k] > 0:
        total_spin += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][k] < 0:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.00207608024691358}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - i % N) == 1:
        nns.append(J[0, i%N, i//N] * h_site)
      elif i//N == nn_site // N and abs(nn_site % N - i % N) > 1:
        nns.append(0)
      else:
        nns.append(J[(j-1)%2, i%N, i//N]*h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0473686728395062}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])
      
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007646604938271605}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) + J[3,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)]) - J[3,i//N,i//N]

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0028449074074074067}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    priorities[k][0] = (J_up - J_down)*h_site
    priorities[k][1] = -priorities[k][0]

  return(priorities)




#score: {'data2D.txt': 0.004153240740740741}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = (J_up + J_down)*h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.2806344135802465}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.3082109567901227}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_energy += J[k,i//N,i//N]*h[site][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.0013146604938271604}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    energy_difference = 2*h[i//N][i%N] * (total_energy + h[i//N][i%N])
    
    if energy_difference > 0:
      priorities[i][0] = -energy_difference
      priorities[i][1] = 1
    else:
      priorities[i][0] = energy_difference
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.051234413580246864}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[1] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin[1]
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin[0] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin[0]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0013282407407407407}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[i//N][i%N]
    if h_site > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      total_spin -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.0007476851851851852}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += total_energy + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.006340277777777778}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if J[0,i//N,i%N]*h[(i+1)%N][i%N] > 0:
      priorities[i][0] = total_energy - (J[0,i//N,i%N]*2 + J[1,i//N,i%N])
    elif J[0,i//N,i%N]*h[(i+1)%N][i%N] < 0:
      priorities[i][0] = total_energy + (J[0,i//N,i%N]*2 - J[1,i//N,i%N])
    else:
      priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.05059953703703704}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k%2==0 else h[(i+k+1)%N][i%N]) for k in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.006355092592592594}
#island_id: 3
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[1] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + (total_spin[1] if h[site_nbr][i%N] > 0 else -total_spin[1])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin[0] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + (total_spin[0] if h[site_nbr][i%N] > 0 else -total_spin[0])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.1420492283950618}
#island_id: 3
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) + h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) - h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0056594135802469124}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      if j == 0: nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      elif j == 1: nn_site = (i // N + ((site_nbr-1)%N) - 1) % N
      elif j == 2: nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      else: nn_site = (i // N + ((site_nbr+1)%N) - 1) % N
      
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0066575617283950615}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  # Add some extra magic to make the function even better
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] += 0.5 * total_energy ** 2
    priorities[i][1] -= priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006665586419753086}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_spin = 1
      else:
        nn_spin = -1

      nns.append(nn_spin * h[nn_site][i%N])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005132561728395061}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == (i//N+1)%N or i%N==0: 
        nn_site = (site_nbr + 1) % N  
      elif i//N==(i//N+1)%N and i%N==N-1:
        nn_site = (site_nbr - 1) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016578703703703703}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    spin_energy = h_site + sum([n*n for n in nns])
    if spin_energy > 0:
      priorities[i][0] = max([spin_energy - J[0,i%N,i//N]*n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = min([spin_energy + J[0,i%N,i//N]*n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_site = -1
      priority_total = -sum(J[j,i//N,site_nbr] for j in range(3))
    else:
      priority_site = 1
      priority_total = sum(J[j,i//N,site_nbr] for j in range(3))

    priorities[i][0] = h[site_nbr][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0013285493827160497}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.05035385802469137}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      priority_total = [1, -1]
    else:
      priority_total = [-1, 1]

    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1

    priorities[i][0] = total_spin + sum([J[k,i%N,j]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0010276234567901227}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][0] = h[site_nbr][i%N] + neighbors_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][0] = -h[site_nbr][i%N] - neighbors_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002492283950617291}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site's own magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]

  # Calculate interactions with neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    neighbors = [(k, (k+i-N)//N) for k in range(4)]
    for neighbor in neighbors:
      priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]

  # Calculate priority based on total magnetism
  priorities[:,1] = -priorities[:,0]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0035387345679012356}
#island_id: 0
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbrs = list(set(site_nbrs))
    h_neighbors = [h[site][i%N] for site in site_nbrs]
    if sum(h_neighbors) > 0:
      priorities[i][0] = np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)])
      priorities[i][1] = -(np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)]))
    else:
      priorities[i][0] = np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)])
      priorities[i][1] = -(np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)]))
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.008169907407407407}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i // N) % N
    site_nbr_col = i % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row_neighbor = (site_nbr_row + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row_neighbor][i%N]
        priorities[i][1] -= h[site_nbr_row_neighbor][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row_neighbor][i%N]
        priorities[i][1] += h[site_nbr_row_neighbor][i%N]
    
    site_nbr_col_neighbor = (site_nbr_col + ((k-1)%2 - 1)) % N
    if J[3,i%N,site_nbr_col_neighbor] > 0:
      priorities[i][0] += h[site_nbr_col_neighbor][i//N]
      priorities[i][1] -= h[site_nbr_col_neighbor][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col_neighbor][i//N]
      priorities[i][1] += h[site_nbr_col_neighbor][i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.007664043209876543}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.07435570987654325}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    
    if i//N != 0:
      site_energy += J[1, i//N, i//N] * h[(i-1)//N][i%N]
    if i//N < N-1:
      site_energy += J[2, i//N, i//N] * h[(i+1)//N][i%N]
    
    for j in range(N):
      if i%N != 0:
        site_energy += J[3, i//N, i%N] * h[i//N][j]
      if i%N < N-1:
        site_energy += J[3, i//N, (i+1)%N] * h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.3439816358024681}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if np.abs(h[i//N][i%N]) > 0.5:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1 if h[i//N][i%N] > 0 else -1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1 if h[i//N][i%N] < 0 else 1

  return(priorities)




#score: {'data2D.txt': 0.007791512345679012}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]

    if i % N > 0:
      total_energy += J[1, site_nbr, i//N] * h[(i-1)//N][(i-1)%N]
    if i % N < N - 1:
      total_energy += J[2, site_nbr, i//N] * h[(i+1)//N][i%N + 1]
    if i // N > 0:
      total_energy += J[3, site_nbr, i//N] * h[(i-1)//N][i%N]
    if i // N < N - 1 and (i % N == 0 or i % N == N - 1):
      total_energy += J[0, site_nbr, i//N] * h[i//N][i%N]

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.008343364197530864}
#island_id: 1
#version_generated: 2
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin + sum(h[j][i%N] for j in range(N) if abs(j-i)%2 == 0)
    priorities[i][1] = -total_spin + sum(h[j][i%N] for j in range(N) if abs(j-i)%2 != 0)
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.003604475308641976}
#island_id: 1
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + (i//N+1)%N) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N]
    
    if i // N < N-1:
      total_spin += J[1,i//N,i%N] * (h[i//N+1][i%N] - h[site_nbr2][i%N])
    if i % N > 0:
      total_spin += J[2,i//N,i%N] * (h[site_nbr1][i%N-1] - h[i//N][i%N])
    
    if i % N < N-1 and i // N < N-1:
      total_spin += J[3,i//N,i%N] * (h[site_nbr3][i%N+1] + h[i//N+1][i%N] - 2*h[site_nbr2][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17046589506172866}
#island_id: 2
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

    site_nbr_opp = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_opp][i%N] > 0:
      priorities[i][0] += J[3, i//N, i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[3, i//N, i//N]

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.11481929012345692}
#island_id: 2
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  # add a twist to prioritize sites with no interaction
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0, i//N, i%N] == 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] = -1 if h[i//N][i%N] > 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.3238257716049374}
#island_id: 1
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][i%N] > 0:
        if J[3,i%N,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      else:
        if J[3,i%N,j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.005032253086419754}
#island_id: 1
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for i in range(N**2):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])

    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  # Add a bias term to the priority based on the current spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.26976095679012313}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    
    # Add interactions with neighboring sites
    if i // N > 0:
      site_energy += J[0, i//N, i//N] * (h[(i//N-1)%N][i%N])
    if i % N > 0:
      site_energy += J[1, i//N, i//N] * (h[i//N][(i+1)%N])
    if i // N < N - 1:
      site_energy += J[2, i//N, i//N] * (h[(i//N+1)%N][i%N])
    if i % N < N - 1 and i // N > 0:
      site_energy += J[3, i//N, i//N] * (h[(i//N-1)%N][(i+1)%N])

    # Adjust energy based on magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.17138996913580273}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])

    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0, site_nbr, i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[0, site_nbr, i//N]

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      J[:,i//N,i%N][J[:,i//N,i%N]>0.5]+=1
      J[:,i//N,i%N][J[:,i//N,i%N]<-0.5]-=1
    else:
      J[:,i//N,i%N][J[:,i//N,i%N]>0.5]-=1
      J[:,i//N,i%N][J[:,i//N,i%N]<-0.5]+=1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': -9.799382716049343e-05}
#island_id: 0
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2)
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2)
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.021364969135802468}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += (total_energy + nn_energy) / abs(nn_energy)
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= (total_energy - nn_energy) / abs(nn_energy)
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.02459614197530864}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -2.8240740740740123e-05}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if nn_energy > 0:
      priorities[i][0] += total_energy + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.0007476851851851852}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += 2*total_energy + nn_energy
      priorities[i][1] -= 4
    else:
      priorities[i][0] -= 2*total_energy - nn_energy
      priorities[i][1] += 4
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.08258163580246924}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16431033950617308}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  for i in range(N):
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i,N-1-i] > 0:
      priorities[i*N+i][0] += h[site_nbr][i]
      priorities[i*N+i][1] -= h[site_nbr][i]
    else:
      priorities[i*N+i][0] -= h[site_nbr][i]
      priorities[i*N+i][1] += h[site_nbr][i]
  
  for j in range(N):
    site_nbr = (j % N + ((1-1)%2 - 1)) % N
    if J[1,N-1-j,j] > 0:
      priorities[j*N+j][0] += h[site_nbr][j]
      priorities[j*N+j][1] -= h[site_nbr][j]
    else:
      priorities[j*N+j][0] -= h[site_nbr][j]
      priorities[j*N+j][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.17964212962962964}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      total_spin = h[site_nbr1][i%N]
    else:
      total_spin = -h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      total_spin += h[site_nbr3][i%N]
      total_spin -= h[site_nbr4][i%N]
    else:
      total_spin -= h[site_nbr3][i%N]
      total_spin += h[site_nbr4][i%N]

    if J[1,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    site_nbr5 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr5][i%N]
    else:
      total_spin -= h[site_nbr5][i%N]

    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Compute interactions with horizontal and vertical neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.10518256172839513}
#island_id: 3
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) + h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0] - 2*h[site_nbr][i%N]
    else:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) - h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0] + 2*h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': -0.0011924382716049392}
#island_id: 3
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.06733873456790126}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006374228395061729}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    total_energy = J[1,i//N,site_nbr] * h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.022201080246913633}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    total_spin = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
        total_spin += (J[j,i//N,nn_site] > 0).astype(int)
      else:
        nn_energy = -h[nn_site][i%N]
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = (total_energy + nn_energy_sum) * total_spin
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.00775817901234568}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if J[0, i//N, i//N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  # Add a bias term to the priority based on the current spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.3428674382716039}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        if J[2,(i-1)//N,i//N] > 0:
          total_spin += h[(i-1)//N][j]
        else:
          total_spin -= h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        if J[3,(i-N)//N,i//N] > 0:
          total_spin += h[(i-N)//N][j]
        else:
          total_spin -= h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        if J[1,(i-1)//N,i//N] > 0:
          total_spin += h[i//N][j]
        else:
          total_spin -= h[i//N][j]
    site_energy = total_spin * (total_spin if J[0, i//N, i%N] > 0 else -total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin including interactions with nearest neighbors
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.2012217592592595}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i // N + ((i % N - 1) % N)) % N
    if h[site_nbr][i%N] * J[3, i%N, i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate interaction with neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # adjust magnetism term based on the sign of h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34217422839506073}
#island_id: 2
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        total_spin += h[(i-1)//N][j] * J[0, i//N, i%N]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin += h[(i-N)//N][j] * J[3, (i-N)//N, i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += h[i//N][j] * J[1, i//N, i%N]
      elif (i+1)%N == j:
        total_spin += h[i//N][j] * J[2, i//N, i%N]
    
    site_energy = total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.3428754629629619}
#island_id: 2
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        total_spin += h[(i-1)//N][j] * J[0, (i-1)//N, i%N]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin -= h[(i-N)//N][j] * J[3, (i-N)//N, i%N]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += h[i//N][j] * J[1, i//N, i%N]
    site_energy = total_spin * (total_spin if J[2, i//N, i%N] > 0 else -total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.003758179012345679}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if sum(J[:,i//N,i%N]) > 0:
      priorities[i][1] -= 2*total_energy
    else:
      priorities[i][1] += 2*total_energy
  return(priorities)




#score: {'data2D.txt': -0.009550771604938271}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -6171599491158.986}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N] if J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][((i+N)%N)%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0016807098765432107}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N]) - 2*sum(h[site_nbr])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N]) + 2*sum(h[site_nbr])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.0012047839506172833}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin if h[i//N][i%N] < 0 else total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.14424768518518538}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      spin = 1
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      spin = -1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin * spin
  return(priorities)




#score: {'data2D.txt': -0.0014649691358024689}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    # Add the interactions with the next nearest neighbors
    if i % (N*N) < N:
      priorities[i][0] += J[2,i//N,i%N]*h[(i+N-1)%N][i%N]
      priorities[i][1] -= J[2,i//N,i%N]*h[(i+N-1)%N][i%N]
    if i % (N*N) >= N and i % (N*N) < 2*N:
      priorities[i][0] += J[3,(i+N-1)%N,i//N]*h[i%N,(i+N-1)%N]
      priorities[i][1] -= J[3,(i+N-1)%N,i//N]*h[i%N,(i+N-1)%N]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.09343904320987653}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([J[k,i,j]*h[(k+N-1)%N][j] for k in range(3)]) + total_spin
        priorities[i*N+j][1] = -priorities[i*N+j][0]
      else:
        priorities[i*N+j][0] -= sum([J[k,i,j]*h[(k+N-1)%N][j] for k in range(3)]) - total_spin
        priorities[i*N+j][1] = -priorities[i*N+j][0]
  return(priorities)




#score: {'data2D.txt': -0.052260339506172857}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum(h[k][i%N] for k in range(N))
      priorities[i][0] = sum(J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum(h[k][i%N] for k in range(N))
      priorities[i][0] = sum(J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.10717700617283961}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum(h[site_nbr][j] for j in range(N)) + 1
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum(h[site_nbr][j] for j in range(N)) - 1
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0036063271604938273}
#island_id: 1
#version_generated: 2
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i//N
    
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in [0, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_sum = 0
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        spin_sum += h[site_nbr][j]
      else:
        spin_sum -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N] + spin_sum
        priorities[i][1] -= h[site_nbr][i%N] - spin_sum
      else:
        priorities[i][0] -= h[site_nbr][i%N] + spin_sum
        priorities[i][1] += h[site_nbr][i%N] - spin_sum
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0012405864197530861}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for l in range(N):
      site_nbr = (i % N + ((l-1)%2 - 1)) % N
      if J[3,i%N,l] > 0:
        priorities[i][0] += h[site_nbr][l]
        priorities[i][1] -= h[site_nbr][l]
      else:
        priorities[i][0] -= h[site_nbr][l]
        priorities[i][1] += h[site_nbr][l]
    
    return(priorities)




#score: {'data2D.txt': -0.08245910493827165}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = total_spin + magnetism
    priorities[i][1] = -total_spin - magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16547484567901255}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the spin priority based on local magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority for assigning spins to -1 and 1
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * N + sum(h[j][i%N] for j in range(N))
      priorities[i][1] = -(total_spin * N + sum(h[j][i%N] for j in range(N)))
    else:
      priorities[i][0] = -((total_spin * N) + sum(h[j][i%N] for j in range(N)))
      priorities[i][1] = (total_spin * N + sum(h[j][i%N] for j in range(N)))

  return(priorities)




#score: {'data2D.txt': 0.06338040123456797}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k+2,i%N,i//N] > 0:
       total_spin += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       total_spin -= h[site_nbr][i%N]
       priorities[i][0] += h[site_nbr][i%N]
    
    for j in range(N):
     site_nbr = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       total_spin += h[site_nbr][j]
       priorities[i][1] -= h[site_nbr][j]
     else:
       total_spin -= h[site_nbr][j]
       priorities[i][0] += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0006992283950617284}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
 
  # Sort the sites based on the priority
  indices = np.argsort(priorities[:,0])
  priorities = priorities[indices]
 
  return(priorities)




#score: {'data2D.txt': 0.019974537037037034}
#island_id: 0
#version_generated: 2
#generate time14:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  # Check if the spin assignment is valid
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      if sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) > 0:
        priorities[i] = -priorities[i]
    else:
      if sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) < 0:
        priorities[i] = -priorities[i]

  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add site-specific contributions to priorities
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.005700462962962963}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append((site_nbr, h[site_nbr][i%N]))
    if sum(1 for _, val in site_nbrs) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1645208333333336}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i//N]
      priorities[i][1] -= h[site_nbr_row][i//N]
    else:
      priorities[i][0] -= h[site_nbr_row][i//N]
      priorities[i][1] += h[site_nbr_row][i//N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i%N]
      priorities[i][1] -= h[site_nbr_col][i%N]
    else:
      priorities[i][0] -= h[site_nbr_col][i%N]
      priorities[i][1] += h[site_nbr_col][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1653785493827163}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism at site
    total_spin += h[i//N][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add next-nearest neighbor interactions (if applicable)
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16521435185185204}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,(i+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Assign priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.08344675925925932}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin + sum(h[site_nbr])
    priorities[i][1] = -total_spin + sum(-h[site_nbr])
  return(priorities)




#score: {'data2D.txt': 0.0004427469135802473}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if i//N == (k+N-1)%N and (i%N+k+2)%4==1:
        h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      elif i//N == (k+N-1)%N and (i%N+k+2)%4==3:
        h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0010192901234567897}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001565895061728395}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: # wraparound
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      if J[k,i%N,i//N]*h[(k+N-1)%N][i%N] > 0:
        h_site += J[k,i%N,i//N]
      else:
        h_site -= J[k,i%N,i//N]

    if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002374845679012345}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.01128533950617284}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-N_half)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N < N_half:
        if j%2 == 0:
          nns.append(h[nn_site][i%N])
        else:
          nns.append(-h[nn_site][i%N])
      else:
        if j%2 == 0:
          nns.append(-h[nn_site][i%N])
        else:
          nns.append(h[nn_site][i%N])
    
    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    
    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.012395524691358023}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      if j == 0:
        nn_site = (site_nbr + ((i//N-1)%2 - 1)) % N
      elif j == 1:
        nn_site = (site_nbr + ((i//N)%2 - 1)) % N
      elif j == 2:
        nn_site = (site_nbr + ((i//N+1)%N)) % N
      else:
        nn_site = (site_nbr + (((i//N)-1)%2 - 1)) % N

      nn_sites.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) - J[1,i//N,i//N]

    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015705246913580244}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = h_site * (J_up - J_down)
    priorities[i][1] = -(priorities[i][0])

  return(priorities)




#score: {'data2D.txt': -0.0090125}
#island_id: 0
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(i%N - nn_site %N) < 2:
        nn_sites.append(J[abs(i%N - nn_site %N),i//N,nn_site//N] * h_site)
    priorities[i][0] = np.sum(nn_sites) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009686728395061732}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    flip = 0 if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) < h_site else 1
    priorities[i][flip] += J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
  return(priorities)




#score: {'data2D.txt': -0.005630401234567902}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.0002334876543209875}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      if left_nbr != i and J[0,left_nbr%N,top_nbr%N] > 0:
        priorities[i][0] += J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
      if right_nbr != i and J[0,right_nbr%N,top_nbr%N] > 0:
        priorities[i][0] -= J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      if left_nbr != i and J[0,left_nbr%N,top_nbr%N] > 0:
        priorities[i][0] -= J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
      if right_nbr != i and J[0,right_nbr%N,top_nbr%N] > 0:
        priorities[i][0] += J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002374845679012345}
#island_id: 2
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0038486111111111117}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    # Introduce a small noise term to avoid getting stuck in local minima
    noise = 0.01 * np.random.rand()

    priorities[i][0] = np.exp(-diff + noise)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11235972222222222}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin)
      priority_down = 1 - priority_up
    else:
      priority_up = 1 - np.exp(-total_spin)
      priority_down = priority_up

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': -0.001977623456790124}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff) / (np.exp(-p_up) + np.exp(-p_down))
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0023819444444444417}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    if i < N*N/2:
      priorities[i][1] = -priority_sum
    else:
      priorities[i][0] = -priority_sum
  
  return(priorities)




#score: {'data2D.txt': -0.20788441358024695}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
        
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    total_energy = h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03339521604938272}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
    else:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.06614212962962965}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4):  # include the diagonal neighbor as well
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time14:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11501373456790137}
#island_id: 1
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute the contribution from nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the contributions from all sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Apply the magnetism term
    total_spin *= np.sign(h[i//N][i%N])
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0014819444444444444}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h[site_nbr][i%N] + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.02224891975308642}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_site_1 = (site_nbr + ((2-1)%2 - 1)) % N
    if J[1,i//N,nn_site_1] > 0:
      nn_energy_1 = h[nn_site_1][i%N]
    else:
      nn_energy_1 = -h[nn_site_1][i%N]

    nn_site_2 = (site_nbr + ((3-1)%2 - 1)) % N
    if J[2,i//N,nn_site_2] > 0:
      nn_energy_2 = h[nn_site_2][i%N]
    else:
      nn_energy_2 = -h[nn_site_2][i%N]

    total_energy = (h[i//N][i%N] + nn_energy_1 + nn_energy_2) * h_site
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005777006172839506}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[0,i//N,site_nbr] > 0:
      priorities[i][0] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = h[site_nbr][i%N]

    priorities[i][1] = -priorities[i][0] + nn_energy_sum

  return(priorities)




#score: {'data2D.txt': 0.030788425925925927}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if total_energy > 0:
      priorities[i][0] = h_site + total_energy
      priorities[i][1] = -priorities[i][0]
    elif total_energy < 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      if np.random.rand() > 0.5:
        priorities[i][0] = h_site + total_energy
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = h_site
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.exp(h_site + total_energy)
    priorities[i][1] = np.exp(-h_site - total_energy)

  return(priorities)




#score: {'data2D.txt': 0.11235972222222222}
#island_id: 2
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.exp(total_spin_up)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - np.exp(-total_spin_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin)
      priority_down = 1 / (np.exp(-total_spin) + 1)
    else:
      priority_up = 1 / (np.exp(total_spin) + 1)
      priority_down = np.exp(-total_spin)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.0291195987654321}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      for k in range(4):
        if k==3:
          continue
        neighbor = (site_nbr + ((k-1)%2 - 1)) % N
        if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
          neighbor = (neighbor + ((k-1)%2 - 1)) % N
        priority_total[0] += J[k,i//N,nn_site]
        priority_total[1] -= J[k,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
    
  return(priorities)




#score: {'data2D.txt': 0.018646759259259262}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] < 0:
        priorities[i][0] -= J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] < 0:
        priorities[i][0] -= J[1, i//N, i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] > 0:
        priorities[i][0] += J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] > 0:
        priorities[i][0] += J[1, i//N, i%N]
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][i%N] for k in range(3))
    priorities[i][0] += h[site_nbr][i%N] + nn_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2
    else:
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': -0.0055526234567901235}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.11411743827160509}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the influence from four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # adjust the spin based on local magnetism and nearest neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_contributions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        neighbor_contributions -= 2
      else:
        total_spin -= 1
        neighbor_contributions += 2
    priorities[i][0] = -total_spin + neighbor_contributions/2
    priorities[i][1] = total_spin + neighbor_contributions/2
  return(priorities)




#score: {'data2D.txt': 0.06266064814814815}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.014498611111111113}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_energy += 2*J[j,i//N,i%N]*h[(i+j-3)%N][i%N]
      else:
        total_energy -= 2*J[j,i//N,i%N]*h[(i+j-3)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0788337962962963}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002082561728395062}
#island_id: 0
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

    # Add interaction with next nearest neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += np.sum(J[:,i//N,site])
        priorities[i][1] -= 2*np.sum(J[:,i//N,site])
      else:
        priorities[i][0] -= np.sum(J[:,i//N,site])
        priorities[i][1] += 2*np.sum(J[:,i//N,site])

  return(priorities)




#score: {'data2D.txt': 0.1613686728395064}
#island_id: 1
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
    
  return(priorities)




#score: {'data2D.txt': 0.11584243827160508}
#island_id: 1
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr2][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        total_spin -= h[site_nbr2][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0036038580246913585}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum of interactions from left and right neighbors
    total_spin += sum(J[0,i//N,(i%N)+j] for j in range(-1,2) if 0 <= i%N+j < N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.06103503086419755}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = 1
      for k in range(4):
        if J[k,i//N,i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    else:
      total_spin = -1
      for k in range(4):
        if J[k,i//N,i%N] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0021887345679012346}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr1][i%N]
       priorities[i][1] -= h[site_nbr1][i%N]
     else:
       priorities[i][0] -= h[site_nbr1][i%N]
       priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004227314814814815}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009560185185185193}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h_site + 2*neighbor_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0002837962962962961}
#island_id: 3
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if i//N == (k+N-1)%N and (i%N+k+2)%4==1:
        h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      elif i//N == (k+N-1)%N and (i%N+k+2)%4==3:
        h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(J[k, i%N, (i//N+k+2)%4] for k in range(3))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(J[k, i%N, (i//N+k+2)%4] for k in range(3))
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007035493827160492}
#island_id: 3
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
     site = (i + ((k-1)%2 - 1)) % N
     if i//N == (site+N-1)%N and (i%N+k+2)%4==1:
      h_site += J[k,i%N,i//N]*h[site][i%N]
     elif i//N == (site+N-1)%N and (i%N+k+2)%4==3:
      h_site -= J[k,i%N,i//N]*h[site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.07523533950617285}
#island_id: 2
#version_generated: 2
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.exp(total_spin_up)
      priorities[i][1] = 1 / (1 + np.exp(-total_spin_down))
    else:
      priorities[i][0] = 1 / (1 + np.exp(total_spin_up))
      priorities[i][1] = np.exp(total_spin_down)

  return(priorities)




#score: {'data2D.txt': -0.3281248456790114}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0012566358024691366}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
      
  return(priorities)




#score: {'data2D.txt': 0.0012813271604938282}
#island_id: 3
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
    priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.0045875}
#island_id: 3
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    total_spin = 0
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if J[0,i//N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_spin + h_site - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h_site + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.02333070987654321}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin_up)
      priority_down = 1 / (1 + np.exp(total_spin_down))
    else:
      priority_up = 1 / (1 + np.exp(-total_spin_up))
      priority_down = np.exp(total_spin_down)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    # Calculate the interaction energy with neighbors
    for k in range(-1, 2):
      if k == 0:
        continue
      x = (i + k) % N
      y = i // N
      total_spin += J[k, y, i%N] * h[x][y]
    
    # Update the magnetism at each site based on the interaction energy
    if total_spin > 0:
      priorities[i][0] = np.exp(total_spin)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - np.exp(-total_spin)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.018206944444444442}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin_up)
      priority_down = np.exp(total_spin_down) / (1 + np.exp(total_spin_up))
    else:
      priority_up = 1 / (1 + np.exp(-total_spin_up))
      priority_down = np.exp(total_spin_down)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': 0.09301496913580247}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
      elif h[site_nbr][i%N] < 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        elif sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) < 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
  return(priorities)




#score: {'data2D.txt': 0.07749367283950617}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      site_energy = h[site_nbr][i%N]
      if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
        if site_energy > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = 1
          priorities[i][1] = -1
      else:
        if site_energy > 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
        else:
          priorities[i][0] = -1
          priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.08017731481481483}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy)
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0010378086419753096}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      if i % (N*N) < N*(N-1):
        priorities[i][0] = h_site + 2*neighbor_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = neighbor_sum
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00853533950617284}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      
      if neighbor_sum > 0:
        priorities[i][0] = 2
        priorities[i][1] = 0
      elif neighbor_sum < 0:
        priorities[i][0] = 0
        priorities[i][1] = 2
      else:
        priorities[i][0] = h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.0055526234567901235}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.024727314814814817}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy - J[1, i//N, i%N]
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy + J[1, i//N, i%N]
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.00870848765432099}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.017414969135802472}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][0] -= sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][0] += sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': 0.0005276234567901242}
#island_id: 2
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.0006683641975308652}
#island_id: 2
#version_generated: 2
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      total_sum = h_site + neighbor_sum
      if J[1,i//N,i%N] > 0:
        total_sum += 2*h[site_nbr][i%N]
      else:
        total_sum -= 2*h[site_nbr][i%N]

      priorities[i][0] = total_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]

    priorities[i][1] = -priorities[i][0]
    
    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]

    priorities[i][1] = -priorities[i][0]
    
    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.01764212962962963}
#island_id: 3
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]

    priorities[i][1] = -priorities[i][0]
    
    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.0009461419753086428}
#island_id: 2
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[3,k,i//N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0005776234567901239}
#island_id: 2
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = np.zeros((2,))
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if J[0,i%N,i//N] > 0:
          total_spin += h[site][i%N]
        else:
          total_spin -= h[site][i%N]
      priorities[i][0] = np.sum(np.sign(h_site + 2*total_spin))
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.008878858024691358}
#island_id: 2
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h[site_nbr][i%N] + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.0009461419753086428}
#island_id: 2
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[3,k,i//N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.008878858024691358}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h[site_nbr][i%N] + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.008878858024691358}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h[site_nbr][i%N] + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.008878858024691358}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h[site_nbr][i%N] + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    # Use a more robust method to calculate the probabilities based on the priority difference
    prob_up = np.exp(-diff) / (np.exp(-p_up) + np.exp(-p_down))
    priorities[i][0] = prob_up * (1 + 0.5*np.tanh(prob_up*(2-prob_up)))

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if p_up < p_down:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(-p_up) / (np.exp(-p_up) + np.exp(-p_down))
    else:
      priorities[i][0] = np.exp(-p_down) / (np.exp(-p_up) + np.exp(-p_down))
      priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0013572530864197532}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    energy_up = h_site**2 + 2*h_site*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    energy_down = -h_site**2 - 2*h_site*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    diff = energy_up - energy_down
    priorities[i][0] = np.exp(-diff) / (np.exp(-energy_up) + np.exp(-energy_down))
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0033677469135802475}
#island_id: 2
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    # Calculate the priority based on the interaction strength and magnetism
    p_interaction_up = sum([J[k,i%N,i//N]**2 for k in range(4)])
    p_interaction_down = sum([J[k,i%N,i//N]**2 for k in range(4)])

    priorities[i][0] = np.exp(-diff) * (np.exp(-p_up) / (np.exp(-p_up) + np.exp(-p_down))) * np.exp(-p_interaction_up)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001936882716049383}
#island_id: 2
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
      neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site = -h[site_nbr][i%N]
      neighbor_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = 2*h_site + 4*neighbor_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006327006172839506}
#island_id: 2
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      spin_value = 1
    else:
      spin_value = -1
      
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N*N) < N*(N-1):
      priorities[i][0] = spin_value + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = spin_value + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0009220679012345681}
#island_id: 2
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  # Sort the sites based on priority
  sorted_indices = np.argsort(priorities[:,0])
  return priorities[sorted_indices]




#score: {'data2D.txt': 0.0003010802469135804}
#island_id: 2
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,(i-1)%N,i//N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][(i-1)%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0011961419753086417}
#island_id: 3
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: # wraparound
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(3)])
      if h_sum > 0:
        priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(3)]) 
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024905864197530864}
#island_id: 3
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h_site > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004588734567901234}
#island_id: 3
#version_generated: 2
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    row, col = divmod(i, N)
    site_h = h[site_nbr][col]
    site_interaction = sum([J[k, i%N, i//N]*h[(k+N-1)%N][col] for k in range(3) if (k==0 and col+1>=N) or (k==2 and col-1<0)])
    
    if h[site_nbr][col] > 0:
      site_interaction -= J[1, i%N, i//N]
    else:
      site_interaction += J[1, i%N, i//N]
      
    priorities[i][0] = site_h + site_interaction
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.16144768518518543}
#island_id: 1
#version_generated: 2
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    for k in range(2):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.008970833333333332}
#island_id: 1
#version_generated: 2
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.10300663580246924}
#island_id: 1
#version_generated: 2
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -total_spin + np.sum(1-J[:,i//N,i//N])
    else:
      priorities[i][0] = -total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = total_spin + np.sum(1-J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': -0.0031868827160493832}
#island_id: 1
#version_generated: 2
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0064729938271604935}
#island_id: 1
#version_generated: 2
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if J[3,i%N,j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    priorities[i][0] = total_spin + sum(h[j][i%N] for j in range(N))
    priorities[i][1] = -total_spin + sum(-h[j][i%N] for j in range(N))
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16222145061728419}
#island_id: 1
#version_generated: 2
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N//N] > 0:
      priorities[i][0] += h[site_nbr][N//N]
      priorities[i][1] -= h[site_nbr][N//N]
    else:
      priorities[i][0] -= h[site_nbr][N//N]
      priorities[i][1] += h[site_nbr][N//N]
  
  return(priorities)




#score: {'data2D.txt': -0.0027189814814814815}
#island_id: 1
#version_generated: 2
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]

    if J[3,i%N,i//N] > 0:
      priorities[i] = [total_spin + magnetism, -total_spin - magnetism]
    else:
      priorities[i] = [-total_spin - magnetism, total_spin + magnetism]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    
    # Consider the four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11555354938271618}
#island_id: 1
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add next-nearest neighbor interactions (diagonal and off-diagonal)
    for j in range(N):
      site_nbr = ((i // N + j % 2) + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0008976851851851857}
#island_id: 1
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)//2 - 1)) % N
    
    total_spin = h[site_nbr_row][i%N] + J[0,i%N,i//N] + J[3,i%N,site_nbr_col]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.15637947530864219}
#island_id: 0
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (total_spin + 1) * 3
      priorities[i][1] -= (2 * total_spin - 1)
    else:
      priorities[i][0] -= (total_spin + 1) * 3
      priorities[i][1] += (2 * total_spin - 1)

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 4
      priorities[i][1] -= 3 * total_spin
    else:
      priorities[i][0] -= total_spin * 4
      priorities[i][1] += 3 * total_spin
  return(priorities)




#score: {'data2D.txt': 0.0025557098765432106}
#island_id: 0
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.25 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.25 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.007523302469135803}
#island_id: 0
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': -9.799382716049343e-05}
#island_id: 0
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2)
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2)
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.016232253086419752}
#island_id: 0
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2) + np.sum(J[:,i//N,i%N])
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2) - np.sum(J[:,i//N,i%N])
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.001272685185185185}
#island_id: 2
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % (N*N) < N*(N-1):
        priorities[i][0] = h[site_nbr][i%N] + 2*total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        total_spin += sum([J[3,k,i%N]*h[k][i%N] for k in range(N)])
        priorities[i][0] = h[site_nbr][i%N] + 2*total_spin
        priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum([J[k,i%N,i//N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      if i % (N*N) < N*(N-1):
        priorities[i][0] = -h[site_nbr][i%N] + 2*total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        total_spin += sum([J[3,k,i%N]*-h[k][i%N] for k in range(N)])
        priorities[i][0] = -h[site_nbr][i%N] + 2*total_spin
        priorities[i][1] = -priorities[i][0]

  # Sort the sites based on priority
  sorted_indices = np.argsort(priorities[:,0])
  return priorities[sorted_indices]




#score: {'data2D.txt': -0.0007717592592592591}
#island_id: 2
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[3, k, i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  # Sort the sites based on priority
  sorted_indices = np.argsort(priorities[:,0])
  return priorities[sorted_indices]




#score: {'data2D.txt': -0.0017936728395061728}
#island_id: 2
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h_site + 2*neighbor_sum
    priorities[i][1] = -priorities[i][0]

  # Sort the sites based on priority
  sorted_indices = np.argsort(priorities[:,0])
  return priorities[sorted_indices]




#score: {'data2D.txt': -0.0009220679012345681}
#island_id: 2
#version_generated: 2
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  # Sort the sites based on priority
  sorted_indices = np.argsort(priorities[:,0])
  return priorities[sorted_indices]




#score: {'data2D.txt': 0.0007844135802469143}
#island_id: 1
#version_generated: 2
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + ((i%N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N] + J[3,i%N,i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
        
  return(priorities)




#score: {'data2D.txt': 0.16576929012345704}
#island_id: 1
#version_generated: 2
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_east = (i % N + ((i//N+1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_east][i//N]
      priorities[i][1] -= h[site_nbr_east][i//N]
    else:
      priorities[i][0] -= h[site_nbr_east][i//N]
      priorities[i][1] += h[site_nbr_east][i//N]
    
    site_nbr_north = (i % N + ((i//N-2)%2 - 1)) % N
    if i%N > 0:
      if J[1,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_north][i//N]
        priorities[i][1] -= h[site_nbr_north][i//N]
      else:
        priorities[i][0] -= h[site_nbr_north][i//N]
        priorities[i][1] += h[site_nbr_north][i//N]
    elif i//N > 0:
      site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
      if J[1,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i//N]
        priorities[i][1] -= h[site_nbr][i//N]
      else:
        priorities[i][0] -= h[site_nbr][i//N]
        priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.0390983024691358}
#island_id: 2
#version_generated: 2
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin)
      priority_down = 1 - priority_up
    else:
      priority_up = 1 - np.exp(-total_spin)
      priority_down = priority_up

    priorities[i][0] = priority_up * (np.sum(J[:,i//N,(i+1)%N])*h[(i+1)%N,i%N] > 0) + 1
    priorities[i][1] = priority_down * (np.sum(J[:,i//N,(i+1)%N])*h[(i+1)%N,i%N] < 0) + 1

  return(priorities)




#score: {'data2D.txt': -0.0036939814814814812}
#island_id: 2
#version_generated: 2
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = np.sum(J[:,i//N,i%N])*(-1)*h[site_nbr][i%N]
    priority_up = np.exp(total_spin_up)
    priority_down = 1 - priority_up
    if h[site_nbr][i%N] > 0:
      priority_up *= (1 + total_spin_up)
      priority_down *= (1 - total_spin_down)
    else:
      priority_up *= (1 - total_spin_up)
      priority_down *= (1 + total_spin_down)
    
    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': 0.08819799382716056}
#island_id: 1
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[site_nbr][j] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': 0.031052314814814814}
#island_id: 3
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_j = 0
    for k in range(4):  
      if (k == 0 and (i%N) < N/2) or (k == 1 and i%N >= N/2) or (k == 2 and i//N < N/2) or (k == 3 and i//N >= N/2):
        sum_j += J[k,i//N,i%N]*h[(i+k-N-1)%N][i%N]
    if sum_j > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0024905864197530864}
#island_id: 3
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h_site > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0024905864197530864}
#island_id: 3
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = 0 if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0 else 1
    priorities[i][spin] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06357237654320988}
#island_id: 0
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.08635972222222221}
#island_id: 0
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if i//N%2==0:
      priorities[i][0] = -total_energy
      priorities[i][1] = total_energy
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -total_energy
  return(priorities)




#score: {'data2D.txt': 0.053878240740740733}
#island_id: 0
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else h[(i+k-1)%N][i%N]) for k in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06378472222222221}
#island_id: 0
#version_generated: 2
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if J[0,i//N,i%N] > 0:
      priorities[i][0] = total_energy - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time14:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time14:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_mag = np.sign(total_spin)
    
    priorities[i] = [total_spin, -spin_mag]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Add a twist: consider the priority of assigning spin +1 or -1 based on the total spin
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0024905864197530864}
#island_id: 3
#version_generated: 2
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h_sum > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: # wraparound
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(3)])
      if h_sum > 0:
        priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(3)]) 
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(3)])
        priorities[i][1] = -priorities[i][0]

    # Add magnetism term
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(np.abs(J[:,i//N]))
      priorities[i][1] -= np.sum(np.abs(J[:,i//N]))
    else:
      priorities[i][0] -= np.sum(np.abs(J[:,i//N]))
      priorities[i][1] += np.sum(np.abs(J[:,i//N]))

  return(priorities)




#score: {'data2D.txt': -0.0006970679012345686}
#island_id: 3
#version_generated: 2
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(4):
     if k == 1 and (col+1)%N == N: # wraparound
       k = 0
     elif k == 2 and (col-1)%N == -1:
       k = 3
     h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(4)])
     if h_sum > 0:
       priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(4)]) 
       priorities[i][1] = -priorities[i][0]
     else:
       priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
       priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001446450617283951}
#island_id: 0
#version_generated: 2
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
     nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     if i//N < N//2:
       if j%2 == 0 and i%N < N//2:
        continue
       elif j%2 == 1 and i%N >= N//2:
        continue
     nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nns)]) + J[j-1,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nns)]) - J[j-1,i//N,i//N]

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -(J_up + J_down)*h_site

  return(priorities)




#score: {'data2D.txt': -0.1537825617283953}
#island_id: 0
#version_generated: 2
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h[i//N][i%N] > 0:
      spin_up = 1
    else:
      spin_up = -1

    priorities[i][0] = (J_up * spin_up + J_down) * h_site
    priorities[i][1] = -(J_up * spin_up + J_down) * h_site

  return(priorities)




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = max(0, i-N)
    right_nbr = min(i+1, N*N-1)
    top_nbr = (i-N)%N
    bot_nbr = (i+N)%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = h[site_nbr][i%N]
    
    left_nbr = (i-1) % N
    if i > 0 and J[2,i//N,left_nbr] > 0:
      priorities[i][0] -= J[2,i//N,left_nbr]*h[i//N][left_nbr]
      priorities[i][1] += J[2,i//N,left_nbr]*h[i//N][left_nbr]
    elif i > 0 and J[2,i//N,left_nbr] < 0:
      priorities[i][0] += J[2,i//N,left_nbr]*h[i//N][left_nbr]
      priorities[i][1] -= J[2,i//N,left_nbr]*h[i//N][left_nbr]
    
    right_nbr = (i+1) % N
    if i < N*N-1 and J[3,i//N,right_nbr] > 0:
      priorities[i][0] -= J[3,i//N,right_nbr]*h[i//N][right_nbr]
      priorities[i][1] += J[3,i//N,right_nbr]*h[i//N][right_nbr]
    elif i < N*N-1 and J[3,i//N,right_nbr] < 0:
      priorities[i][0] += J[3,i//N,right_nbr]*h[i//N][right_nbr]
      priorities[i][1] -= J[3,i//N,right_nbr]*h[i//N][right_nbr]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.005630401234567902}
#island_id: 3
#version_generated: 2
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.161136265432099}
#island_id: 1
#version_generated: 2
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i % N + ((i//N-1)//N - 1)) % N

    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i % N + ((i//N-1)//N - 1)) % N

    if h[site_nbr_row][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the magnetism at this site
    total_spin += h[site_nbr][i%N]
    
    # Add the interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # If magnetism is positive, spin should be -1; otherwise it should be 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if spin_sum > 0:
        priorities[i][0] = h_site + spin_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = h_site + spin_sum
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011421296296296303}
#island_id: 2
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 4*h_site + 4*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011421296296296303}
#island_id: 2
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011421296296296303}
#island_id: 2
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0090125}
#island_id: 0
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      if i//N == (site_nbr + ((j-1)%2 - 1)) % N // N and abs(i%N - (site_nbr + ((j-1)%2 - 1)) %N) < 2:
        nn_sites.append(J[abs(i%N - (site_nbr + ((j-1)%2 - 1)) %N),i//N,(site_nbr + ((j-1)%2 - 1)) // N] * h_site)
      if i//N == (site_nbr + ((3-j)%2 - 1)) % N // N and abs(i%N - (site_nbr + ((3-j)%2 - 1)) %N) < 2:
        nn_sites.append(J[abs(i%N - (site_nbr + ((3-j)%2 - 1)) %N),i//N,(site_nbr + ((3-j)%2 - 1)) // N] * h_site)
    priorities[i][0] = np.sum(nn_sites) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009085648148148148}
#island_id: 0
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(i%N - nn_site %N) < 2:
        if h[nn_site][i%N] > 0:
          nn_sites.append(J[abs(i%N - nn_site %N),i//N,nn_site//N] * (1+h_site))
        else:
          nn_sites.append(-J[abs(i%N - nn_site %N),i//N,nn_site//N] * (1-h_site))
    priorities[i][0] = np.sum(nn_sites) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0090125}
#island_id: 0
#version_generated: 2
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(i%N - nn_site %N) < 2:
        nn_sites.append(J[abs(i%N - nn_site %N),i//N,nn_site//N] * h_site)
    priorities[i][0] = np.sum(nn_sites) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = max(0, i-N)
    right_nbr = min(i+1, N*N-1)
    top_nbr = (i-N)%N
    bot_nbr = (i+N)%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = max(0, i-N)
    right_nbr = min(i+1, N*N-1)
    top_nbr = (i-N)%N
    bot_nbr = (i+N)%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': 0.001480401234567901}
#island_id: 3
#version_generated: 2
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = max(0, i-N)
    right_nbr = min(i+1, N*N-1)
    top_nbr = (i-N)%N
    bot_nbr = (i+N)%N
    
    total_spin = h[site_nbr][i%N]
    
    if J[2,i//N,(i-1)%N] > 0:
      total_spin -= J[2,i//N,(i-1)%N]*h[i//N][(i-1)%N]
    else:
      total_spin += J[2,i//N,(i-1)%N]*h[i//N][(i-1)%N]
    
    if J[3,i//N,(i+1)%N] > 0:
      total_spin -= J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]
    else:
      total_spin += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]
    
    if J[0,site_nbr,i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return priorities




#score: {'data2D.txt': 0.0007341049382716044}
#island_id: 3
#version_generated: 2
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = max(0, i-N)
    right_nbr = min(i+1, N*N-1)
    top_nbr = (i-N)%N
    bot_nbr = (i+N)%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if i > 0 and J[2,i//N,(i-1)%N] > 0:
      priorities[i][0] += J[2,i//N,(i-1)%N]*h[(i-1)//N][(i-1)%N]
      priorities[i][1] -= J[2,i//N,(i-1)%N]*h[(i-1)//N][(i-1)%N]
    elif i > 0 and J[2,i//N,(i-1)%N] < 0:
      priorities[i][0] -= J[2,i//N,(i-1)%N]*h[(i-1)//N][(i-1)%N]
      priorities[i][1] += J[2,i//N,(i-1)%N]*h[(i-1)//N][(i-1)%N]
    
    if i < N*N-1 and J[3,i//N,(i+1)%N] > 0:
      priorities[i][0] -= J[3,i//N,(i+1)%N]*h[(i+1)//N][(i+1)%N]
      priorities[i][1] += J[3,i//N,(i+1)%N]*h[(i+1)//N][(i+1)%N]
    elif i < N*N-1 and J[3,i//N,(i+1)%N] < 0:
      priorities[i][0] += J[3,i//N,(i+1)%N]*h[(i+1)//N][(i+1)%N]
      priorities[i][1] -= J[3,i//N,(i+1)%N]*h[(i+1)//N][(i+1)%N]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': 0.007523302469135803}
#island_id: 0
#version_generated: 2
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.007523302469135803}
#island_id: 0
#version_generated: 2
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin_left = np.sum(J[0,i//N,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': -0.0011961419753086417}
#island_id: 3
#version_generated: 2
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: 
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(3)])
      if h_sum > 0:
        priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(3)]) 
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0011961419753086417}
#island_id: 3
#version_generated: 2
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
     if k == 1 and (col+1)%N == N: # wraparound
       k = 0
     elif k == 2 and (col-1)%N == -1: 
       k = 1
     h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(3)])
     if h_sum > 0:
       priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(3)]) 
       priorities[i][1] = -priorities[i][0]
     else:
       priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(3)])
       priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0011961419753086417}
#island_id: 3
#version_generated: 2
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: # wraparound
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      h_sum = sum([J[l,i%N,i//N]*h[(l+N-1)%N][i%N] for l in range(3)])
      if h_sum > 0:
        priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]) for k in range(3)]) 
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]) for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at the current site
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total interaction from neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Determine the priority based on the magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time15:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.027900154320987653}
#island_id: 0
#version_generated: 2
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0006757716049382714}
#island_id: 0
#version_generated: 2
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+N-1) % N + ((i%N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,site_nbr1,i%N])*h[site_nbr1][i%N] + np.sum(J[:,site_nbr2,i%N])*h[site_nbr2][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0016186728395061725}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0529408950617284}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + nn_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.011763425925925925}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  # Improve the algorithm by taking into account the sum of all biases
  total_bias = np.sum(h)
  for i in range(N**2):
    priorities[i][0] += total_bias
    priorities[i][1] -= total_bias

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0005841049382716052}
#island_id: 0
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)])

    nn_sum *= h_site

    if h[i//N][i%N] > 0:
      priorities[i][0] = -nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.004844907407407407}
#island_id: 0
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])

    priorities[i][0] = h_site + 2 * np.sum(J[:,i//N,i//N] > 0)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046889969135802505}
#island_id: 0
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046535030864197566}
#island_id: 0
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin) * (np.sum(J[:,i//N,(i+1)%N])*h[(i+1)%N,i%N] >= 0)
      priority_down = 1 - priority_up
    else:
      priority_up = 1 - np.exp(-total_spin) * (np.sum(J[:,i//N,(i+1)%N])*h[(i+1)%N,i%N] <= 0)
      priority_down = priority_up
    
    priorities[i][0] = priority_up + 1
    priorities[i][1] = priority_down - 1
  
  return(priorities)




#score: {'data2D.txt': -0.0011652777777777779}
#island_id: 2
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    energy_up = h_site**2 + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    energy_down = -h_site**2 - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    diff = energy_up - energy_down
    priorities[i][0] = np.exp(-diff) / (np.exp(-energy_up) + np.exp(-energy_down))
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005389043209876543}
#island_id: 2
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = np.exp(h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]))
    p_down = np.exp(-h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]))
    priorities[i][0] = p_up / (p_up + p_down)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0015754629629629625}
#island_id: 2
#version_generated: 2
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 2
    else:
        priorities[i][0] -= 1
        priorities[i][1] += 2
    return(priorities)




#score: {'data2D.txt': 0.0013572530864197532}
#island_id: 2
#version_generated: 2
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    energy_up = h_site**2 + 2*h_site*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    energy_down = -h_site**2 - 2*h_site*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    diff = energy_up - energy_down
    priorities[i][0] = np.exp(-diff) / (np.exp(-energy_up) + np.exp(-energy_down))
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11753040123456804}
#island_id: 1
#version_generated: 2
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16545447530864224}
#island_id: 1
#version_generated: 2
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_2 = (i % N + ((i//N-1)%2 - 2)) % N
    total_spin += h[site_nbr][i%N] * J[3,i%N,(i+N)%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00022145061728395032}
#island_id: 1
#version_generated: 2
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h_site + h[site_nbr][k]
        priorities[i][1] -= h_site - h[site_nbr][k]
      else:
        priorities[i][0] -= h_site - h[site_nbr][k]
        priorities[i][1] += h_site + h[site_nbr][k]
    
    if J[3,i%N,i//N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][1]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': -0.0018606481481481477}
#island_id: 1
#version_generated: 2
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1

    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    if total_spin > 0:
      priorities[i][0] = -priorities[i][0]
      priorities[i][1] = -priorities[i][1]
    elif total_spin < 0:
      priorities[i][0] *= -1
      priorities[i][1] *= -1

  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.058880401234567926}
#island_id: 1
#version_generated: 2
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0015754629629629625}
#island_id: 2
#version_generated: 2
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 2
    else:
        priorities[i][0] -= 1
        priorities[i][1] += 2
    return(priorities)




#score: {'data2D.txt': -0.286489043209876}
#island_id: 2
#version_generated: 2
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += 2 + np.count_nonzero(h[site_nbr:] == 1)
      priorities[i][1] -= p_up - p_down
    else:
      priorities[i][0] -= 2 + np.count_nonzero(h[site_nbr:] == -1)
      priorities[i][1] = p_down - p_up
  return(priorities)




#score: {'data2D.txt': -0.0010442901234567908}
#island_id: 2
#version_generated: 2
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
        priorities[i][0] += 2
        priorities[i][1] -= 1
    else:
        priorities[i][0] -= 1
        priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': 0.17552021604938295}
#island_id: 1
#version_generated: 2
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_lr = (i % N + ((i//N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_lr][i//N]
      priorities[i][1] -= h[site_nbr_lr][i//N]
    else:
      priorities[i][0] -= h[site_nbr_lr][i//N]
      priorities[i][1] += h[site_nbr_lr][i//N]

    site_nbr_ud = (i // N + ((i%N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr_ud][i%N]
      priorities[i][1] -= h[site_nbr_ud][i%N]
    else:
      priorities[i][0] -= h[site_nbr_ud][i%N]
      priorities[i][1] += h[site_nbr_ud][i%N]

  return(priorities)




#score: {'data2D.txt': 0.0013233024691358026}
#island_id: 1
#version_generated: 2
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0013563271604938268}
#island_id: 1
#version_generated: 2
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.001793672839506173}
#island_id: 1
#version_generated: 2
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Calculate the priority based on the site interactions and magnetism
    for k in range(N**2):
      total_spin = 0
      for j in range(N):
        if J[3,k%N,j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[k][0] += total_spin
      priorities[k][1] -= total_spin
    
    return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004933796296296297}
#island_id: 0
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0019239197530864197}
#island_id: 3
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1 + np.tanh(h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])))
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0018458333333333332}
#island_id: 3
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[k][i%N] if k==site_nbr else J[0,i%N,k]*h[k][i%N] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    site_neighbors = [(k+N-1)%N for k in range(3)]
    neighbors_spin = sum([J[k,i%N,i//N]*h[n][i%N] for n,k in zip(site_neighbors,range(4))])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbors_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbors_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the priority based on site interactions and magnetism
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # calculate the priority based on site interactions and magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= 2*total_spin
      priorities[i][1] += 2*total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total magnetism and energy contribution from neighbors
    total_spin = h[site_nbr][i%N]
    energy_neighbor = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        energy_neighbor += 1
      else:
        energy_neighbor -= 1
    
    # Update priorities based on total magnetism and energy contribution
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + energy_neighbor, -total_spin - energy_neighbor]
    else:
      priorities[i] = [-total_spin - energy_neighbor, total_spin + energy_neighbor]
  
  return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_neighbor_spin = sum([J[j, i%N, i//N] * h[(i+j-1)%N, (i+k-1)%2] for j in range(4)])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_neighbor_spin/4, -total_spin + total_neighbor_spin/4]
    else:
      priorities[i] = [-total_spin + total_neighbor_spin/4, total_spin + total_neighbor_spin/4]
  
  return(priorities)




#score: {'data2D.txt': -0.005404475308641975}
#island_id: 1
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin = np.sign(total_spin)
    priorities[i][0] = site_spin * (np.sum(J[:,i//N,i//N]) + h[site_nbr][i%N])
    priorities[i][1] = -site_spin * (np.sum(J[:,i//N,i//N]) + h[site_nbr][i%N])
    
  return(priorities)




#score: {'data2D.txt': 0.06839675925925928}
#island_id: 1
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
   site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
   total_spin = h[site_nbr][i%N]
   
   for k in range(4):
    if J[k,i%N,i//N] > 0:
     total_spin += 1
    else:
     total_spin -= 1
   
   if h[i//N][i%N] > 0:
    priorities[i] = [total_spin, -total_spin]
   else:
    priorities[i] = [-total_spin, total_spin]
   
   for j in range(N):
    site_nbr = (i % N + ((j-1)%2 - 1)) % N
    if J[3,i%N,j] > 0:
     if h[i//N][j] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
     else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    site_nbr = (i % N + ((k-1)%2 - 1)) % N
    if J[k,i%N,i//N] > 0:
     if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
     else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
   
  return(priorities)




#score: {'data2D.txt': -0.007484104938271605}
#island_id: 2
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(3):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N:
          spin_h_site += J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(3):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N:
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024853395061728394}
#island_id: 2
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009112654320987659}
#island_id: 2
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00011342592592592493}
#island_id: 3
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[k][i%N] if k==site_nbr else J[0,i%N,k]*h[k][i%N] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023933641975308656}
#island_id: 3
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[0,i%N,k]*h[k][i%N] if k!=site_nbr else h[i//N][i%N] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023933641975308656}
#island_id: 3
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[0,i%N,k]*h[k][i%N] if k!=site_nbr else h[i//N][i%N] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001302932098765432}
#island_id: 3
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[0,i%N,k]*h[k][i%N] if k!=site_nbr else h[i//N][i%N] for k in range(N)])
    if sum(h[i//N]) > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001571759259259259}
#island_id: 2
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N][site_nbr] * h[site][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N][site_nbr] * h[site][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N][site_nbr] * h[site][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0038674382716049386}
#island_id: 2
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006802932098765432}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N or abs((j-N/2)%N - i%N) < 2:
          spin_h_site += J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N or abs((j-N/2)%N - i%N) < 2:
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018202160493827157}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.007518055555555556}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N or ((j+N-1)%N == i//N and (j-N)%N == i%N):
          spin_h_site += J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if i//N == j or (j+1)%N == i%N or (j-1)%N == i%N or ((j+N-1)%N == i//N and (j-N)%N == i%N):
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005597376543209876}
#island_id: 3
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = np.tanh(sum_h)
    else:
      priorities[i][1] = -np.tanh(sum_h)
  return(priorities)




#score: {'data2D.txt': -0.002281944444444445}
#island_id: 3
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for j in range(4): # considering all four nearest neighbors
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += h[k%N][k//N]
      else:
        sum_h -= h[k%N][k//N]
    priorities[i][0] = np.tanh(sum_h)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0026535493827160497}
#island_id: 3
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = np.exp(h_site + neighbors_sum)
    priorities[i][1] = 1 / priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0025254629629629633}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        priorities[i][0] += J[j,i//N,i%N]*h[(j+N-1)%4][i%N]
      else:
        priorities[i][0] -= J[j,i//N,i%N]*h[(j+N-1)%4][i%N]
    if total_spin > 0:
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.005422993827160495}
#island_id: 2
#version_generated: 2
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0019442901234567897}
#island_id: 0
#version_generated: 2
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0003621913580246916}
#island_id: 1
#version_generated: 2
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
      priorities[i][1] = total_spin - np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
  
  return(priorities)




#score: {'data2D.txt': -0.03922608024691358}
#island_id: 1
#version_generated: 2
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = np.sum(h[i//N][i%N] + np.array([J[k,i//N,i%N] for k in range(4)]))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      neighbor_site = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin += h[neighbor_site][i%N]
      else:
        total_spin -= h[neighbor_site][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.04095262345679013}
#island_id: 1
#version_generated: 2
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin + np.sum(h[:,i%N])
    priorities[i][1] = -total_spin - np.sum(h[:,i%N])
  
  return(priorities)




#score: {'data2D.txt': 0.0013285493827160497}
#island_id: 0
#version_generated: 2
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      J_sum = sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in neighbors])
      priorities[i][0] = J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      J_sum = -sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in neighbors])
      priorities[i][0] = J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.001837808641975309}
#island_id: 0
#version_generated: 2
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[k][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*x for k, x in [(k, (h[site_nbr][j]+total_spin/4)) for k, j in [(k, (k+i-N)//N) for k in range(4)]]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*x for k, x in [(k, (h[site_nbr][j]-total_spin/4)) for k, j in [(k, (k+i-N)//N) for k in range(4)]]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002678858024691358}
#island_id: 0
#version_generated: 2
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      j = (k+i-N)//N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr][j]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr][j]
    priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time15:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11228966049382728}
#island_id: 1
#version_generated: 2
#generate time15:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]*h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11623101851851865}
#island_id: 1
#version_generated: 2
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.16621311728395086}
#island_id: 1
#version_generated: 2
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.023476388888888887}
#island_id: 1
#version_generated: 2
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i//N,i%N] > 0:
      total_spin += h[i//N].sum() - h[i//N][i%N]
    else:
      total_spin -= h[i//N].sum() + h[i//N][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[i//N].sum() - h[i//N][i%N]
      priorities[i][1] -= h[i//N].sum() + h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N].sum() + h[i//N][i%N]
      priorities[i][1] += h[i//N].sum() - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0019239197530864197}
#island_id: 3
#version_generated: 2
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority = 1 + np.tanh(h_site + sum(neighbors))
    priorities[i][0] = priority
    priorities[i][1] = 1 - priority
  return(priorities)




#score: {'data2D.txt': 0.0007115740740740732}
#island_id: 0
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.020664043209876543}
#island_id: 0
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[site_nbr][i%N] + h[(i+k-1)%N][i%N]) for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += nn_energy / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= nn_energy / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.004914969135802469}
#island_id: 0
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin including magnetism and nearest neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the magnetism and nearest neighbor interactions
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][j] for j in range(N) if abs(j-i%N) <= 1]) 
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.005422993827160495}
#island_id: 2
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 9.861111111111126e-05}
#island_id: 2
#version_generated: 2
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in [(i-1)%N, (i+1)%N]:
      if j == i:
        continue
      total_spin += h[j//N][j%N]
    for k in range(3):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k, i%N, i//N]*h[(k+N-1)%N][i%N]
        priorities[i][1] -= priorities[i][0]
      else:
        priorities[i][0] -= J[k, i%N, i//N]*h[(k+N-1)%N][i%N]
        priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0026535493827160497}
#island_id: 3
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    interactions = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priority_spin_up = np.exp(h_site + interactions)
    priority_spin_down = 1 / priority_spin_up
    priorities[i][0] = priority_spin_up / (priority_spin_up + priority_spin_down)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0019239197530864197}
#island_id: 3
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority = 1 + np.tanh(h_site + sum(neighbors))
    priorities[i][0] = priority
    priorities[i][1] = 1 - priority
  return(priorities)




#score: {'data2D.txt': 0.0008254629629629621}
#island_id: 3
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority_spin_1 = np.exp(h_site + sum(neighbors))
    priority_spin_minus_1 = 1 / (np.exp(-2*h_site) * sum([np.exp(J[k,i%N,i//N]*h[(k+N-1)%N][i%N]) for k in range(3)]))
    priorities[i][0] = priority_spin_1 / (priority_spin_1 + priority_spin_minus_1)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0014023148148148148}
#island_id: 3
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority_sum = sum(neighbors)
    if np.abs(priority_sum) > 0.5:
      if priority_sum > 0:
        priorities[i][0] = 1
        priorities[i][1] = 0
      else:
        priorities[i][0] = 0
        priorities[i][1] = 1
    else:
      priority_avg = np.mean([np.exp(h_site + neighbor) for neighbor in neighbors])
      if priority_avg > 0.5:
        priorities[i][0] = 1
        priorities[i][1] = 0
      else:
        priorities[i][0] = 0
        priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': -0.0017486111111111116}
#island_id: 3
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    total_h = h_site + sum(neighbors)
    priority = 2 * np.tanh(total_h) - 1
    priorities[i][0] = priority
    priorities[i][1] = 1 - priority
  return(priorities)




#score: {'data2D.txt': -0.0009461419753086417}
#island_id: 2
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    total_spin = 0
    for j in [(i-1)%N, (i+1)%N]:
      if j == i:
        continue
      total_spin += h[j//N][j%N]
    
    site_nbrs = [i % N + ((i // N - 1) % 2 - 1)] * 4
    for k in range(4):
      site_nbr = site_nbrs[k % 4]
      if h[site_nbr][i % N] > 0:
        priorities[i][0] += J[k, i % N, i // N] * h[site_nbr][i % N]
        priorities[i][1] -= priorities[i][0]
      else:
        priorities[i][0] -= J[k, i % N, i // N] * h[site_nbr][i % N]
        priorities[i][1] += priorities[i][0]
    
    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.0010612654320987659}
#island_id: 2
#version_generated: 2
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for j in [(i-1)%N, (i+1)%N]:
      if j == i:
        continue
      total_spin += h[j//N][j%N]
      site_nbrs.append(j)
    for k in range(2):
      site_nbr = (i % N + ((site_nbrs[k]-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k, i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] -= priorities[i][0]
      else:
        priorities[i][0] -= J[k, i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0006640432098765429}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in [(i-1)%N, (i+1)%N]:
      if j == i:
        continue
      total_spin += h[j//N][j%N]
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += J[0, i%N, i//N]*h[site_nbr][i%N]
    priorities[i][1] -= priorities[i][0]
  for k in range(1):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[k, i%N, i//N]*h[site_nbr][i%N]
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= J[k, i%N, i//N]*h[site_nbr][i%N]
      priorities[i][1] += priorities[i][0]
  for k in range(2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= J[k, i%N, i//N]*h[site_nbr][i%N]
      priorities[i][1] += priorities[i][0]
    else:
      priorities[i][0] += J[k, i%N, i//N]*h[site_nbr][i%N]
      priorities[i][1] -= priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0027862654320987665}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = -spin_h_site
    if h[i//N][i%N] > 0:
      priorities[i][1] = np.sum(np.array([J[3,i//N,i%N], J[2,i//N,i%N]]))
    else:
      priorities[i][1] = np.sum(np.array([-J[3,i//N,i%N], -J[2,i//N,i%N]]))

  return(priorities)




#score: {'data2D.txt': 0.060781944444444444}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = J[0, i//N, i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site += J[j, i//N, i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -J[0, site_nbr, i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site -= J[j, site_nbr, i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.27132638888888844}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site -= J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = -spin_h_site
    if h[i//N][i%N] > 0:
      priorities[i][1] = 2*abs(priorities[i][0]) + J[3,i//N,i%N]*h[(3+N-4)%N][i%N]
    else:
      priorities[i][1] = -2*abs(priorities[i][0]) - J[3,i//N,i%N]*h[(3+N-4)%N][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0022902777777777774}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = h[site_nbr][i%N]
      for j in range(4):
        if J[j, i//N, i%N] * h[(j+N-4)%N][i%N] > 0:
          spin_h_site += J[j, i//N, i%N] * h[(j+N-4)%N][i%N]
        else:
          spin_h_site -= J[j, i//N, i%N] * h[(j+N-4)%N][i%N]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -h[site_nbr][i%N]
      for j in range(4):
        if J[j, i//N, i%N] * h[(j+N-4)%N][i%N] > 0:
          spin_h_site -= J[j, i//N, i%N] * h[(j+N-4)%N][i%N]
        else:
          spin_h_site += J[j, i//N, i%N] * h[(j+N-4)%N][i%N]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.30264984567901165}
#island_id: 2
#version_generated: 2
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    magnetism = h[site_nbr][i%N]
    nearest_neighbors_magnetism = [J[0,i//N,i%N]*h[(0+N-4)%N][i%N], J[1,i//N,i%N]*h[(1+N-4)%N][i%N],
                     J[2,i//N,i%N]*h[(2+N-4)%N][i%N], J[3,i//N,i%N]*h[(3+N-4)%N][i%N]]
    priorities[i][0] = magnetism + sum(nearest_neighbors_magnetism)
    if h[i//N][i%N] > 0:
      priorities[i][1] = -2*abs(priorities[i][0]) - max(0, J[3,i//N,i%N]*h[(3+N-4)%N][i%N])
    else:
      priorities[i][1] = 2*abs(priorities[i][0]) + min(0, J[3,i//N,i%N]*h[(3+N-4)%N][i%N])

  return(priorities)




#score: {'data2D.txt': -0.2600615740740738}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
        total_spin += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(total_spin)
      priorities[i][1] = -2*abs(total_spin) - J[3,i//N,i%N]*h[(3+N-4)%N][i%N]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = 2*abs(total_spin) + J[3,i//N,i%N]*h[(3+N-4)%N][i%N]

  return(priorities)




#score: {'data2D.txt': 0.27132638888888844}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          total_spin += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = total_spin
    else:
      total_spin = -h[site_nbr][i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          total_spin -= J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
      priorities[i][0] = -total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = 2*abs(total_spin) + J[3,i//N,i%N]*h[(3+N-4)%N][i%N]
    else:
      priorities[i][1] = -2*abs(total_spin) - J[3,i//N,i%N]*h[(3+N-4)%N][i%N]

  return(priorities)




#score: {'data2D.txt': -0.28745848765432047}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
        total_spin += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -2*abs(total_spin)
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = 2*abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.03137083333333333}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = J[0, i//N, i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site += J[j, i//N, i%N]
      spin_v = 0
      for k in range(4):
        if (k == 0 and i//N != 0) or (k == 1 and i%N != N-1) or (k == 2 and i//N != N-1) or (k == 3 and i%N == 0):
          spin_v += J[k, site_nbr, i%N]
      priorities[i][0] = spin_h_site - spin_v
    else:
      spin_h_site = -J[0, site_nbr, i%N]
      for j in range(4):
        if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
          spin_h_site -= J[j, site_nbr, i%N]
      spin_v = 0
      for k in range(4):
        if (k == 0 and i//N != 0) or (k == 1 and i%N != N-1) or (k == 2 and i//N != N-1) or (k == 3 and i%N == 0):
          spin_v += J[k, site_nbr, i%N]
      priorities[i][0] = -spin_h_site + spin_v
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16722824074074089}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
        total_spin += J[j, site_nbr, i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 2
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin - 2
  return(priorities)




#score: {'data2D.txt': 0.10130632716049383}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_h_site = J[0, i//N, i%N]
      for j in range(4):
        if j == 0 and i//N != 0:
          spin_h_site += J[j, i//N-1, i%N]
        elif j == 1 and i%N != N-1:
          spin_h_site += J[j, i//N, i%N+1]
        elif j == 2 and i//N != N-1:
          spin_h_site += J[j, i//N+1, i%N]
        elif j == 3 and i%N == 0:
          spin_h_site += J[j, i//N, i%N+1]
      priorities[i][0] = spin_h_site
    else:
      spin_h_site = -J[0, site_nbr, i%N]
      for j in range(4):
        if j == 0 and i//N != 0:
          spin_h_site -= J[j, i//N-1, i%N]
        elif j == 1 and i%N != N-1:
          spin_h_site -= J[j, i//N, i%N+1]
        elif j == 2 and i//N != N-1:
          spin_h_site -= J[j, i//N+1, i%N]
        elif j == 3 and i%N == 0:
          spin_h_site -= J[j, i//N, i%N+1]
      priorities[i][0] = -spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00037669753086419744}
#island_id: 2
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if (j == 0 and i//N != 0) or (j == 1 and i%N != N-1) or (j == 2 and i//N != N-1) or (j == 3 and i%N == 0):
        total_spin += J[j, site_nbr, i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin + 2*h[site_nbr][i%N]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin - 2*h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': -0.005389043209876543}
#island_id: 3
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    interactions = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priority_spin_up = np.exp(h_site + interactions)
    priority_spin_down = 1 / priority_spin_up
    
    total_priority = priority_spin_up + priority_spin_down
    priorities[i][0] = priority_spin_up / total_priority
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005389043209876543}
#island_id: 3
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interactions = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priority_spin_up = np.exp(h[site_nbr][i%N] + interactions)
    priority_spin_down = 1 / priority_spin_up
    priorities[i][0] = priority_spin_up / (priority_spin_up + priority_spin_down)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014109567901234566}
#island_id: 3
#version_generated: 2
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(3):
      if J[j,i%N,i//N] > 0:
        total_spin += h[(j+N-1)%N][i%N]
      else:
        total_spin -= h[(j+N-1)%N][i%N]
    priority_spin_up = np.exp(total_spin)
    priority_spin_down = 1 / priority_spin_up
    priorities[i][0] = priority_spin_up / (priority_spin_up + priority_spin_down)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00447824074074074}
#island_id: 0
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * np.sum(J[:,site_nbr,i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.00039212962962963013}
#island_id: 0
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[:,site_nbr,i%N].sum() > 0:
      priorities[i][0] += total_spin * 4.5
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 4.5
      priorities[i][1] += 3.5 * total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= J[:,site_nbr,i%N].sum() * h[site_nbr][i%N]
      priorities[i][1] += 4.5 * J[:,site_nbr,i%N].sum() * h[site_nbr][i%N]
    else:
      priorities[i][0] += J[:,site_nbr,i%N].sum() * h[site_nbr][i%N]
      priorities[i][1] -= 3.5 * J[:,site_nbr,i%N].sum() * h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.00099645061728395}
#island_id: 0
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': 0.050189969135802474}
#island_id: 0
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,i%N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 3.5*total_spin
      priorities[i][1] -= 2.5*total_spin
    else:
      priorities[i][0] -= 3.5*total_spin
      priorities[i][1] += 2.5*total_spin
  return(priorities)




#score: {'data2D.txt': 0.14339182098765452}
#island_id: 2
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i//N,i%N]
    for j in range(4):
      if j == 0 and i//N != 0:
        total_spin += J[j,i//N-1,i%N]
      elif j == 1 and i%N != N-1:
        total_spin += J[j,i//N,i%N+1]
      elif j == 2 and i//N != N-1:
        total_spin += J[j,i//N+1,i%N]
      elif j == 3 and i%N == 0:
        total_spin += J[j,i//N,i%N+1]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.014277314814814816}
#island_id: 2
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_h_site = 0
    for j in range(4):
      if j == 0 and i//N != 0:
        spin_h_site += J[j, i//N-1, i%N]
      elif j == 1 and i%N != N-1:
        spin_h_site += J[j, i//N, i%N+1]
      elif j == 2 and i//N != N-1:
        spin_h_site += J[j, i//N+1, i%N]
      elif j == 3 and i%N == 0:
        spin_h_site += J[j, i//N, i%N+1]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_h_site
    else:
      priorities[i][0] = spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.01753287037037037}
#island_id: 2
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += J[0, i//N, i%N]
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin += J[j, i//N-1, i%N]
        elif j == 1 and i%N != N-1:
          total_spin += J[j, i//N, i%N+1]
        elif j == 2 and i//N != N-1:
          total_spin += J[j, i//N+1, i%N]
        elif j == 3 and i%N == 0:
          total_spin += J[j, i//N, i%N+1]
      priorities[i][0] = total_spin
    else:
      total_spin -= J[0, site_nbr, i%N]
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin -= J[j, i//N-1, i%N]
        elif j == 1 and i%N != N-1:
          total_spin -= J[j, i//N, i%N+1]
        elif j == 2 and i//N != N-1:
          total_spin -= J[j, i//N+1, i%N]
        elif j == 3 and i%N == 0:
          total_spin -= J[j, i//N, i%N+1]
      priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11537731481481495}
#island_id: 1
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i//N
    
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in [(0,1), (1,0), (1,1), (0,-1)]:
      if J[k[0],i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.010434413580246913}
#island_id: 1
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for j in range(4):
      if J[j,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N] + J[j,i%N,i//N]
        priorities[i][1] -= h[site_nbr1][i%N] + J[j,i%N,i//N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N] + J[j,i%N,i//N]
        priorities[i][1] += h[site_nbr1][i%N] + J[j,i%N,i//N]

    if i % (N*N) < N:
      site_nbr = (i % N + ((0-1)%2 - 1)) % N
      total_spin = h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] += total_spin
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= total_spin
        priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': 0.019002314814814816}
#island_id: 2
#version_generated: 2
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] -= (priorities[i][0] + total_spin)
    else:
      priorities[i][0] -= sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] += (priorities[i][0] - total_spin)
  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14498904320987674}
#island_id: 2
#version_generated: 2
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[site_nbr//N][site_nbr%N] for site_nbr in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum(J[k, i%N, i//N]*h[(k+N-1)%N][i%N] for k in range(3))
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009710030864197531}
#island_id: 2
#version_generated: 2
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i//N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': 0.001860339506172839}
#island_id: 2
#version_generated: 2
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_h_site = h[site_nbr][i%N]
    for j in range(4):
      if j == 0 and i//N != 0:
        spin_h_site += J[j, i//N-1, i%N]
      elif j == 1 and i%N != N-1:
        spin_h_site += J[j, i//N, i%N+1]
      elif j == 2 and i//N != N-1:
        spin_h_site += J[j, i//N+1, i%N]
      elif j == 3 and i%N == 0:
        spin_h_site += J[j, i//N, i%N+1]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -spin_h_site
    else:
      priorities[i][0] = spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.016619907407407406}
#island_id: 2
#version_generated: 2
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_h_site = h[site_nbr][i%N]
    for j in [0, 1, 3]:
      if j == 0 and i//N != 0:
        spin_h_site += J[j, i//N-1, i%N]
      elif j == 1 and i%N != N-1:
        spin_h_site += J[j, i//N, i%N+1]
      elif j == 3 and i%N == 0:
        spin_h_site += J[j, i//N, i%N+1]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_h_site
    else:
      priorities[i][0] = spin_h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0016186728395061725}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = (1 + np.tanh(total_energy)) * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.07459151234567903}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = np.exp(-2*(priorities[i][0]+J[0,i//N,site_nbr]))
  
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = 2*h_site + total_energy

  return(priorities)




#score: {'data2D.txt': 0.015418055555555555}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = ((i//N)%N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,i%N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 3.5*total_spin
      priorities[i][1] -= 2.5*total_spin
    else:
      priorities[i][0] -= 3.5*total_spin
      priorities[i][1] += 2.5*total_spin
  
  # Improved part: Add the interaction with the next neighbor
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2.5*J[3,i//N,i%N]
      priorities[i][1] -= 1.5*J[3,i//N,i%N]
    else:
      priorities[i][0] -= 2.5*J[3,i//N,i%N]
      priorities[i][1] += 1.5*J[3,i//N,i%N]

  return(priorities)




#score: {'data2D.txt': -0.0011368827160493824}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    spin_h = h[i//N][i%N]
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i%N] == spin_h:
        total_spin += 2*h[site_nbr][i%N]
      else:
        total_spin += h[site_nbr][i%N]
    if spin_h > 0:
      priorities[i][0] += 3.5*total_spin
      priorities[i][1] -= 2.5*total_spin
    else:
      priorities[i][0] -= 3.5*total_spin
      priorities[i][1] += 2.5*total_spin
  return(priorities)




#score: {'data2D.txt': 0.07503225308641975}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = 3.5*total_spin
      priorities[i][1] = -2.5*total_spin
    else:
      priorities[i][0] = -3.5*total_spin
      priorities[i][1] = 2.5*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0018720679012345673}
#island_id: 0
#version_generated: 2
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if abs(J[j,i//N,i%N]) > 0.5:
        total_spin += J[j,i//N,i%N] * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return priorities




#score: {'data2D.txt': -0.24966404320987642}
#island_id: 2
#version_generated: 2
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      for j in range(4):
        if j == 0 and i//N != 0 or j == 1 and i%N != N-1 or j == 2 and i//N != N-1 or j == 3 and i%N == 0:
          total_spin += J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
    else:
      for j in range(4):
        if j == 0 and i//N != 0 or j == 1 and i%N != N-1 or j == 2 and i//N != N-1 or j == 3 and i%N == 0:
          total_spin -= J[j,i//N,i%N]*h[(j+N-4)%N][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -2*abs(total_spin) - J[3,i//N,i%N]*h[(3+N-4)%N][i%N]
    else:
      priorities[i][1] = 2*abs(total_spin) + J[3,i//N,i%N]*h[(3+N-4)%N][i%N]

  return(priorities)




#score: {'data2D.txt': 0.11786959876543224}
#island_id: 1
#version_generated: 2
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.15095293209876565}
#island_id: 1
#version_generated: 2
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([h[site_nbr][j] for j in range(N) if J[3,i%N,j] > 0])
      priorities[i][1] = -total_spin - sum([h[site_nbr][j] for j in range(N) if J[3,i%N,j] <= 0])
    else:
      priorities[i][0] = -total_spin - sum([h[site_nbr][j] for j in range(N) if J[3,i%N,j] > 0])
      priorities[i][1] = total_spin + sum([h[site_nbr][j] for j in range(N) if J[3,i%N,j] <= 0])
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.06296805555555555}
#island_id: 0
#version_generated: 2
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        continue
      priority_total[0] += J[k,i//N,neighbor]
      if k==3:
        priority_total[1] -= 2*J[k,i//N,neighbor]
      else:
        priority_total[1] -= J[k,i//N,neighbor]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.04384429012345679}
#island_id: 0
#version_generated: 2
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      for k in range(4):
        if k==3:
          continue
        neighbor = (site_nbr + ((k-1)%2 - 1)) % N
        if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
          neighbor = (neighbor + ((k-1)%2 - 1)) % N
        priority_total[0] += J[k,i//N,nn_site]
        priority_total[1] -= J[k,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
  return(priorities)




#score: {'data2D.txt': -0.0006717592592592595}
#island_id: 0
#version_generated: 2
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.0010612654320987659}
#island_id: 2
#version_generated: 2
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    for k in [(0, 1), (1, 0)]:
      site_nbr = (i % N + ((site_nbrs[k[0]]-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k[0], i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] -= priorities[i][0]
      else:
        priorities[i][0] -= J[k[0], i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.004445216049382716}
#island_id: 2
#version_generated: 2
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    for k in range(2):
      site_nbr = (site_nbrs[k]%N + ((site_nbrs[k]//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k, i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] -= priorities[i][0]
      else:
        priorities[i][0] -= J[k, i%N, i//N]*h[site_nbr][i%N]
        priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1292634259259261}
#island_id: 2
#version_generated: 2
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] += priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0010430555555555555}
#island_id: 1
#version_generated: 2
#generate time15:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%N - 1)) % N
    site_nbr4 = (i // N + ((i%N+1)%N - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]
    
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr4][i%N]
      priorities[i][1] -= h[site_nbr4][i%N]
    else:
      priorities[i][0] -= h[site_nbr4][i%N]
      priorities[i][1] += h[site_nbr4][i%N]
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N] + h[site_nbr3][i%N] + h[site_nbr4][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.007969907407407406}
#island_id: 1
#version_generated: 2
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.33299274691357933}
#island_id: 2
#version_generated: 2
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] -= max(1, sum(J[k, i//N, i//N] for k, site_nbr in enumerate(site_nbrs)))
    else:
      priorities[i][0] -= sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] += max(1, -sum(J[k, i//N, i//N] for k, site_nbr in enumerate(site_nbrs)))
  return(priorities)




#score: {'data2D.txt': -0.0001557098765432094}
#island_id: 2
#version_generated: 2
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] += total_spin
  return(priorities)




#score: {'data2D.txt': -0.0010597222222222223}
#island_id: 2
#version_generated: 2
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i-1)%N, (i+1)%N]
    total_spin = sum(h[j//N][j%N] for j in site_nbrs)
    if h[i//N][i%N] > 0:
      spin_energy = sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] -= spin_energy
      priorities[i][0] += spin_energy
    else:
      spin_energy = -sum(J[k, i//N, i//N]*h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
      priorities[i][1] += spin_energy
      priorities[i][0] -= spin_energy
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009165123456790122}
#island_id: 3
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for j in range(4): 
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += h[k%N][k//N]
      else:
        sum_h -= h[k%N][k//N]
    for j in range(4):
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += J[j,i//N,k//N]
      else:
        sum_h -= J[j,i//N,k//N]
    priorities[i][0] = np.tanh(sum_h)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0036865740740740743}
#island_id: 3
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for j in range(4): # considering all four nearest neighbors
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += h[k%N][k//N]
      else:
        sum_h -= h[k%N][k//N]
    priorities[i][0] = np.tanh(sum_h)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002281944444444445}
#island_id: 3
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N]
    for j in range(4): 
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        total_h += h[k%N][k//N]
      else:
        total_h -= h[k%N][k//N]
    priorities[i][0] = np.tanh(total_h)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002281944444444445}
#island_id: 3
#version_generated: 2
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for j in range(4): # considering all four nearest neighbors
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += h[k%N][k//N]
      else:
        sum_h -= h[k%N][k//N]
    priorities[i][0] = np.tanh(sum_h)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002224228395061729}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    if J[0,i%N,i//N] > 0:
      priority = np.tanh(h_site + sum(neighbors)) * N
    else:
      priority = -np.tanh(-h_site - sum(neighbors)) * N
    priorities[i][0] = priority
    priorities[i][1] = 1 - priority
  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority = 2 * np.tanh(h_site + sum(neighbors))
    priorities[i][0] = (1 + priority) / 2
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005320216049382717}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    priority = np.tanh(h_site + sum(neighbors))
    priorities[i][0] = priority
    priorities[i][1] = 1 - priority
  return(priorities)




#score: {'data2D.txt': -0.002281944444444445}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for j in range(4): 
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        sum_h += h[k%N][k//N]
      else:
        sum_h -= h[k%N][k//N]
    priorities[i][0] = np.tanh(sum_h)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0005720679012345681}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = [0,0]
    for j in range(4): 
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        total_spin[0] += h[k%N][k//N]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[k%N][k//N]
        total_spin[1] += 1
    priorities[i][0] = np.tanh(total_spin[0])
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002281944444444445}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4): # considering all four nearest neighbors
      k = (i // N + ((j-1) % 2 - 1)) % N * N + i % N
      if J[j,i//N,k//N] > 0:
        total_spin += h[k%N][k//N]
      else:
        total_spin -= h[k%N][k//N]
    priorities[i][0] = np.tanh(total_spin)
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.025480709876543224}
#island_id: 1
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[(i % N + (N-1)%N)%N][i//N]
      priorities[i][1] -= h[(i % N + (N-1)%N)%N][i//N]
    else:
      priorities[i][0] -= h[(i % N + (N-1)%N)%N][i//N]
      priorities[i][1] += h[(i % N + (N-1)%N)%N][i//N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[i%N,(i // N + (N-1)%N)%N]
      priorities[i][1] -= h[i%N,(i // N + (N-1)%N)%N]
    else:
      priorities[i][0] -= h[i%N,(i // N + (N-1)%N)%N]
      priorities[i][1] += h[i%N,(i // N + (N-1)%N)%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Combine interactions from the four neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the site's own magnetism to the total spin
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16406404320987678}
#island_id: 1
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if i // N > 0:
      if J[3,i%N,(i//N) % N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if i % N > 0:
      if J[1,(i//N)%N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,(i//N)%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0023538580246913582}
#island_id: 2
#version_generated: 2
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + total_spin
    
    if np.abs(priorities[i][0]) < 1e-6:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009112654320987659}
#island_id: 2
#version_generated: 2
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0005029320987654321}
#island_id: 2
#version_generated: 2
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.002145833333333333}
#island_id: 2
#version_generated: 2
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = (1-h_site)*total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': -0.0005029320987654321}
#island_id: 2
#version_generated: 2
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.0009112654320987659}
#island_id: 2
#version_generated: 2
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priority = h_site + total_spin
    priorities[i][0] = np.exp(priority)
    priorities[i][1] = 1 / priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.006316203703703703}
#island_id: 2
#version_generated: 2
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    else:
      total_spin = -sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.07061990740740741}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    else:
      priorities[i][0] = 1
      priorities[i][1] = -1
  return(priorities)




#score: {'data2D.txt': 0.0007476851851851852}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.05059953703703704}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k%2==0 else h[(i+k+1)%N][i%N]) for k in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002145833333333333}
#island_id: 2
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = (1-h_site)*total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.0008631172839506172}
#island_id: 2
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = (1-h_site)*total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    priorities[i][0] = (1-h[site_nbr][i%N])*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0008421296296296296}
#island_id: 2
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': 0.07344182098765435}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0329050925925926}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = -np.tanh(h_site + nn_energy)
    priorities[i][1] = 1 - np.tanh(-h_site - nn_energy)

  return(priorities)




#score: {'data2D.txt': 0.03853317901234568}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][1] = -priorities[i][0]
    priority_sum = np.sum(np.abs(J[:,i//N,i//N]))
    if J[3,i//N,site_nbr] > 0:
      priority_sum += h[i//N][i%N]
    else:
      priority_sum -= h[i//N][i%N]

    priorities[i][0] = h_site + nn_energy + (J[3,i//N,site_nbr] - J[1,i//N,site_nbr]) * np.tanh((priority_sum)/2.0)
  return(priorities)




#score: {'data2D.txt': -0.006181944444444445}
#island_id: 0
#version_generated: 2
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      total_energy += J[3,i//N,site_nbr]
    else:
      total_energy -= J[3,i//N,site_nbr]

    priorities[i][0] = total_energy + nn_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0023177469135802465}
#island_id: 1
#version_generated: 2
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_spin = 1
    else:
      h_spin = -1

    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h_spin
      priorities[i][1] -= h_spin
    else:
      priorities[i][0] -= h_spin
      priorities[i][1] += h_spin

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.08014490740740748}
#island_id: 2
#version_generated: 2
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_spin += h[i//N][i%N]
    priorities[i][0] = (1-h_site)*total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.0008631172839506172}
#island_id: 2
#version_generated: 2
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = (1-h_site)*total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    priorities[i][0] = (1-h[site_nbr][i%N])*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0014766975308641976}
#island_id: 2
#version_generated: 2
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.12003626543209882}
#island_id: 3
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if total_spin > 0:
      priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N])*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N])*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.000710030864197531}
#island_id: 3
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[(i+N-1)%N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0054038580246913576}
#island_id: 3
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(3):
        total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(3):
        total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': 0.07690231481481481}
#island_id: 0
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06355015432098766}
#island_id: 0
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      if i+k < N**2 and i+k >= 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08565478395061729}
#island_id: 0
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      if k == 0:
        total_energy += J[0,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 2:
        total_energy -= J[2,i//N,i%N] * h[(i+k-1)%N][i%N]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.023175462962962964}
#island_id: 0
#version_generated: 2
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * h[(i+k)%N][i%N]
    priorities[i][0] = total_energy + np.sum(J[:,i//N,i%N])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0018625000000000007}
#island_id: 1
#version_generated: 2
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if i % N > 0:
      total_spin += h[i//N][i%N-1]
      total_spin -= J[3,i%N,i//N-1]
    if i // N > 0:
      total_spin += h[(i-1)//N][(i-1)%N]
      total_spin -= J[2,(i-1)%N,(i-1)//N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(np.abs(J[:,i//N,i//N]))
      priorities[i][1] = -total_spin + np.sum(np.abs(J[:,i//N,i//N]))
    else:
      priorities[i][0] = -total_spin + np.sum(np.abs(J[:,i//N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.abs(J[:,i//N,i//N]))
    
  return(priorities)




#score: {'data2D.txt': -0.0014606481481481476}
#island_id: 2
#version_generated: 2
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)], axis=0)
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus * (np.sum([J[k,i//N,k]%2 for k in range(3)]) % 2) / (N**2)
    priorities[i][1] = priority_minus * ((N**2) - np.sum([J[k,i//N,k]%2 for k in range(3)]) % 2) / (N**2)
  return(priorities)




#score: {'data2D.txt': -0.0003834876543209872}
#island_id: 2
#version_generated: 2
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    local_magnetization = np.tanh(total_spin)
    priority_minus = np.exp(-total_spin) * (1 + local_magnetization)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.003081018518518519}
#island_id: 2
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
    if np.isclose(priority_plus, priority_minus):
      if np.random.rand() < 0.5:
        priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0006856481481481482}
#island_id: 0
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = J[0,i%N,i//N] * h[i//N][i%N]
    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    if energy_nn > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.07344182098765435}
#island_id: 0
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      energy_nn = h[i//N][i%N]
    else:
      energy_nn = -h[i//N][i%N]

    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0036081790123456787}
#island_id: 0
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = J[0,i%N,i//N] * h[i//N][i%N]
    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07806311728395064}
#island_id: 0
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0] - J[1,i//N,i%N]

  return(priorities)




#score: {'data2D.txt': -0.0014418209876543222}
#island_id: 2
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': -0.0014078703703703705}
#island_id: 2
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h_site > 0:
      priorities[i][1] = np.exp(-2*h_site*total_spin)
    else:
      priorities[i][1] = np.exp(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0038208333333333328}
#island_id: 2
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = h[site_nbr][i%N]
    priorities[i][0] = total_spin + np.abs(total_spin)
    priorities[i][1] = np.exp(-2*h_site*total_spin) if total_spin > 0 else -np.exp(-2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': 0.002591203703703704}
#island_id: 2
#version_generated: 2
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (1 + np.sign(h[site_nbr][i%N]))
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site][i%N]
        priorities[i][1] -= h[site][i%N]
      else:
        priorities[i][0] -= h[site][i%N]
        priorities[i][1] += h[site][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.023300771604938274}
#island_id: 1
#version_generated: 2
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i][0] = np.sum(J[:,i//N,i%N])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16621311728395086}
#island_id: 1
#version_generated: 2
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0008208333333333336}
#island_id: 3
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[(i+N-1)%N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  # sort the spins based on their priority
  for i in range(N**2):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.09664398148148148}
#island_id: 0
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    
    priorities[i][0] = (h_site + total_energy) / 2
    priorities[i][1] = np.exp(-4 * (priorities[i][0]+J[0,i//N,site_nbr]))
  
  return(priorities)




#score: {'data2D.txt': -0.04207885802469136}
#island_id: 0
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = []
    energies = []
    for j in range(4):
      if J[j,i//N,site_nbr] > 0:
        energy = h[(site_nbr + ((j-1)%2 - 1)) % N][i%N]
      else:
        energy = -h[(site_nbr + ((j-1)%2 - 1)) % N][i%N]

      nn_sites.append((site_nbr + ((j-1)%2 - 1)) % N)
      energies.append(energy)

    total_energy = sum(energies)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = np.exp(-2*(priorities[i][0]+J[0,i//N,site_nbr]))
  return(priorities)




#score: {'data2D.txt': -0.07459151234567903}
#island_id: 0
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = np.exp(-2*(priorities[i][0]+J[0,i//N,site_nbr]))
    
  return(priorities)




#score: {'data2D.txt': 0.002591203703703704}
#island_id: 2
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (1 + np.sign(h[site_nbr][i%N]))
  return(priorities)




#score: {'data2D.txt': 0.002591203703703704}
#island_id: 2
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (1 + np.sign(h[site_nbr][i%N]))
  return(priorities)




#score: {'data2D.txt': 0.002591203703703704}
#island_id: 2
#version_generated: 2
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (1 + np.sign(h[site_nbr][i%N]))
  return(priorities)




#score: {'data2D.txt': 0.002591203703703704}
#island_id: 2
#version_generated: 2
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (1 + np.sign(h[site_nbr][i%N]))
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.00456898148148148}
#island_id: 1
#version_generated: 2
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time15:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin from magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priorities based on the total spin
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time15:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    total_spin = sum(J[k,i%N,i//N]*h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11462577160493839}
#island_id: 1
#version_generated: 2
#generate time15:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0008584876543209875}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) * (np.sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)]) > 0)
  return(priorities)




#score: {'data2D.txt': 0.0007572530864197531}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_energy = sum([J[k,i%N,k-1]*np.sign(h[(k+N-1)%N][i%N])*np.sign(h[(k+1)%N][i%N]) for k in range(3)])
    priorities[i][0] = total_spin
    priorities[i][1] = -total_energy * np.exp(-2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0005986111111111104}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priority_ones = total_spin + np.exp(-2*h_site*total_spin)
    priority_minusones = -total_spin + np.exp(2*h_site*total_spin)
    priorities[i] = np.array([priority_ones, priority_minusones])
  return priorities




#score: {'data2D.txt': -0.0003134259259259265}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.tanh(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0014078703703703705}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h_site > 0:
      priorities[i][1] = np.exp(-2*h_site*total_spin)
    else:
      priorities[i][1] = np.exp(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0014078703703703705}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h_site > 0:
      priorities[i][1] = np.exp(-2*h_site*total_spin)
    else:
      priorities[i][1] = np.exp(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0014078703703703705}
#island_id: 2
#version_generated: 2
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([h[site_nbr][(j-1)%N] * J[j, i % N, i // N] for j in range(4)])
    priorities[i][0] = total_spin
    if h_site > 0:
      priorities[i][1] = np.exp(-2*h_site*total_spin)
    else:
      priorities[i][1] = np.exp(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.039885030864197535}
#island_id: 2
#version_generated: 2
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_spin += h[i//N][i%N]
    priorities[i][0] = total_spin
    if J[1,i//N,1] > 0:
      priority_1 = np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
    else:
      priority_1 = -np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
    if J[2,i//N,2] > 0:
      priority_2 = np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
    else:
      priority_2 = -np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
    priorities[i][1] = (np.exp(-2*h_site*total_spin) + np.min([priority_1, priority_2]))
  return(priorities)




#score: {'data2D.txt': -0.0012464506172839506}
#island_id: 2
#version_generated: 2
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(4)])
    h_site = h[i%N][i//N]
    priorities[i][0] = total_spin
    if J[0,i%N,i//N] > 0:
      h_site = h_site
    else:
      h_site = -h_site
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(4)])
  return(priorities)




#score: {'data2D.txt': -0.0014418209876543222}
#island_id: 2
#version_generated: 2
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002305401234567902}
#island_id: 2
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = (1 + np.exp(-2*h_site)) / (1 + np.exp(2*h_site))
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0005029320987654321}
#island_id: 2
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': -0.0005029320987654321}
#island_id: 2
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-2*priorities[i][0])
  return(priorities)




#score: {'data2D.txt': -0.0005029320987654321}
#island_id: 2
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.exp(-priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.010010030864197533}
#island_id: 0
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][k%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    priorities[i][0] += total_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2 - sum(J[k,i//N,i%N] for k in range(3))
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,i%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': -0.0063362654320987645}
#island_id: 0
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][i%N] for k in [0, 1])
    priorities[i][0] += h[site_nbr][i%N] + nn_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= sum([2, 1, -1])  # 2 for the current site and 1 for each neighbor
    else:
      priorities[i][1] += sum([2, 1, -1])
  return(priorities)




#score: {'data2D.txt': -0.03608009259259261}
#island_id: 0
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.02601126543209877}
#island_id: 0
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    if sum(J[:,i//N,site_nbr]) > 0:
      priorities[i][0] = energy_diff
      priorities[i][1] = -energy_diff
    else:
      priorities[i][0] = -energy_diff
      priorities[i][1] = energy_diff
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = 0
    for j in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_j = (j % N + ((j//N-1)%2 - 1)) % N
      energy_diff += sum(J[j%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[j%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.031488425925925934}
#island_id: 3
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] += J[0,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0005856481481481481}
#island_id: 3
#version_generated: 2
#generate time15:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[i//N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_energy = energy_diff * h[site_nbr][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = J[0,i//N,i%N] * h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2
  
  return(priorities)




#score: {'data2D.txt': -0.0013106481481481487}
#island_id: 3
#version_generated: 2
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * J[0,i//N,i%N]
    
    if total_spin > 0:
      priorities[i][0] += 2*total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 2*total_spin
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.04081929012345679}
#island_id: 3
#version_generated: 2
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] += J[0,i//N,i%N]
    
    # Add interaction with the diagonal neighbor
    site_nbr_diagonal = (i % N + ((i//N+N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] += J[1,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.09259861111111112}
#island_id: 0
#version_generated: 2
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.07690231481481481}
#island_id: 0
#version_generated: 2
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0019069444444444442}
#island_id: 0
#version_generated: 2
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy + np.sum(J[:, i//N, :])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004118364197530864}
#island_id: 2
#version_generated: 2
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = h[site_nbr][i%N]
    spin_moment = np.exp(-2*h_site*total_spin)
    if J[0,i%N,i//N] > 0:
      magnetism = -1
    else:
      magnetism = 1
    
    # Calculate the priority using a more complex formula
    priorities[i][0] = total_spin + spin_moment*(2*h_site-1)
    priorities[i][1] = np.abs(J[1,i//N,1]) * (magnetism > 0) + np.abs(J[2,i//N,2]) * (magnetism < 0)
  return(priorities)




#score: {'data2D.txt': -0.0014418209876543222}
#island_id: 2
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = total_spin
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': -0.0014418209876543222}
#island_id: 2
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': -0.00229675925925926}
#island_id: 2
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
    # Add a term to prioritize spins that align with the local magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += -2*h_site
    else:
      priorities[i][1] -= 2*h_site
  return(priorities)




#score: {'data2D.txt': 0.009913117283950617}
#island_id: 0
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,1]:
      if i+k < N*N or i+k >= N*N:
        continue
      total_energy += J[(k+1)//2,i//N,(i+k)%N] * h[(i+k)%N][(i+k)%N]
    priorities[i][0] = total_energy + np.sum(J[:,i//N,i%N])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11853533950617284}
#island_id: 0
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014418209876543222}
#island_id: 2
#version_generated: 2
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = total_spin
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][1] = np.exp(-2*h_site*total_spin) + np.sum([np.abs(J[k,i//N,k]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': 0.0008683641975308642}
#island_id: 2
#version_generated: 2
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = total_spin
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_energy = sum([J[k,i%N,k]*np.sign(h[k][i%N])**2 for k in range(3)])
    priorities[i][1] = np.exp(-2*h_site*total_spin) + total_energy
  return(priorities)




#score: {'data2D.txt': 3.256172839506116e-05}
#island_id: 2
#version_generated: 2
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = total_spin
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_interaction = sum([J[k,i//N,k]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][1] = np.exp(-2*h_site*total_spin) + spin_interaction
  return(priorities)




#score: {'data2D.txt': 0.0010634259259259258}
#island_id: 3
#version_generated: 2
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    total_spin = 0
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[(i+N-1)%N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.06963441358024694}
#island_id: 3
#version_generated: 2
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for j in range(N):
      site_nbr1 = (j + ((i//N-1)%2 - 1)) % N
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[site_nbr][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0008103395061728393}
#island_id: 3
#version_generated: 2
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for j in range(N):
      site_nbr_neighbor = (j + ((i//N-1)%2 - 1)) % N
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[site_nbr][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.000710030864197531}
#island_id: 3
#version_generated: 2
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[(i+N-1)%N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00481496913580247}
#island_id: 2
#version_generated: 2
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus * (np.sum(h) > 0)
    priorities[i][1] = priority_minus * (np.sum(h) < 0)
  return(priorities)




#score: {'data2D.txt': -0.027806944444444447}
#island_id: 2
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = (priority_plus * np.sign(h[i//N][i%N]))
    priorities[i][1] = (priority_minus * np.abs(h[i//N][i%N]))
  return(priorities)




#score: {'data2D.txt': -0.0008421296296296296}
#island_id: 2
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.0008572530864197531}
#island_id: 2
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([J[0,i%N,j]*h[j] for j in range(N) if i//N==j or (i//N+1)%N==j])
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.04293904320987654}
#island_id: 3
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] += J[0,i//N,i%N] * total_spin
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * total_spin
      priorities[i][1] += J[0,i//N,i%N]

    site_nbr_diagonal = (i % N + ((i//N+N-1)%2 - 1)) % N
    total_spin_diagonal = h[site_nbr_diagonal][i%N]
    if total_spin > 0:
      priorities[i][0] += J[1,i//N,i%N] * total_spin_diagonal
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N] * total_spin_diagonal
      priorities[i][1] += J[1,i//N,i%N]

  return(priorities)




#score: {'data2D.txt': -0.32522669753086325}
#island_id: 3
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[0,i//N,i%N]
      priorities[i][1] += 1
    
    # Add interaction with the horizontal and vertical neighbors
    for j in range(2):
      site_nbr_horizontal = (i % N + ((i//N-1)%2 - 1)) % N
      if h[i//N][i%N] > 0:
        priorities[i][0] += J[j+1,i//N,i%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[j+1,i//N,i%N]
        priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.04081929012345679}
#island_id: 3
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_diagonal = (i % N + ((i//N+N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N] * h[site_nbr][i%N] + J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] -= J[0,i//N,i%N] + J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * h[site_nbr][i%N] + J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] += J[0,i//N,i%N] + J[1,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.04081929012345679}
#island_id: 3
#version_generated: 2
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * h[site_nbr][i%N]
      priorities[i][1] += J[0,i//N,i%N]
    
    site_nbr_diagonal = (i % N + ((i//N+N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N] * h[site_nbr_diagonal][i%N]
      priorities[i][1] += J[1,i//N,i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0015118827160493827}
#island_id: 1
#version_generated: 2
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    priorities[i] = [total_spin, -total_spin] if np.mean(h.flatten()) > 0 else [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0005856481481481481}
#island_id: 3
#version_generated: 2
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[i//N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0005856481481481481}
#island_id: 3
#version_generated: 2
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[i//N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 9.182098765432151e-05}
#island_id: 3
#version_generated: 2
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    
    for j in range(N):
      if i*N+j < N:
        total_spin += J[(j+1)%2,i//N,j]%N*h[i//N][j]
      else:
        total_spin -= J[j%2,i//N,(i-N-1)%N]%N*h[i//N][(i-N-1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015183641975308638}
#island_id: 0
#version_generated: 2
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    for d in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
      ni, nj = i // N + d[0], i % N + d[1]
      ni %= N; nj %= N
      if J[d[1], i % N, i // N] > 0:
        energy_nn += h[ni][nj]
      else:
        energy_nn -= h[ni][nj]
    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07344182098765435}
#island_id: 0
#version_generated: 2
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    spin_energy = h[site_nbr][i%N] + energy_nn

    priorities[i][0] = spin_energy
    priorities[i][1] = -spin_energy

  return(priorities)




#score: {'data2D.txt': 0.006232561728395062}
#island_id: 0
#version_generated: 2
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    if h_site == 1:
      priorities[k][0] = (2*J_up + 2*J_down)
      priorities[k][1] = -(2*J_up + 2*J_down)
    else:
      priorities[k][0] = -(2*J_up + 2*J_down)
      priorities[k][1] = 2*J_up + 2*J_down

  return(priorities)




#score: {'data2D.txt': -0.004241203703703704}
#island_id: 0
#version_generated: 2
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    priorities[k][0] = (1/(1+np.exp((J_up - J_down)*h_site)))*2*h_site
    priorities[k][1] = 1-(priorities[k][0])

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N)]
  
  for k in range(N ** 2):
    site_nbr = (k % N + ((k // N - 1) % 2 - 1)) % N
    if h[site_nbr][k % N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    J_up = np.sum([J[i, k % N, k // N] * h_site for i in range(4)])
    J_down = -np.sum([J[i, k % N, k // N] * (-h_site) for i in range(4)])
    
    priorities[k][0] = (J_up - J_down) * h_site
    priorities[k][1] = -priorities[k][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0028449074074074067}
#island_id: 0
#version_generated: 2
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    priorities[k][0] = (J_up - J_down)*h_site
    priorities[k][1] = np.abs(priorities[k][0])

  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.165611265432099}
#island_id: 1
#version_generated: 2
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin1 = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin1 += 1
      else:
        total_spin1 -= 1
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    total_spin2 = h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin2 += 1
      else:
        total_spin2 -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin1 + total_spin2, -total_spin1 - total_spin2]
    else:
      priorities[i] = [-total_spin1 - total_spin2, total_spin1 + total_spin2]
    
  return(priorities)




#score: {'data2D.txt': 0.0008896604938271609}
#island_id: 3
#version_generated: 2
#generate time16:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in [(i-1)%N, (i+1)%N]:
      if i//N == j//N and ((j%N) - (i%N)) % N != N//2:
        total_spin += J[0,i//N,i%N] * h[j//N][j%N]
      elif i//N == j//N and abs((j%N) - (i%N)) == N//2:
        total_spin -= 2*J[1,i//N,i%N] * h[j//N][j%N]
      else:
        if ((j//N)%2) != ((i//N)%2):
          total_spin += J[0,i//N,i%N] * h[j//N][j%N]
        else:
          total_spin -= J[1,i//N,i%N] * h[j//N][j%N]
    
    if total_spin > 0:
      priorities[i][0] += 2*total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 2*total_spin
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.000709104938271605}
#island_id: 3
#version_generated: 2
#generate time16:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * J[0,i//N,i%N]
    
    if total_spin > 0:
      priorities[i][0] += 4*total_spin
      priorities[i][1] -= 3
    else:
      priorities[i][0] -= 4*total_spin
      priorities[i][1] += 3
    
  return(priorities)




#score: {'data2D.txt': 0.000709104938271605}
#island_id: 3
#version_generated: 2
#generate time16:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * J[0,i//N,i%N]
    
    if total_spin > 0:
      priorities[i][0] += 3*total_spin
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 3*total_spin
      priorities[i][1] += 2
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * J[0,i//N,i%N]
    
    if total_spin > 0:
      priorities[i][0] += 3*total_spin
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 3*total_spin
      priorities[i][1] += 2
  
  return(priorities)




#score: {'data2D.txt': -0.00356466049382716}
#island_id: 3
#version_generated: 2
#generate time16:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * J[0,i//N,i%N]
    
    if total_spin > 0:
      priorities[i][0] += 4*total_spin
      priorities[i][1] -= 3
    elif total_spin < 0:
      priorities[i][0] -= 4*total_spin
      priorities[i][1] += 3
    else:
      priorities[i][0] = 2*(h[site_nbr][i%N] > 0) - 1
      priorities[i][1] = 1
  
  return(priorities)




#score: {'data2D.txt': -0.0014606481481481476}
#island_id: 2
#version_generated: 2
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)], axis=0)
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.0006368827160493823}
#island_id: 2
#version_generated: 2
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)], axis=0)
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy) / (1 + np.exp(-spin_energy))
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.0002353395061728399}
#island_id: 2
#version_generated: 2
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[site_nbr][i%N]) for k in range(3)])
    h_site = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)], axis=0)
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy)
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    h_site = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)], axis=0)
    spin_energy = total_spin + h_site
    priority_minus = np.exp(-spin_energy) * (1 - np.sum(np.sign(h[:, i%N]) == 1, axis=0))
    priority_plus = 1 - priority_minus
    priorities[i][0] = priority_plus
    priorities[i][1] = priority_minus
  return(priorities)




#score: {'data2D.txt': 0.0016760802469135809}
#island_id: 3
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.005768981481481483}
#island_id: 3
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(4): 
        if k==0:  
          if i//N==0 or h[(k+N-1)%N][i%N]==0:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
          else:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
        elif k==1: 
          if i%N==0 or h[(k+N-1)%N][i//N]==0:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
          else:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
        elif k==2: 
          if i%N==N-1 or h[(k+N-1)%N][i//N]==0:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
          else:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
        elif k==3: 
          if i//N==N-1 or h[(k+N-1)%N][i%N]==0:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
          else:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(4):
        if k==0:  
          if i//N==0 or h[(k+N-1)%N][i%N]==0:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
          else:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
        elif k==1: 
          if i%N==0 or h[(k+N-1)%N][i//N]==0:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
          else:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
        elif k==2: 
          if i%N==N-1 or h[(k+N-1)%N][i//N]==0:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
          else:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i//N]
        elif k==3: 
          if i//N==N-1 or h[(k+N-1)%N][i%N]==0:
            total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
          else:
            total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.0009106481481481482}
#island_id: 3
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      if k == 0:
        if i % N == 0 or i % N == N-1: 
          total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
        elif (i // N) % 2 == 0:  
          total_spin -= J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
        else:
          total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
      elif k == 1:
        if i % N > 0 and (i // N) % 2 == 0:  
          total_spin -= J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
        elif i % N < N-1 and ((i // N) % 2) != 0: 
          total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
      else:
        if i % N > 0 and (i // N) % 2 == 0:  
          total_spin -= J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
        elif i % N < N-1 and ((i // N) % 2) != 0: 
          total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the priority based on the nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # adjust the priority based on the site magnetism and interaction with its four nearest neighbors
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0003134259259259265}
#island_id: 2
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = np.tanh(2*h_site*total_spin)
  return(priorities)




#score: {'data2D.txt': 11675999038661.518}
#island_id: 2
#version_generated: 2
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_spin *= (1 + np.exp(-2*h_site*total_spin))/2
    priorities[i][0] = total_spin
    priorities[i][1] = 1 - 2*np.arctanh(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.0031294753086419753}
#island_id: 2
#version_generated: 2
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    total_spin += h_site
    priorities[i][0] = total_spin
    priorities[i][1] = np.tanh(2*total_spin)
  return(priorities)




#score: {'data2D.txt': -0.032757561728395064}
#island_id: 3
#version_generated: 2
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N] * (h[site_nbr][i%N] + J[1,i//N,i%N])
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N] * (h[site_nbr][i%N] + J[1,i//N,i%N])
      priorities[i][1] += J[0,i//N,i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.031488425925925934}
#island_id: 3
#version_generated: 2
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      J_val = J[0,i//N,i%N]
      priorities[i][0] += J_val * h[site_nbr][i%N]
      priorities[i][1] -= J_val
    else:
      J_val = J[0,i//N,i%N]
      priorities[i][0] -= J_val * h[site_nbr][i%N]
      priorities[i][1] += J_val
    
  for i in range(N**2):
    for j in range(2):
      priorities[i][j] *= N
      if priorities[i][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09483287037037047}
#island_id: 1
#version_generated: 2
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Nearest neighbors' contribution
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Horizontal and vertical interactions
    site_nbr_h = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_v = (i // N + ((i%N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_h][j]
        total_spin -= h[site_nbr_v][j]
      else:
        total_spin -= h[site_nbr_h][j]
        total_spin += h[site_nbr_v][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16222145061728419}
#island_id: 1
#version_generated: 2
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N//N] > 0:
      priorities[i][0] += h[site_nbr][N//N]
      priorities[i][1] -= h[site_nbr][N//N]
    else:
      priorities[i][0] -= h[site_nbr][N//N]
      priorities[i][1] += h[site_nbr][N//N]
  
  return(priorities)




#score: {'data2D.txt': -0.2646881172839505}
#island_id: 1
#version_generated: 2
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.007111265432098765}
#island_id: 1
#version_generated: 2
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_neighbors = [(i-1)%N, (i+1)%N, ((i+N-1)%N), (i+N)%N]
    for j in site_neighbors:
      if J[3,i%N,j] > 0:
        total_spin += h[j][i%N]
      else:
        total_spin -= h[j][i%N]
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16713966049382742}
#island_id: 1
#version_generated: 2
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(2):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.11655262345679025}
#island_id: 1
#version_generated: 2
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority for each spin assignment
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.sum(J[:,i//N,i//N]) + J[3,i//N,N-1-i%N]
      priorities[i][1] -= np.sum(J[:,i//N,i//N]) - J[3,i//N,N-1-i%N]
    else:
      priorities[i][0] -= np.sum(J[:,i//N,i//N]) + J[3,i//N,N-1-i%N]
      priorities[i][1] += np.sum(J[:,i//N,i//N]) - J[3,i//N,N-1-i%N]
    
    if i % N != 0:
      site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
      site_nbr_down = (i % N + ((i//N+1)%2 - 1)) % N
      
      if h[i//N][i%N] > 0:
        priorities[i][0] += J[3,i//N,N-1-i%N]
        priorities[i][1] -= J[3,i//N,N-1-i%N]
      else:
        priorities[i][0] -= J[3,i//N,N-1-i%N]
        priorities[i][1] += J[3,i//N,N-1-i%N]
    
    if i < N**2 - 1:
      site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
      site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N
      
      if h[i//N][i%N] > 0:
        priorities[i][0] += J[3,i//N,N-1-i%N]
        priorities[i][1] -= J[3,i//N,N-1-i%N]
      else:
        priorities[i][0] -= J[3,i//N,N-1-i%N]
        priorities[i][1] += J[3,i//N,N-1-i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 1
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:, i//N, i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + h[i//N][i%N], -total_spin - h[i//N][i%N]]
    else:
      priorities[i] = [-total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.007101697530864197}
#island_id: 3
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[1,i%N,i//N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.15690077160493832}
#island_id: 3
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      J_site = J[0,i%N,i//N]*h[i//N][i%N]
    else:
      J_site = -J[0,i%N,i//N]*h[i//N][i%N]

    priorities[i][0] = h_site + J_site
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_bias = h[site_nbr][i%N]
      J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      spin_bias = -h[site_nbr][i%N]
      J_bias = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = spin_bias + J_bias
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0016047839506172848}
#island_id: 3
#version_generated: 2
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0007893518518518521}
#island_id: 2
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009418209876543202}
#island_id: 2
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if sum(h[i//N]) + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.07077700617283955}
#island_id: 2
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_energy
      priorities[i][1] = -total_energy
    else:
      priorities[i][0] = -total_energy
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_bias = h[site_nbr][i%N]
      J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = spin_bias + J_bias
    else:
      spin_bias = -h[site_nbr][i%N]
      J_bias = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = spin_bias + J_bias
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0022723765432098764}
#island_id: 3
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    priorities[i][0] = total_spin_bias + J_bias
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_bias = h[site_nbr][i%N]
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Calculate the priority for each possible spin value
    if h[i//N][i%N] > 0:
      priorities[i][0] = spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018050925925925938}
#island_id: 3
#version_generated: 2
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.013336574074074075}
#island_id: 1
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.1671677469135805}
#island_id: 1
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
   site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
   total_spin = h[site_nbr][i%N]
   
   for k in range(4):
    if J[k,i%N,i//N] > 0:
     total_spin += 1
    else:
     total_spin -= 1
   
   priority = [-total_spin, total_spin] if h[i//N][i%N] < 0 else [total_spin, -total_spin]
   
   priorities[i] = [p + J[3,i%N,i//N] for p in priority] if i % N > 0 and (i // N) % 2 == 1 else priority
   priorities[i] = [p + J[2,i//N,i%N] for p in priority] if i % N < N - 1 and (i // N) % 2 == 1 else priority
 
  return(priorities)




#score: {'data2D.txt': 0.1645081790123459}
#island_id: 1
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate priority based on site interactions and magnetism
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%(N-1)+(i//N)%2,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # update priorities based on magnetism and site interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0007893518518518521}
#island_id: 2
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = 2*h_site + 2*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -2*h_site - 2*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0007893518518518521}
#island_id: 2
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0003165123456790115}
#island_id: 2
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0022427469135802456}
#island_id: 2
#version_generated: 2
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0018050925925925938}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018050925925925938}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0017479938271604963}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin_bias = sum([h[(i+N-1)%N][j] for j in range(N)])
    J_bias = sum([J[k,(i%N),i//N]*h[(k+N-1)%N][(i%N)] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018050925925925938}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0014430555555555561}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,(i%N),i//N]*h[site_nbr][(k+1)%3] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0017479938271604963}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin_bias = sum([h[(i+N-1)%N][j] for j in range(N)])
    J_bias = sum([J[k,(i%N),i//N]*h[(k+N-1)%N][(i%N)] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0034649691358024704}
#island_id: 3
#version_generated: 2
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i+N-1)%N, (i+1)%N, (i-N)%N if i-N>=0 else N-1]
    total_spin_bias = sum([h[j][i%N] for j in site_nbrs])
    J_bias = sum([J[k,(i%N),i//N]*h[site_nbrs[k]][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin_bias + J_bias
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin_bias - J_bias
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.010703858024691358}
#island_id: 1
#version_generated: 2
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0021800925925925924}
#island_id: 3
#version_generated: 2
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002104783950617284}
#island_id: 3
#version_generated: 2
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = (total_spin_bias + J_bias - abs(total_spin_bias) / 2)
    priorities[i][1] = -priorities[i][0]
    
    # Improve this by considering the priority of the site's neighbors
    if i % N > 0:
      priorities[i][0] += priorities[(i-1)%N][0]
      priorities[i][1] -= priorities[(i-1)%N][0]
    if i % N < N - 1:
      priorities[i][0] += priorities[(i+1)%N][0]
      priorities[i][1] -= priorities[(i+1)%N][0]
    
  return(priorities)




#score: {'data2D.txt': -0.13281496913580265}
#island_id: 3
#version_generated: 2
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.0021800925925925924}
#island_id: 3
#version_generated: 2
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.linalg.norm(np.array([2*h_site, -np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.linalg.norm(np.array([-2*h_site, -np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0007893518518518521}
#island_id: 2
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = (2*h_site + 2*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])) * N
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = (-2*h_site - 2*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])) * N
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00070108024691358}
#island_id: 2
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = 2*h_site + 2*sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - sum([J[k,i%N,k]*h[site_nbr][k] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -2*h_site - 2*sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum([J[k,i%N,k]*h[site_nbr][k] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.007106635802469136}
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    total_energy = h_site + sum(nn_values)
    priority_total = np.array([total_energy, -total_energy])
    
    priorities[i] = priority_total
    
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419744}
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    if sum(nn_values) > 0:
      priorities[i][0] = h_site + max([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.22370231481481487}
#island_id: 0
#version_generated: 2
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0] - 1
    else:
      priorities[i][1] = priorities[i][0] + 1
  
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.06046682098765432}
#island_id: 0
#version_generated: 2
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0] + sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    else:
      priorities[i][1] = priorities[i][0] - sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.006431635802469135}
#island_id: 0
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[0,i//N,site_nbr] > 0:
      priorities[i][0] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = h[site_nbr][i%N]

    # Add a term to the priority that is proportional to the magnetism at the site
    priorities[i][1] = -priorities[i][0] + nn_energy_sum - 2*h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0532162037037037}
#island_id: 0
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[0,i//N,site_nbr] > 0:
      priorities[i][0] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = h[site_nbr][i%N]

    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[1,i//N,site_nbr] > 0:
      priorities[i][1] = -priorities[i][0] - nn_energy_sum
    else:
      priorities[i][1] = -priorities[i][0] + nn_energy_sum

  return(priorities)




#score: {'data2D.txt': -0.005777006172839506}
#island_id: 0
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[0,i//N,site_nbr] > 0:
      priorities[i][0] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = h[site_nbr][i%N]

    priorities[i][1] = -priorities[i][0] + nn_energy_sum
  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site += h[site_nbr][i%N]
    else:
      h_site -= h[site_nbr][i%N]

    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 3
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site += h[site_nbr][i%N]
    else:
      h_site -= h[site_nbr][i%N]

    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.20301003086419753}
#island_id: 3
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([J[k,i,j]*h[(k+N-1)%N][j] for k in range(3)])
      
      if J[0,i,j] > 0:
        h_site = h[site_nbr][j]
      else:
        h_site = -h[site_nbr][j]

      priorities[i*N+j][0] = total_spin + h_site
      if J[1,i,j] > 0:
        priorities[i*N+j][1] = -priorities[i*N+j][0]
      else:
        priorities[i*N+j][1] = priorities[i*N+j][0]
        
  return(priorities)




#score: {'data2D.txt': -0.007101697530864197}
#island_id: 3
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbrs = [(k+N-1)%N for k in range(3)]
    neighbors = [J[k,i%N,i//N]*h[nb][i%N] for k,nb in zip(range(3),site_nbrs)]
    
    priorities[i][0] = h_site + sum(neighbors)
    if J[1,i%N,i//N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.26114243827160466}
#island_id: 2
#version_generated: 2
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([abs(J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k])) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([abs(J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k])) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.004378240740740741}
#island_id: 2
#version_generated: 2
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i%N]*h[site][i%N]
      else:
        total_spin += J[k-2,i//N,i%N]*(h[(k+N-3)%4][i%N] + h[site_nbr][i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0010584876543209875}
#island_id: 2
#version_generated: 2
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if sum(J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)) > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)]) 
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009572530864197537}
#island_id: 2
#version_generated: 2
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = 2*h_site + sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -2*h_site - sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]+h[site_nbr][k]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012470679012345682}
#island_id: 3
#version_generated: 2
#generate time16:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    # Calculate the number of aligned neighbors and penalize it
    aligned_neighbors = sum([1 if h[(i+N-1)%N][j] == h[i//N][j] else -1 for j in range(N)])
    priorities[i][0] -= abs(aligned_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.08502206790123464}
#island_id: 3
#version_generated: 2
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    if h[i//N][i%N] > 0:
      # Favor alignment of neighboring sites' spins with site's own spin
      for j in range(N):
        if i >= N and i % N == j: continue
        if h[(i+N-1)%N][j] > 0:
          priorities[i][1] -= 1
        else:
          priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.004378240740740741}
#island_id: 2
#version_generated: 2
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i%N]*h[site][i%N]
      else:
        total_spin += J[k-2,i//N,i%N]*(h[(k+N-3)%4][i%N] + h[site_nbr][i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.33205570987654226}
#island_id: 2
#version_generated: 2
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i%N]*h[site][i%N]
      else:
        total_spin += J[k-2,i//N,i%N]*(h[(k+N-3)%4][i%N] + h[site_nbr][i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum(np.abs(J[:,i//N,i%N]*h[:(k+1),i%N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum(np.abs(J[:,i//N,i%N]*h[:(k+1),i%N]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.004378240740740741}
#island_id: 2
#version_generated: 2
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k - 1) % 2 - 1)) % N
        total_spin += J[k, i // N, i % N] * h[site][i % N]
      else:
        total_spin += J[k - 2, i // N, i % N] * (h[(k + N - 3) % 4][i % N] + h[site_nbr][i % N])
    if h[i // N][i % N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return (priorities)




#score: {'data2D.txt': 0.004152623456790124}
#island_id: 2
#version_generated: 2
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i%N]*h[site][i%N]
      else:
        site = (site_nbr + ((k-3)%2 - 1)) % N
        total_spin += J[k-2,i//N,i%N]*(h[(k+N-4)%4][i%N] + h[site][i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 2
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      J_up = J[0, i // N, i % N]
      J_down = J[1, i // N, i % N]
      J_left = J[2, i // N, i % N]
      J_right = J[3, i // N, i % N]
      priorities[i][0] = 2 * (J_up + J_down + J_left + J_right)
      priorities[i][1] = -priorities[i][0]
    else:
      J_up = -J[0, i // N, i % N]
      J_down = -J[1, i // N, i % N]
      J_left = -J[2, i // N, i % N]
      J_right = -J[3, i // N, i % N]
      priorities[i][0] = 2 * (J_up + J_down + J_left + J_right)
      priorities[i][1] = -priorities[i][0]
  return (priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k - 1) % 2 - 1)) % N
        total_spin_up += J[k, i // N, i % N] * h[site][i % N]
        total_spin_down += J[k, i // N, i % N] * (-h[site][i % N])
      else:
        total_spin_up += J[k - 2, i // N, i % N] * (h[(k + N - 3) % 4][i % N] + h[site_nbr][i % N])
        total_spin_down += J[k - 2, i // N, i % N] * (-h[(k + N - 3) % 4][i % N] - h[site_nbr][i % N])
    if h[i // N][i % N] > 0:
      priorities[i][0] = total_spin_up
      priorities[i][1] = -total_spin_down
    else:
      priorities[i][0] = -total_spin_up
      priorities[i][1] = total_spin_down
  return (priorities)




#score: {'data2D.txt': 0.004378240740740741}
#island_id: 2
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k - 1) % 2 - 1)) % N
        total_spin += J[k, i // N, i % N] * h[site][i % N]
      else:
        total_spin += J[k - 2, i // N, i % N] * (h[(k + N - 3) % 4][i % N] + h[site_nbr][i % N])
    if h[i // N][i % N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return (priorities)




#score: {'data2D.txt': -0.13704058641975325}
#island_id: 2
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    
    for k in range(4):
      if k < 2:
        site = (site_nbr + ((k - 1) % 2 - 1)) % N
        total_spin_up += J[k, i // N, i % N] * h[site][i % N]
        total_spin_down -= J[k, i // N, i % N] * h[site][i % N]
      else:
        total_spin_up += J[k - 2, i // N, i % N] * (h[(k + N - 3) % 4][i % N] + h[site_nbr][i % N])
        total_spin_down -= J[k - 2, i // N, i % N] * (h[(k + N - 3) % 4][i % N] + h[site_nbr][i % N])
    
    if h[i // N][i % N] > 0:
      priorities[i][0] = total_spin_up
      priorities[i][1] = -total_spin_down
    else:
      priorities[i][0] = -total_spin_up
      priorities[i][1] = -total_spin_down
  
  return (priorities)




#score: {'data2D.txt': 0.0007115740740740732}
#island_id: 0
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0007115740740740732}
#island_id: 0
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.29639768518518456}
#island_id: 0
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      if h[site_nbr][i%N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      if h[site_nbr][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0004945987654320991}
#island_id: 3
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0016047839506172848}
#island_id: 3
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if priorities[i][0] > priorities[i][1]:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    elif priorities[i][1] > priorities[i][0]:
      priorities[i] = [-priorities[i][1], priorities[i][1]]

  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 3
#version_generated: 2
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(3):
      total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(total_spin)
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 4.552469135802495e-05}
#island_id: 3
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4))
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16510231481481505}
#island_id: 1
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_left = (i - 1) % N**2
    site_right = (i + 1) % N**2
    site_up = i-N if i >= N else None
    site_down = i+N if i < N**2 - N else None
    
    if J[0,i%N,i//N] > 0:
      total_spin += h[i//N][i%N]
    elif J[0,i%N,i//N] < 0:
      total_spin -= h[i//N][i%N]
    
    if site_left and J[1,i//N,i//N] > 0:
      total_spin += h[i//N][i%N]
    elif site_left and J[1,i//N,i//N] < 0:
      total_spin -= h[i//N][i%N]
    
    if site_right and J[2,i//N,i//N] > 0:
      total_spin += h[i//N][i%N]
    elif site_right and J[2,i//N,i//N] < 0:
      total_spin -= h[i//N][i%N]
    
    if site_up and J[3,i%N,(i//N) % N] > 0:
      total_spin += h[(i//N) % N][(i)%N]
    elif site_up and J[3,i%N,(i//N) % N] < 0:
      total_spin -= h[(i//N) % N][(i)%N]
    
    if site_down and J[3,(i+N-1)//N,(i+1)%N] > 0:
      total_spin += h[(i+N-1)//N][(i+1)%N]
    elif site_down and J[3,(i+N-1)//N,(i+1)%N] < 0:
      total_spin -= h[(i+N-1)//N][(i+1)%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.004523919753086419}
#island_id: 1
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0, i%N, i//N]
    
    if i % N != 0:
      total_spin += J[1, i%N, i//N] * (h[(site_nbr1-1)%N][i%N] - h[site_nbr1][i%N])
      
    if i // N != 0:
      total_spin += J[2, i%N, i//N] * (h[site_nbr1][i%N] - h[(site_nbr1-1)%N][i%N])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.15832330246913603}
#island_id: 1
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.015251697530864198}
#island_id: 0
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,(i)%N] * h[site_nbr][(i)%N] for k in range(3))
    priorities[i][0] += nn_energy + h[site_nbr][(i)%N]
    if h[site_nbr][(i)%N] > 0:
      priorities[i][1] -= 2 - sum(J[k,i//N,(i)%N] for k in range(3)) - 1
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,(i)%N] for k in range(3)) + 1
  return(priorities)




#score: {'data2D.txt': -0.006235030864197531}
#island_id: 0
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][k%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    priorities[i][0] += total_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= sum(J[k,i//N,i%N] for k in range(3))
    else:
      priorities[i][1] += sum(J[k,i//N,i%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': -0.031422067901234564}
#island_id: 0
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[site_nbr][k%N] if h[i//N][i%N] > 0 else -h[site_nbr][k%N]) for k in range(3))
    total_energy = nn_energy + (2*h[i//N][i%N] if h[i//N][i%N] > 0 else -2*h[i//N][i%N])
    priorities[i][0] += total_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2 + sum(J[k,i//N,i%N] for k in range(3))
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,i%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': -0.027738117283950616}
#island_id: 0
#version_generated: 2
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,(i%N+N)%N] * h[site_nbr][(i%N+N)%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    priorities[i][0] += total_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2 - sum(J[k,i//N,(i%N+N)%N] for k in range(3))
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,(i%N+N)%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': 0.0013516975308641972}
#island_id: 0
#version_generated: 2
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy + np.sum(J[:, i//N, :]) - min(1.0, -np.sum(J[:, i//N, :]))
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0033192901234567903}
#island_id: 0
#version_generated: 2
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = np.sum(J[:, i//N, :]) + (priorities[i][0] > 0) * 2
  return(priorities)




#score: {'data2D.txt': 0.0019069444444444442}
#island_id: 0
#version_generated: 2
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy + np.sum(J[:, i//N, :])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014461419753086413}
#island_id: 2
#version_generated: 2
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + max(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - min(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00047422839506172827}
#island_id: 2
#version_generated: 2
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)]) > 0:
      priorities[i][0] = np.sum(np.abs(J[:])) * (sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)]) - sum([J[k,i%N,(i//N+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum(np.abs(J[:])) * (sum([J[k,i%N,(i//N+N-1)%N]*h[site_nbr][k] for k in range(3)]) + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      h_site += h[site_nbr][i%N]
    else:
      h_site -= h[site_nbr][i%N]

    priorities[i][1] = -h_site
    
  return(priorities)




#score: {'data2D.txt': 0.0034995370370370375}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0,0]
      
      for k in range(3):
        if J[k][i%N,i//N] > 0:
          total_spin[0] += h[site_nbr][k]
          total_spin[1] -= 1
        else:
          total_spin[0] -= h[site_nbr][k]
          total_spin[1] += 1
      
      priorities[i*N+j][0] = total_spin[0]
      priorities[i*N+j][1] = -total_spin[0]
      
  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site += h[site_nbr][i%N]
    else:
      h_site -= h[site_nbr][i%N]

    priorities[i][0] = h_site
    priorities[i][1] = -h_site
  return(priorities)




#score: {'data2D.txt': 0.07307361111111114}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      h_site = sum([J[k,i%N,j]*h[site_nbr][k] for k in range(3)])
      if J[0,i%N,j] > 0:
        h_site += h[i][j]
      else:
        h_site -= h[i][j]

      priorities[i*N+j][0] = h_site
      priorities[i*N+j][1] = -priorities[i*N+j][0]
  return(priorities)




#score: {'data2D.txt': 0.04187391975308643}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    # Calculate the local field at each site based on the interactions with its neighbors
    local_field = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
    
    # Update the priority for assigning spins based on the local field and total spin bias
    if h[i//N][i%N] > 0:
      priorities[i][1] = -local_field + abs(local_field) / 2
    else:
      priorities[i][1] = local_field - abs(local_field) / 2

  return(priorities)




#score: {'data2D.txt': 0.062388425925925965}
#island_id: 3
#version_generated: 2
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    if h[i//N][i%N] > 0:
      # Favor alignment of neighboring sites' spins with site's own spin
      for j in range(N):
        if i >= N and i % N == j: continue
        if h[(i+N-1)%N][j] > 0:
          priorities[i][1] -= 1
        else:
          priorities[i][1] += 1
    
    # Add a term that favors spins aligning with the magnetism
    priorities[i][0] += sum([abs(h[k][i%N]) for k in range(N)])

  return(priorities)




#score: {'data2D.txt': 0.0916785493827161}
#island_id: 3
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = 2 * total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    if h[i//N][i%N] > 0:
      # Favor alignment of neighboring sites' spins with site's own spin
      for j in range(N):
        if i >= N and i % N == j: continue
        if h[(i+N-1)%N][j] > 0:
          priorities[i][1] -= 2
        else:
          priorities[i][1] += 2

  return(priorities)




#score: {'data2D.txt': 0.06880262345679017}
#island_id: 3
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_bias = sum([h[site_nbr][j] for j in range(N)])
    
    # Calculate the total spin of neighboring sites that have not been assigned yet
    unassigned_neighbors = [k for k in range(N) if i >= N*k and (i+k)%N != site_nbr]
    neighbor_spin_bias = sum([h[(i+N-1)%N][j] for j in unassigned_neighbors])
    
    J_bias = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add a term that favors spins aligning with the total spin bias
    priorities[i][0] = total_spin_bias + J_bias - abs(total_spin_bias) / 2
    
    if h[i//N][i%N] > 0:
      # Favor alignment of neighboring sites' spins with site's own spin
      for j in range(N):
        if i >= N and i % N == j: continue
        if h[(i+N-1)%N][j] > 0:
          priorities[i][1] -= 1
        else:
          priorities[i][1] += 1
    
    # Add a term that favors spins aligning with the spin of unassigned neighboring sites
    priorities[i][0] += neighbor_spin_bias
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += max(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] -= min(-sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
    else:
      priorities[i][0] -= min(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] += max(-sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0)
  return(priorities)




#score: {'data2D.txt': 0.27551064814814774}
#island_id: 2
#version_generated: 2
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0010961419753086421}
#island_id: 2
#version_generated: 2
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + max(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0) - min(sum([J[k,i%N,i//N]*h[(k-N+1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - min(sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]), 0) + max(sum([J[k,i%N,i//N]*h[(k-N+1)%N][i%N] for k in range(3)]), 0)
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3029174382716043}
#island_id: 2
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.26687484567901204}
#island_id: 2
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) + sum([J[2, i%N, i//N]*h[site_nbr][2]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) - sum([J[2, i%N, i//N]*h[site_nbr][2]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.2353257716049382}
#island_id: 2
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = abs(total_spin) + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -abs(total_spin) - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14259675925925944}
#island_id: 0
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002239043209876543}
#island_id: 2
#version_generated: 2
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = site_energy + sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -site_energy - sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002239043209876543}
#island_id: 2
#version_generated: 2
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0022427469135802456}
#island_id: 2
#version_generated: 2
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - sum([J[0,i%N,j]*h[site_nbr][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = abs(total_spin) + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) + np.sum(abs(h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -abs(total_spin) - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) + np.sum(abs(h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.2353257716049382}
#island_id: 2
#version_generated: 2
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = abs(total_spin) + sum([(2*h[(k+N-1)%N][i%N]-1)*abs(J[k,i%N,i//N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -abs(total_spin) - sum([(2*h[(k+N-1)%N][i%N]-1)*abs(J[k,i%N,i//N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = abs(total_spin) + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) + np.sum(np.abs(h - h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -abs(total_spin) - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) + np.sum(np.abs(h - h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = abs(total_spin) + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) - np.sum(np.abs(h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -abs(total_spin) - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(3)]) - np.sum(np.abs(h[site_nbr]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3029174382716043}
#island_id: 2
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    neighbor_sum = sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - neighbor_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3029174382716043}
#island_id: 2
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3062060185185178}
#island_id: 2
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) - sum([abs(J[3,k,i//N])*h[k][i%N]*h[k][i//N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) + sum([abs(J[3,k,i//N])*h[k][i%N]*h[k][i//N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) - (N-1)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) + (N-1)
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 1
#version_generated: 2
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = -total_spin**2
    priorities[i][1] = total_spin**2
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
   site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
   total_spin = h[site_nbr][i%N]
   
   for k in range(4):
    if J[k,i%N,i//N] > 0:
     total_spin += 1
    else:
     total_spin -= 1
 
   for j in range(N):
    site_nbr = (i % N + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
   
   if h[i//N][i%N] > 0:
    priorities[i] = [total_spin, -total_spin]
   else:
    priorities[i] = [-total_spin, total_spin]
 
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) + np.sum(np.abs(h))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([abs(J[k,i%N,i//N])*(2*h[(k+N-1)%N][i%N]-1) for k in range(4)]) + np.sum(np.abs(h))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions along the same row and column
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total spin considering nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the magnetism at the current site
    site_magnetism = h[i//N][i%N]
    
    # Assign priorities based on the total spin and magnetism
    if site_magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nn_sites.append(J[j,i//N,nn_site])

    if sum(nn_sites) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for n in nn_sites])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for n in nn_sites])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.011584413580246913}
#island_id: 0
#version_generated: 2
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,nn_site]
    h_site = h[site_nbr][i%N] if sum(J[:,i//N,i%N]) > 0 else -h[site_nbr][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14259675925925944}
#island_id: 0
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.04170663580246915}
#island_id: 0
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      total_energy = sum(J[k,i//N,(site_nbr+(k-1)%2-N)%N] if J[k,i//N,(site_nbr+(k-1)%2-N)%N]>0 else -J[k,i//N,(site_nbr+(k-1)%2-N)%N] for k in range(4)) * h[site_nbr][i%N]
      priorities[i][1] += total_energy
  return(priorities)




#score: {'data2D.txt': 0.14259675925925944}
#island_id: 0
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.09131712962962962}
#island_id: 0
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
    for j in range(4):
        if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0:
            priorities[i][1] -= 1
        else:
            priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 3
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = total_spin + h_site
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.009927006172839793}
#island_id: 3
#version_generated: 2
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        
        if J[k,i,j] > 0:
          total_spin += h[site][j]
        else:
          total_spin -= h[site][j]
      
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -priorities[i*N+j][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0035387345679012356}
#island_id: 0
#version_generated: 2
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbrs = list(set(site_nbrs))
    h_neighbors = [h[site][i%N] for site in site_nbrs]
    if sum(h_neighbors) > 0:
      priorities[i][0] = np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)])
      priorities[i][1] = -(np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)]))
    else:
      priorities[i][0] = np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)])
      priorities[i][1] = -(np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)]))
  return(priorities)




#score: {'data2D.txt': 0.0035387345679012356}
#island_id: 0
#version_generated: 2
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbrs = list(set(site_nbrs))
    
    # Calculate the total magnetism at each site
    total_spin = np.sum([h[site][i%N] for site in site_nbrs])
    
    if total_spin > 0:
      priorities[i][0] = np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)])
      priorities[i][1] = -(np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)]))
    else:
      priorities[i][0] = np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)])
      priorities[i][1] = -(np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)]))
  
  return(priorities)




#score: {'data2D.txt': 0.0035387345679012356}
#island_id: 0
#version_generated: 2
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbrs = list(set(site_nbrs))
    h_neighbors = [h[site][i%N] for site in site_nbrs]
    if sum(h_neighbors) > 0:
      priorities[i][0] = np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)])
      priorities[i][1] = -(np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)]))
    else:
      priorities[i][0] = np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)])
      priorities[i][1] = -(np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)]))
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N)]
  
  for k in range(N ** 2):
    site_nbr = (k % N + ((k // N - 1) % 2 - 1)) % N
    if h[site_nbr][k % N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    J_up = np.sum([J[i, k % N, k // N] * h_site for i in range(4)])
    J_down = -np.sum([J[i, k % N, k // N] * (-h_site) for i in range(4)])
    
    if J_up > 0:
      priorities[k][1] -= 1
    elif J_down > 0:
      priorities[k][0] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.0021424382716049377}
#island_id: 0
#version_generated: 2
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N)]
  
  for k in range(N ** 2):
    site_nbr = (k % N + ((k // N - 1) % 2 - 1)) % N
    if h[site_nbr][k % N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    J_up = np.sum([J[i, k % N, k // N] * h_site for i in range(4)])
    J_down = -np.sum([J[i, k % N, k // N] * (-h_site) for i in range(4)])
    
    priorities[k][0] = (2 * J_up - 3 * J_down)
    priorities[k][1] = -priorities[k][0]
  
  return(priorities)




#score: {'data2D.txt': -0.002411882716049382}
#island_id: 0
#version_generated: 2
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N)]
  
  for k in range(N ** 2):
    site_nbr = (k % N + ((k // N - 1) % 2 - 1)) % N
    if h[site_nbr][k % N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    J_up = np.sum([J[i, k % N, k // N] * h_site for i in range(4)])
    J_down = -np.sum([J[i, k % N, k // N] * (-h_site) for i in range(4)])
    
    priorities[k][0] = (J_up - J_down) * h_site + np.sum(J[:, k % N, k // N]) * h_site
    priorities[k][1] = -priorities[k][0]
  
  return(priorities)




#score: {'data2D.txt': -0.00032391975308641987}
#island_id: 3
#version_generated: 2
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(h[i//N]) > 0:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.000546141975308642}
#island_id: 3
#version_generated: 2
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007408950617283958}
#island_id: 3
#version_generated: 2
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009816203703703704}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0] - 4 * J[0,i//N,max(0, i%N-1):min(N, i%N+2)].sum()
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0] + 4 * J[0,i//N,max(0, i%N-1):min(N, i%N+2)].sum()

  return(priorities)




#score: {'data2D.txt': -0.03319706790123457}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0] - np.sum(J[:, i//N, :][:, i%N], axis=None)
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0] + np.sum(J[:, i//N, :][:, i%N], axis=None)

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0013705246913580254}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    for j in range(max(0, i%N-1), min(N, i%N+2)):
      for k in range(max(0, (i//N-1)%N), min(N, (i//N+1))):
        total_spin += J[0,j,k] * h[j][k]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00041250000000000076}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if J[0,i%N,i//N] > 0:
      total_spin += neighbor_sum
    else:
      total_spin -= neighbor_sum
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - J[1,i//N,i%N]
      priorities[i][1] = -priorities[i][0] - 2*J[1,i//N,i%N]
    else:
      priorities[i][0] = -total_spin + J[1,i//N,i%N]
      priorities[i][1] = -priorities[i][0] + 2*J[1,i//N,i%N]

  return(priorities)




#score: {'data2D.txt': 0.0007408950617283958}
#island_id: 3
#version_generated: 2
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.007209104938271605}
#island_id: 2
#version_generated: 2
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % N == 0: # top edge
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif i % N == N-1: # bottom edge
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif i < N: # left edge
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif i >= N*N-N: # right edge
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0005174382716049376}
#island_id: 1
#version_generated: 2
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    for j in range(N):
      if J[3, i%N, j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.11669089506172853}
#island_id: 1
#version_generated: 2
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin_row = h[site_nbr_row][i % N]
    total_spin_col = h[i // N][site_nbr_col]

    if J[0, i % N, i // N] > 0:
      total_spin_row += 1
    else:
      total_spin_row -= 1

    if J[1, i % N, i // N] > 0:
      total_spin_col += 1
    else:
      total_spin_col -= 1

    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin_row + total_spin_col, -total_spin_row - total_spin_col]
    else:
     priorities[i] = [-total_spin_row - total_spin_col, total_spin_row + total_spin_col]

  return(priorities)




#score: {'data2D.txt': -0.041557253086419776}
#island_id: 3
#version_generated: 2
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.023744598765432102}
#island_id: 3
#version_generated: 2
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N] 
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin - np.sum(J[:, i//N, :][:, i%N], axis=None)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin + np.sum(J[:, i//N, :][:, i%N], axis=None)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.03319706790123457}
#island_id: 3
#version_generated: 2
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0] - np.sum(J[:, i//N, :][:, i%N], axis=None)
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0] + np.sum(J[:, i//N, :][:, i%N], axis=None)

  return(priorities)




#score: {'data2D.txt': 0.023744598765432102}
#island_id: 3
#version_generated: 2
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N][max(0, i%N-1):min(N, i%N+2)], axis=None) + h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin - np.sum(J[:, i//N, :][:, i%N], axis=None)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin + np.sum(J[:, i//N, :][:, i%N], axis=None)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009849845679012348}
#island_id: 1
#version_generated: 2
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    priorities[i] = np.array(priority_total)
  return(priorities)




#score: {'data2D.txt': 0.16746867283950645}
#island_id: 1
#version_generated: 2
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = ((i-1) % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr1][i%N]
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      total_spin -= h[site_nbr1][i%N]
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      total_spin += h[i//N,site_nbr2]
      priorities[i][0] += h[i//N,site_nbr2]
      priorities[i][1] -= h[i//N,site_nbr2]
    else:
      total_spin -= h[i//N,site_nbr2]
      priorities[i][0] -= h[i//N,site_nbr2]
      priorities[i][1] += h[i//N,site_nbr2]
    
    if J[2,i%N,(i+N-1)%N] > 0:
      total_spin += h[site_nbr3][i%N]
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      total_spin -= h[site_nbr3][i%N]
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]
    
    if J[3,i%N,(i+N-1)%N//N] > 0:
      total_spin += h[site_nbr4][i%N]
      priorities[i][0] += h[site_nbr4][i%N]
      priorities[i][1] -= h[site_nbr4][i%N]
    else:
      total_spin -= h[site_nbr4][i%N]
      priorities[i][0] -= h[site_nbr4][i%N]
      priorities[i][1] += h[site_nbr4][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1654609567901237}
#island_id: 1
#version_generated: 2
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.00032391975308641987}
#island_id: 3
#version_generated: 2
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(h[i//N]) > 0:
      priorities[i][0] = (total_h_site + total_J) * 2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_h_site + total_J)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0006128086419753086}
#island_id: 3
#version_generated: 2
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00042793209876543204}
#island_id: 3
#version_generated: 2
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(h[i//N]) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00032391975308641987}
#island_id: 3
#version_generated: 2
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    if sum(h[i//N]) > 0:
      priorities[i][0] = total_h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0021115740740740743}
#island_id: 0
#version_generated: 2
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] += np.sum(J[:,i//N,site])
       priorities[i][1] -= 2*np.sum(J[:,i//N,site])
     else:
       priorities[i][0] -= np.sum(J[:,i//N,site])
       priorities[i][1] += 2*np.sum(J[:,i//N,site])

  return(priorities)




#score: {'data2D.txt': -0.005180401234567901}
#island_id: 0
#version_generated: 2
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * np.sum(J[:,i//N,i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  # Add interaction with next nearest neighbors
  for k in range(4):
    for j in range(N**2):
      site = (j % N + ((j//N-1)%2 - 1)) % N
      if h[site][j%N] > 0:
        priorities[j][0] += np.sum(J[:,j//N,site])
        priorities[j][1] -= 2*np.sum(J[:,j//N,site])
      else:
        priorities[j][0] -= np.sum(J[:,j//N,site])
        priorities[j][1] += 2*np.sum(J[:,j//N,site])

  return(priorities)




#score: {'data2D.txt': -0.002082561728395062}
#island_id: 0
#version_generated: 2
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

    # Add interaction with next nearest neighbors
    for k in range(4):
     site = (i % N + ((k-1)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] += np.sum(J[:,i//N,site])
       priorities[i][1] -= 2*np.sum(J[:,i//N,site])
     else:
       priorities[i][0] -= np.sum(J[:,i//N,site])
       priorities[i][1] += 2*np.sum(J[:,i//N,site])

  # Add interaction with next nearest neighbors in the other direction
  for k in range(4):
    site = (i % N + ((k+1)%2 - 1)) % N
    if h[site][i%N] > 0:
      priorities[i][0] += np.sum(J[:,i//N,site])
      priorities[i][1] -= 2*np.sum(J[:,i//N,site])
    else:
      priorities[i][0] -= np.sum(J[:,i//N,site])
      priorities[i][1] += 2*np.sum(J[:,i//N,site])

  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time16:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total magnetism and interaction energy
    total_spin = h[site_nbr][i%N]
    
    interaction_energy = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        interaction_energy += 1
      else:
        interaction_energy -= 1
    
    # Assign priorities based on total magnetism and interaction energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_energy, -total_spin - interaction_energy]
    else:
      priorities[i] = [-total_spin - interaction_energy, total_spin + interaction_energy]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    for j in range(2):
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.1638436728395064}
#island_id: 3
#version_generated: 2
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy_diff = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff = sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
      site_energy_diff += energy_diff
    priorities[i][0] = total_energy + site_energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.09998842592592604}
#island_id: 0
#version_generated: 2
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.03608009259259261}
#island_id: 0
#version_generated: 2
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 2.1141975308641703e-05}
#island_id: 2
#version_generated: 2
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for k in range(3):
      if i % N == 0: # top edge
        total_spin += J[k,i//N,0]*h[(k+N-1)%N][0]
      elif i % N == N-1: # bottom edge
        total_spin += J[k,i//N,N-1]*h[(k+N-1)%N][N-1]
      elif k==1 and i < N: # left edge
        total_spin += J[1,0,i//N]*h[0,i%N]
      elif k==2 and i >= N*N-N: # right edge
        total_spin += J[2,N-1,i//N]*h[N-1,i%N]
      else:
        if J[k,i//N,(i+1)%N] > 0:
          total_spin += J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]
        else:
          total_spin -= J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
    return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
        
  return(priorities)




#score: {'data2D.txt': 0.0003405864197530861}
#island_id: 3
#version_generated: 2
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - (np.max(J[:,i//N,i//N]) + np.min(J[:,i//N,i//N]))*total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + (np.max(J[:,i//N,i//N]) + np.min(J[:,i//N,i//N]))*total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004605092592592592}
#island_id: 3
#version_generated: 2
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = max(-priorities[i][0], J[0,i//N,i%N]*(h[site_nbr][i%N]-np.sum(h)/N))
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = min(priorities[i][0], -J[0,i//N,i%N]*(h[site_nbr][i%N]-np.sum(h)/N))

  return(priorities)




#score: {'data2D.txt': 0.0006128086419753086}
#island_id: 3
#version_generated: 2
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 7.299382716049385e-05}
#island_id: 3
#version_generated: 2
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = h[site_nbr][i%N]
    total_J = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]

    # Add a term that depends on the local magnetization
    for j in range(N):
      if i % N == 0 or i % N == N-1:
        if (i//N) % 2 == 0: 
          total_J += J[3,(i+N-1)%N,i//N] * h[(i+N-1)%N][i//N]
        else:
          total_J -= J[2,i//N,(i+N-1)%N] * h[(i+N-1)%N][i//N]
      elif (i % N) in [0, N-1]:
        if i // N < N // 2: 
          total_J += J[3,(i+N-1)%N,i//N] * h[(i+N-1)%N][i//N]
        else:
          total_J -= J[2,i//N,(i+N-1)%N] * h[(i+N-1)%N][i//N]

    if np.sum(h) > 0:
      priorities[i][0] = -total_h_site - total_J
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_h_site + total_J
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012427469135802478}
#island_id: 1
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    if J[1,i%N,i//N] > 0:
      total_spin += h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr2][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -1.1574074074073514e-05}
#island_id: 1
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin considering all interactions
    total_spin = sum(J[k,i%N,i//N] * h[site_nbr][k] for k in range(4))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin *= (h[i//N][i%N] > 0) - 1.5
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16600200617283975}
#island_id: 1
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr_row][i%N]
      total_spin -= h[site_nbr_col][i//N]
    else:
      total_spin -= h[site_nbr_row][i%N]
      total_spin += h[site_nbr_col][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.007619907407407409}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    site_nbr2 = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr2][i%N] > 0:
      priority_total[0] += 1
      priority_total[1] -= 1
    else:
      priority_total[0] -= 1
    
    for j in range(N):
      site_nbr3 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': 0.1160470679012347}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i % N + ((i//N)%2 - 1)) % N
    
    total_spin_row = h[site_nbr_row][i%N]
    total_spin_col = h[i//N][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin_row += 1
    else:
      total_spin_row -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin_col += 1
    else:
      total_spin_col -= 1
    
    priorities[i][0] = (total_spin_row + total_spin_col) * h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.16593132716049408}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priority_total[0], -priority_total[0]]
    else:
      priorities[i] = [-priority_total[0], priority_total[0]]
  
  return(priorities)




#score: {'data2D.txt': 0.16685509259259282}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_x = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_y = (i // N + ((i % N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr_x][i%N]
      total_spin -= h[site_nbr_y][i//N]
    else:
      total_spin -= h[site_nbr_x][i%N]
      total_spin += h[site_nbr_y][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1651350308641978}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i, j) for j in range(N) if (i + ((j-1)%2 - 1)) % N == i]
    
    for k, j in site_nbrs:
      if J[3,k,j] > 0:
        total_spin += h[k][j]
      else:
        total_spin -= h[k][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16018009259259275}
#island_id: 1
#version_generated: 2
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions from left and right
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if J[1,i%N,(i+1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate interactions from top and bottom
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    
    # Calculate interactions from diagonal
    if J[3,i%N,(i+1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.03668317901234569}
#island_id: 3
#version_generated: 2
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = np.sum(J[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if J[0,i%N,i//N] > 0:
      total_spin += neighbor_sum
    else:
      total_spin -= neighbor_sum
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013748456790123465}
#island_id: 3
#version_generated: 2
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][i%N]
        priorities[i][1] -= h[site_nbr_row][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row][i%N]
        priorities[i][1] += h[site_nbr_row][i%N]
    
    for j in range(N):
      site_nbr_col = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr_col][j]
        priorities[i][1] -= h[site_nbr_col][j]
      else:
        priorities[i][0] -= h[site_nbr_col][j]
        priorities[i][1] += h[site_nbr_col][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.24294151234567898}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if J[1,i//N,i%N] > 0 and i%2 == 0:
      total_spin += 1
    elif J[1,i//N,i%N] < 0 and i%2 == 1:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0 and i%2 == 0:
      total_spin += 1
    elif J[2,i//N,i%N] < 0 and i%2 == 1:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0014427469135802472}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction terms
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Apply magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Reorder spins based on priority
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0007248456790123452}
#island_id: 0
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - i%N) <= 1:
        nns.append(J[j,i//N,nn_site//N] * h[nn_site][i%N])
      else:
        nns.append(0)

    if sum(nns) > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site
    elif sum(nns) < 0:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site
    else:
      if np.random.rand() > 0.5:
        priorities[i][0] = h_site
        priorities[i][1] = -h_site
      else:
        priorities[i][0] = -h_site
        priorities[i][1] = h_site
  return(priorities)




#score: {'data2D.txt': -0.0007742283950617288}
#island_id: 0
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0032337962962962967}
#island_id: 0
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h[i//N][i%N] + sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[i//N][i%N] - sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.007209104938271605}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % N == 0: # top edge
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif i % N == N-1: # bottom edge
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif i < N: # left edge
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif i >= N*N-N: # right edge
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.033330401234567916}
#island_id: 3
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = -(priorities[i][0] + np.sum(J[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2), :], axis=None))
    else:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -(priorities[i][0] - np.sum(J[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2), :], axis=None))
  return(priorities)




#score: {'data2D.txt': -0.03248966049382717}
#island_id: 3
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = -total_spin
      total_neighbors = np.sum(J[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)].flatten(), axis=None)
      priorities[i][1] = -priorities[i][0] + 2*total_neighbors
    else:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = total_spin
      total_neighbors = np.sum(J[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)].flatten(), axis=None)
      priorities[i][1] = -priorities[i][0] - 2*total_neighbors

  return(priorities)




#score: {'data2D.txt': -0.03668317901234569}
#island_id: 3
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = -total_spin
      if h[site_nbr][i%N] > 0:
        for j in range(i-N*i):
          if J[j][i] != 0:
            priorities[i][1] -= J[j][i]
    else:
      total_spin = np.sum(h[max(0, i//N-1):min(N, i//N+2), max(0, i%N-1):min(N, i%N+2)], axis=None) + 2*h[i//N][i%N]
      priorities[i][0] = total_spin
      if h[site_nbr][i%N] < 0:
        for j in range(i-N*i):
          if J[j][i] != 0:
            priorities[i][1] += J[j][i]

  return(priorities)




#score: {'data2D.txt': -0.11975663580246927}
#island_id: 3
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin = np.zeros((N, N))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j] -= 1
      else:
        total_spin[i][j] += 1

      total_spin_sum = np.sum(total_spin[max(0, i-1):min(N, i+2), max(0, j-1):min(N, j+2)], axis=None)
      priorities[i*N+j][0] = -total_spin_sum
      priorities[i*N+j][1] = -priorities[i*N+j][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,(i//N+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i//N+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    # horizontal and vertical interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # diagonal interactions
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr2][i%N]
        priorities[i][1] -= h[site_nbr2][i%N]
      else:
        priorities[i][0] -= h[site_nbr2][i%N]
        priorities[i][1] += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total spin from J interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0024992283950617295}
#island_id: 1
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0045646604938271605}
#island_id: 1
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.005554166666666667}
#island_id: 2
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012955246913580248}
#island_id: 2
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_sum = 0
    right_sum = 0
    top_sum = 0
    bottom_sum = 0

    if i % N > 0: # not the left edge
      left_sum = J[1,i//N,i//N]*h[site_nbr][i%N]
    if i % N < N-1: # not the right edge
      right_sum = J[2,i//N,i//N]*h[(site_nbr+N-1)%N][(i+1)%N]
    if i >= N: # top edge
      top_sum = J[0,0,i//N]*h[site_nbr][i%N] + J[1,0,i//N]*h[site_nbr][(i-1)%N]
    if i < N*N-N: # bottom edge
      bottom_sum = J[3,N-1,i//N]*h[(site_nbr+N-1)%N][i%N] + J[2,N-1,i//N]*h[(site_nbr+N-1)%N][(i+1)%N]

    priorities[i][0] = h_site + left_sum + right_sum + top_sum + bottom_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    # Prioritize sites with zero magnetism
    if np.isclose(total_spin, 0):
      priorities[i][0] = 0
      priorities[i][1] = 0
    else:
      priorities[i][0] = total_spin
      if h[i//N][i%N] > 0:
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.005554166666666667}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(N)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004319598765432098}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) + 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) - 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0811097222222223}
#island_id: 0
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = -np.tanh(h_site + nn_energy) * np.exp(-J[3,i//N,site_nbr])
    priorities[i][1] = 1 - np.tanh(-h_site - nn_energy) * np.exp(-J[3,i//N,site_nbr])

  return(priorities)




#score: {'data2D.txt': -0.09935478395061736}
#island_id: 0
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy = 0
    for j in [J[0,i%N,i//N], J[1,i//N,site_nbr], J[2,i//N,site_nbr]]:
      if j > 0:
        nn_energy += h[i//N][i%N]
      else:
        nn_energy -= h[i//N][i%N]
        
    priorities[i][0] = -np.tanh(h[site_nbr][i%N] + nn_energy)
    priorities[i][1] = 1 - np.tanh(-h[site_nbr][i%N] - nn_energy)

  return(priorities)




#score: {'data2D.txt': -0.0329050925925926}
#island_id: 0
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = -np.tanh(h_site + nn_energy) * np.exp(-h_site)
    priorities[i][1] = 1 - np.tanh(-h_site - nn_energy) * np.exp(h_site)

  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.1661689814814817}
#island_id: 1
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  for j in range(N):
    site_nbr = (i % N + ((j-1)%2 - 1)) % N
    if J[3,i%N,j] > 0:
      priorities[i][0] += h[site_nbr][j]
      priorities[i][1] -= h[site_nbr][j]
    else:
      priorities[i][0] -= h[site_nbr][j]
      priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1752165123456792}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1638436728395064}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1638436728395064}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1638436728395064}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    else:
      total_spin -= np.sum(h[max(0, i%N-1):min(N, i%N+2),max(0, (i//N-1)%N):min(N,(i//N+1))].flatten())
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004319598765432098}
#island_id: 2
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) + 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) - 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004319598765432098}
#island_id: 2
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) + 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) - 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004319598765432098}
#island_id: 2
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    top_edge = (i < N) and i % N == 0 or i % N == N-1
    bottom_edge = (i >= N*N-N) and i % N == 0 or i % N == N-1
    left_edge = i < N and i % N == 0
    right_edge = i >= N*N-N and i % N == N-1

    if top_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,0]*h[(k+N-1)%N][0] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif bottom_edge:
      priorities[i][0] = h_site + sum([J[k,i//N,N-1]*h[(k+N-1)%N][N-1] for k in range(3)]) + 2*sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    elif left_edge:
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif right_edge:
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)]) + 2*sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) + 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)]) - 2*sum([J[k,i//N,(i-1)%N]*h[(k+N-1)%N][(i-1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin due to magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority for each spin direction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16621311728395086}
#island_id: 1
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16527021604938294}
#island_id: 1
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-(i%N+1))%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0009658950617283952}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = 0
    for k in range(4):
      if i % N == 0: # top edge
        total_spin += J[k,i//N,0]*h[(k+N-1)%N][0]
      elif i % N == N-1: # bottom edge
        total_spin += J[k,i//N,N-1]*h[(k+N-1)%N][N-1]
      elif k==1 and i < N: # left edge
        total_spin += J[1,0,i//N]*h[0,i%N]
      elif k==2 and i >= N*N-N: # right edge
        total_spin += J[2,N-1,i//N]*h[N-1,i%N]
      else:
        if k % 2 == 0:
          if J[k,i//N,(i+1)%N] > 0:
            total_spin += J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]
          else:
            total_spin -= J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]
        else:
          if i % N == 0: # top edge
            total_spin += J[k,i//N,0]*h[0,0]
          elif i % N == N-1: # bottom edge
            total_spin += J[k,i//N,N-1]*h[N-1,N-1]
          else:
            if J[k,i//N,(i+1)%N] > 0:
              total_spin += J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]
            else:
              total_spin -= J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00045663580246913573}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if k==0 and i < N: # left edge
        total_spin += J[k,i//N,i%N]*h[site_nbr][i%N]
      elif k==1 and (i>=N*N-N or i % N == N-1): # right and bottom edges
        total_spin += J[k,i//N,(i+1)%N]*h[site_nbr][(i+1)%N]
      elif k==2 and i < N: # top edge
        total_spin += J[k,i//N,0]*h[site_nbr][0]
      else: # bottom edge
        total_spin += J[k,i//N,N-1]*h[site_nbr][N-1]

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -priorities[i][0] + 2
    else:
      priorities[i][0] = total_spin - 1
      priorities[i][1] = -priorities[i][0] - 2

  return(priorities)




#score: {'data2D.txt': 0.039105709876543215}
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    sites = [site_nbrs[j] for j in range(N)]
    if h[sites[0]][i%N] > 0:
      priorities[i][0] += sum(h[site][i%N] for site in sites)
      priorities[i][1] -= sum(h[site][i%N] for site in sites)
    else:
      priorities[i][0] -= sum(h[site][i%N] for site in sites)
      priorities[i][1] += sum(h[site][i%N] for site in sites)
  
  return(priorities)




#score: {'data2D.txt': 0.16565200617283976}
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i%N][i//N]
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0018304012345679013}
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 2
    elif J[1,i%N,i//N] < 0:
      total_spin -= 2
    
    if J[2,i%N,i//N] > 0:
      total_spin += 3
    elif J[2,i%N,i//N] < 0:
      total_spin -= 3
    
    if J[3,i%N,i//N] > 0:
      total_spin += 4
    elif J[3,i%N,i//N] < 0:
      total_spin -= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00559212962962963}
#island_id: 2
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i < N: # left edge
      priorities[i][0] = h_site + sum([J[k,0,i//N]*h[0,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    elif i >= N*N-N: # right edge
      priorities[i][0] = h_site + sum([J[k,N-1,i//N]*h[N-1,i%N] for k in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        priorities[i][0] = h_site + sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h_site - sum([J[k,i//N,(i+1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03011095679012346}
#island_id: 0
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.017554475308641976}
#island_id: 0
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0] if J[2,i//N,site_nbr] > 0 else priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.06976620370370373}
#island_id: 0
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_product = (h[i//N][i%N] * h[site_nbr][i%N]) if i//N != site_nbr else 0
    priorities[i] = [total_spin + spin_product, -total_spin - spin_product]
  
  return(priorities)




#score: {'data2D.txt': -0.0010785493827160486}
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    if sum(neighbors) > 0:
      priorities[i][0] = h_site + max(neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min(neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.29600015432098703}
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors = [(i+1) % N, (i-1+N*N)%N]
    if i % N == 0:
      neighbors.remove((i+1) % N)
    elif i % N == N-1:
      neighbors.remove((i-1+N*N)%N)

    for neighbor in neighbors:
      h_sum = sum([J[k,neighbor//N,neighbor%N]*h[(k+N-1)%N][neighbor%N] for k in range(4)])
      if J[0,neighbor//N,neighbor%N] > 0:
        h_site += h_sum
      else:
        h_site -= h_sum

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + 1
      priorities[i][1] = -h_site - 2
    else:
      priorities[i][0] = -h_site - 1
      priorities[i][1] = h_site + 2

  return(priorities)




#score: {'data2D.txt': 0.029946141975308642}
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  # Additional optimization
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.006561574074074073}
#island_id: 3
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += h[site_nbr][i%N]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= h[site_nbr][i%N]
      total_spin[i][1] += 1
    
  site_neighbors = np.zeros((N*N,2))
  for i in range(N**2):
    if i % N > 0: 
      site_neighbors[i][0] = total_spin[(i-1)%N][0]
      site_neighbors[i][1] = total_spin[(i-1)%N][1]
    if i % N < N - 1:
      site_neighbors[i][0] += total_spin[(i+1)%N][0]
      site_neighbors[i][1] += total_spin[(i+1)%N][1]
    if i // N > 0: 
      site_neighbors[i][0] += total_spin[i-N][0]
      site_neighbors[i][1] += total_spin[i-N][1]
    if i // N < N - 1:
      site_neighbors[i][0] += total_spin[i+N][0]
      site_neighbors[i][1] += total_spin[i+N][1]
    
  return(site_neighbors)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      total_spin += J[k,i%N,i//N] * h[(i+((k-1)%2 - 1)) % N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16490663580246934}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i // N) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif i % N == 0:
      pass
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0033665123456790126}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -4.583333333333342e-05}
#island_id: 2
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[0,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

    if J[1,i%N,j] > 0:
      priorities[i][0] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][0] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': -0.01672824074074074}
#island_id: 2
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if h[(site_nbr+k)%N][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 3
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += h[site_nbr][i%N]
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin[i][0] -= h[site_nbr][i%N]
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return(priority_total)




#score: {'data2D.txt': -0.09941095679012354}
#island_id: 3
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += h[site_nbr][i%N]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= h[site_nbr][i%N]
      total_spin[i][1] += 1
    
  site_neighbors = np.zeros((N*N,2))
  for i in range(N**2):
    if i % N > 0: 
      site_neighbors[i][0] = total_spin[(i-1)%N][0]
      site_neighbors[i][1] = total_spin[(i-1)%N][1]
    if i % N < N - 1:
      site_neighbors[i][0] += total_spin[(i+1)%N][0]
      site_neighbors[i][1] += total_spin[(i+1)%N][1]
    if i // N > 0: 
      site_neighbors[i][0] += total_spin[i-N][0]
      site_neighbors[i][1] += total_spin[i-N][1]
    if i // N < N - 1:
      site_neighbors[i][0] += total_spin[i+N][0]
      site_neighbors[i][1] += total_spin[i+N][1]
    
  # Calculate the priority for each site
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] = site_neighbors[i][0] + total_spin[i][0]
      priorities[i][1] = -site_neighbors[i][1] - total_spin[i][1]
    else:
      priorities[i][0] = site_neighbors[i][0] - total_spin[i][0]
      priorities[i][1] = site_neighbors[i][1] + total_spin[i][1]
    
  return(priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.14679583333333357}
#island_id: 1
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((3-i%N)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i%N,i//N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + J[0,i%N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.11159182098765444}
#island_id: 1
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][k]
        priorities[i][1] -= h[site_nbr_row][k]
      else:
        priorities[i][0] -= h[site_nbr_row][k]
        priorities[i][1] += h[site_nbr_row][k]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.006813425925925925}
#island_id: 3
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  site_neighbors = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += h[site_nbr][i%N]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= h[site_nbr][i%N]
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if i % N > 0: 
      site_neighbors[i][0] = total_spin[(i-1)%N][0]
      site_neighbors[i][1] = total_spin[(i-1)%N][1]
    else:
      site_neighbors[i][0] = 0
      site_neighbors[i][1] = 0

    if i % N < N - 1:
      site_neighbors[i][0] += total_spin[(i+1)%N][0]
      site_neighbors[i][1] += total_spin[(i+1)%N][1]
    else:
      site_neighbors[i][0] = site_neighbors[i-1][0]
      site_neighbors[i][1] = site_neighbors[i-1][1]

    if i // N > 0: 
      site_neighbors[i][0] += total_spin[i-N][0]
      site_neighbors[i][1] += total_spin[i-N][1]
    else:
      site_neighbors[i][0] = 0
      site_neighbors[i][1] = 0

    if i // N < N - 1:
      site_neighbors[i][0] += total_spin[i+N][0]
      site_neighbors[i][1] += total_spin[i+N][1]
    else:
      site_neighbors[i][0] = site_neighbors[i-N][0]
      site_neighbors[i][1] = site_neighbors[i-N][1]

  return(site_neighbors)




#score: {'data2D.txt': 0.09259861111111112}
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07690231481481481}
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    if k == -1:
      priorities[i][0] -= total_energy
      priorities[i][1] = total_energy
    else:
      priorities[i][0] = total_energy
      priorities[i][1] -= total_energy
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    if total_energy > 0:
      priorities[i][1] -= 2*total_energy
    else:
      priorities[i][0] -= 2*total_energy
  return(priorities)




#score: {'data2D.txt': 0.02315416666666667}
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    if k == -1:
      priorities[i][0] = -total_energy + J[1,i//N,i%N] - J[0,i//N,i%N]
      priorities[i][1] = total_energy - J[1,i//N,i%N] + J[0,i//N,i%N]
    else:
      priorities[i][0] = -total_energy - J[1,i//N,i%N] + J[0,i//N,i%N]
      priorities[i][1] = total_energy + J[1,i//N,i%N] - J[0,i//N,i%N]
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.11303657407407419}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,site//N] > 0:
        total_spin += h[site][i%N]
      else:
        total_spin -= h[site][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0012865740740740745}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    
    total_spin = h[site_nbr_row][i%N] + J[0,i%N,i//N]
    
    if i % N > 0:
      total_spin += J[1,i%N,i//N]
    if i % N < N-1:
      total_spin += J[2,i%N,i//N]
    if i // N > 0:
      total_spin += J[3,i%N,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0045646604938271605}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0015445987654320982}
#island_id: 2
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[0,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

    if J[1,i%N,j] > 0:
      for k in range(3):
        site_nbr = (i % N + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          priorities[i][0] += J[k,i%N,k]*h[site_nbr][j]
          priorities[i][1] -= J[k,i%N,k]*h[site_nbr][j]
        else:
          priorities[i][0] -= J[k,i%N,k]*h[site_nbr][j]
          priorities[i][1] += J[k,i%N,k]*h[site_nbr][j]

    if h[site_nbr][j] > 0:
      priorities[i][0] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][0] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.005003858024691357}
#island_id: 2
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

    for j in range(3):
      site_nbr2 = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i%N,j] > 0:
        priorities[i][0] += h[site_nbr2][i%N]
        priorities[i][1] -= h[site_nbr2][i%N]
      else:
        priorities[i][0] -= h[site_nbr2][i%N]
        priorities[i][1] += h[site_nbr2][i%N]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.005206944444444444}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  # Additional optimization
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  # Improve by considering the neighboring sites' priorities
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(priorities[(i+N-1)%N*N:(i+1)%N*N, 1]) + np.sum(priorities[:i*N, 1])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= np.sum(priorities[(i+N-1)%N*N:(i+1)%N*N, 1]) - np.sum(priorities[:i*N, 1])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site][i%N]
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.01934614197530864}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + J[0,i//N,i%N]*h[site_nbr][i%N] + J[1,i//N,i%N]*h[(site_nbr+N-1)%N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - J[0,i//N,i%N]*h[site_nbr][i%N] - J[1,i//N,i%N]*h[(site_nbr+N-1)%N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0008757716049382714}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if i<N else 0
    for j in range(3):
      if J[j,i//N,i%N]*h[(j+N-1)%N][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.010306018518518518}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    if h[i//N][i%N] > 0:
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i%N]*h[site][i%N]
    else:
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin -= J[k,i//N,i%N]*h[site][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0024905864197530864}
#island_id: 2
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.16303564814814836}
#island_id: 1
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,N-1-i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+N-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0022038580246913587}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum([J[k,(i+1)%N,i//N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.32414552469135716}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - sum([abs(J[k,i%N,i//N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum([abs(J[k,i%N,i//N]) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.018280709876543212}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]*h[site_nbr2][i%N]
      priorities[i][1] -= J[3,i//N,i%N]
    else:
      priorities[i][0] -= J[3,i//N,i%N]*h[site_nbr2][i%N]
      priorities[i][1] += J[3,i//N,i%N]

  return(priorities)




#score: {'data2D.txt': 0.004153240740740741}
#island_id: 0
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = (J_up + J_down)*h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0011680555555555552}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = J_up * h_site + J_down * (-h_site)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.000672067901234568}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    
    # Calculate priority based on interactions
    priorities[i][0] = J_up - J_down
    priorities[i][1] = -(J_up - J_down)
  
  return(priorities)




#score: {'data2D.txt': 0.00013163580246913596}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009550771604938271}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -energy_diff
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    priorities[i][0] = energy_diff
    priorities[i][1] = -energy_diff
  return(priorities)




#score: {'data2D.txt': -0.009539043209876542}
#island_id: 0
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[j,i//N,(site_nbr+j-N)%N] if J[j,i//N,(site_nbr+j-N)%N]>0 else -J[j,i//N,(site_nbr+j-N)%N] for j in range(-1,3)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.015122685185185185}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.011386574074074073}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*abs(h[site][i%N])
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002788580246913579}
#island_id: 0
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  # Sort sites by priority and reverse the order
  indices = np.argsort(priorities[:,0])[::-1]
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': 0.043272685185185185}
#island_id: 0
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if np.random.rand() < 0.5 else total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0007489197530864195}
#island_id: 0
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    neighbor_sum = 0
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      neighbor_sum += np.sum(J[j, i//N, :])
    
    total_spin += neighbor_sum
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.012166203703703705}
#island_id: 0
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      
      total_spin += np.sum(J[j, i//N, :])
    
    # Add the magnetism term
    priorities[i][0] = total_spin + np.sum(h[i//N])
    priorities[i][1] = -total_spin - np.sum(h[i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1545288580246916}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11675262345679024}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(h[site_nbr])
      priorities[i][1] = -total_spin - sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin - sum(h[site_nbr])
      priorities[i][1] = total_spin + sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.11531342592592606}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k+2,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
      else:
        total_spin -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -total_spin - 1
    else:
      priorities[i][0] = -total_spin - 1
      priorities[i][1] = total_spin + 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
      else:
        total_spin -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.00016990740740740695}
#island_id: 0
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighborhood = [(site_nbr+(j-1)%2-N)%N for j in range(4)]
    total_spin = np.sum(J[:,i//N,np.array(neighborhood)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.004491512345679014}
#island_id: 2
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site][i%N]
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.000907870370370371}
#island_id: 2
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      direction = [(0,1), (1,0), (0,-1), (-1,0)][k]
      site = (i//N+direction[0])%N*N+(i%N+direction[1])
      total_spin += J[k,i//N,i%N]*h[site_nbr][site%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0009270061728395061}
#island_id: 0
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    else:
      priorities[i][0] -= h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = -total_spin + magnetism
    priorities[i][1] = total_spin + magnetism

  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin = np.sign(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -site_spin]
    else:
      priorities[i] = [-total_spin, site_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+N-1)%N)
    total_spin = h[site_nbr1][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr4 = ((i//N+N-2)%N)
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16520509259259286}
#island_id: 1
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0012776234567901232}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16476959876543235}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N
    
    if i > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    
    if i < N**2-1:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.07941527777777778}
#island_id: 0
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      if np.random.rand() < 0.5:  # assign random spin
        priorities[i][0] = np.random.choice([-1, 1])
        priorities[i][1] = -priorities[i][0]
      else:  # flip the previous spin
        site_nbr_prev = (i % N + ((i//N-1)%2 - 1)) % N
        if i > 0:
          prev_spin = priorities[(i-1)//N*N + (i-1)%N][0] * (-1) + priorities[(i-1)//N*N + (i-1)%N][1]
        else:  
          prev_spin = 0
        if prev_spin == -1 and np.random.rand() < 0.5:
          priorities[i][0] = 1
          priorities[i][1] = -1
        elif prev_spin == 1 and np.random.rand() < 0.5:
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = -priorities[(i-1)//N*N + (i-1)%N][0]
          priorities[i][1] = -priorities[(i-1)//N*N + (i-1)%N][1]
  return(priorities)




#score: {'data2D.txt': 0.10278287037037037}
#island_id: 0
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      neighbors = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      neighbor_spins = [h[site_nbr][i%N] * (1 if site_nbr == n else -1) for n in neighbors]
      total_magnetism = sum(neighbor_spins)
      priorities[i][0] = np.sign(total_magnetism)
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06296805555555555}
#island_id: 0
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        continue
      priority_total[0] += J[j,i//N,nn_site]
      if j == 3:
        continue
      for k in range(4):
        neighbor = (site_nbr + ((k-1)%2 - 1)) % N
        if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
          continue
        priority_total[0] += J[k,i//N,neighbor]
        priority_total[1] -= 2 * J[k,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.000977006172839506}
#island_id: 3
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      temp = total_spin[i*N+j][0] + h[site_nbr][j]

      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
        priority_total[i*N+j][0] -= temp
        priority_total[i*N+j][1] += temp
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        priority_total[i*N+j][0] += temp
        priority_total[i*N+j][1] -= temp

  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin[i][0] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
      
  for i in range(N**2):
    total_spin[i][1] = -total_spin[i][0]
    
  return(priority_total)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 3
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  return(priority_total)




#score: {'data2D.txt': 0.16314830246913603}
#island_id: 1
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.000756944444444444}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i] = [total_spin, -total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.11174706790123468}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.0593412037037037}
#island_id: 1
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.006338425925925925}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N]
      priorities[i][1] -= 2*h[site_nbr][i%N]
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N]
      priorities[i][1] += 2*h[site_nbr][i%N]
    
    for k in range(3):
     site = (i + ((k-1)%2 - 1)) % N
     if J[k,i%N,k] > 0:
       total_spin += h[site][i%N]
     else:
       total_spin -= h[site][i%N]
    if J[1,i%N,i%N] > 0:
      priorities[i][0] += 2*total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= 2*total_spin
      priorities[i][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.004312191358024692}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

    for k in range(3):
      if J[k,i%N,k] > 0:
        total_spin += h[(k+N-1)%N][i%N]
      else:
        total_spin -= h[(k+N-1)%N][i%N]

    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin

  return(priorities)




#score: {'data2D.txt': -4.583333333333342e-05}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[0,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

    if J[1,i%N,j] > 0:
      priorities[i][0] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][0] -= sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += sum([J[k,i%N,k]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.002182253086419753}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    
    total_spin1 = h[site_nbr1][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin1 += 1
    else:
      total_spin1 -= 1
    
    total_spin2 = h[site_nbr2][i%N]
    if J[1,i%N,i//N] > 0:
      total_spin2 += 1
    else:
      total_spin2 -= 1
    
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[2,i%N,(i//N)%N] > 0:
      total_spin1 += h[site_nbr3][i%N]
      total_spin1 -= h[site_nbr4][i%N]
    else:
      total_spin1 -= h[site_nbr3][i%N]
      total_spin1 += h[site_nbr4][i%N]
    
    if J[3,i%N,(i//N)%N] > 0:
      priorities[i][0] = total_spin1 + total_spin2
      priorities[i][1] = -total_spin1 - total_spin2
    else:
      priorities[i][0] = -total_spin1 - total_spin2
      priorities[i][1] = total_spin1 + total_spin2
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.22466682098765436}
#island_id: 2
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - abs(sum([J[k,i%N,i//N] for k in range(3)])) + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + abs(sum([J[k,i%N,i//N] for k in range(3)])) - h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004554475308641976}
#island_id: 2
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_list = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum([h[site_nbr][i%N] for site_nbr in site_nbr_list])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N][i%N]*h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbr_list)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N][i%N]*h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbr_list)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009445216049382716}
#island_id: 2
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - N
      priorities[i][1] = -(total_spin + N)
    else:
      priorities[i][0] = -(total_spin + N)
      priorities[i][1] = total_spin - N
    
  return(priorities)




#score: {'data2D.txt': -0.001222067901234568}
#island_id: 1
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    for j in range(N):
      site_nbrs.append((i % N + ((j-1)%2 - 1)) % N)
    
    for site_nbr in set(site_nbrs):
      if J[0,i%N,site_nbr] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for site_nbr in set(site_nbrs):
      if J[3,i//N,site_nbr] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.05632854938271607}
#island_id: 1
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[2,(i-1)%N//N+(i+1)%N//N,i%N] > 0:
      priorities[i][0] += h[(i-1)%N//N+(i+1)%N//N][i%N]
      priorities[i][1] -= h[(i-1)%N//N+(i+1)%N//N][i%N]
    else:
      priorities[i][0] -= h[(i-1)%N//N+(i+1)%N//N][i%N]
      priorities[i][1] += h[(i-1)%N//N+(i+1)%N//N][i%N]
    
    if J[3,i//N,(i-1)%N//N+(i+1)%N//N] > 0:
      priorities[i][0] += h[i//N][(i-1)%N//N+(i+1)%N//N]
      priorities[i][1] -= h[i//N][(i-1)%N//N+(i+1)%N//N]
    else:
      priorities[i][0] -= h[i//N][(i-1)%N//N+(i+1)%N//N]
      priorities[i][1] += h[i//N][(i-1)%N//N+(i+1)%N//N]
  
  return(priorities)




#score: {'data2D.txt': -0.013392129629629629}
#island_id: 2
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][j] for j in range(4)])
    priorities[i][0] = total_spin - sum([J[k,i//N,i%N]*abs(h[(k+N-1)%N][i%N]) for k in range(4)])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.018792746913580245}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[(site_nbr+k)%N][i%N] for k in range(4)])
    total_interaction = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][0] = total_spin - total_interaction
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.017268672839506168}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if h[(site_nbr+k)%N][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin - sum([J[k, i//N, i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if J[0, i//N, i%N] > 0 and h[(site_nbr+2)%N][i%N] > 0:
      priorities[i][0] += 1
    elif J[0, i//N, i%N] < 0 and h[(site_nbr+2)%N][i%N] < 0:
      priorities[i][0] -= 1
    if J[2, i//N, i%N] > 0 and h[(site_nbr+1)%N][i%N] > 0:
      priorities[i][0] += 1
    elif J[2, i//N, i%N] < 0 and h[(site_nbr+1)%N][i%N] < 0:
      priorities[i][0] -= 1
    
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00810108024691358}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if h[(site_nbr+k)%N][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin - sum([J[k, i//N, i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][1] = -priorities[i][0]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum([J[k, i//N, i%N] for k in range(4)])
      priorities[i][1] -= np.sum([J[k, i//N, i%N] for k in range(4)])
    else:
      priorities[i][0] -= np.sum([J[k, i//N, i%N] for k in range(4)])
      priorities[i][1] += np.sum([J[k, i//N, i%N] for k in range(4)])

  return(priorities)




#score: {'data2D.txt': 0.0008390432098765439}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([abs(J[k,i%N,i//N])*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([abs(J[k,i%N,i//N])*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0007875000000000001}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + abs(sum([J[k,i%N,i//N] for k in range(3)]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + abs(sum([J[k,i%N,i//N] for k in range(3)]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 8.503086419753082e-05}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0009782407407407411}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.22701373456790128}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([J[k,j,i]*h[site_nbr][k] for k in range(3)]) + abs(J[0,j,i]) - 2*h[site_nbr][j]
        priorities[i*N+j][1] -= sum([abs(J[k,j,i]) for k in range(3)])
      else:
        priorities[i*N+j][0] -= sum([J[k,j,i]*h[site_nbr][k] for k in range(3)]) - abs(J[0,j,i]) + 2*h[site_nbr][j]
        priorities[i*N+j][1] += sum([abs(J[k,j,i]) for k in range(3)])
  return(priorities)




#score: {'data2D.txt': 0.00036435185185185203}
#island_id: 0
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    J_down = -np.sum([J[j][i//N,i//N]*h[(site_nbr+1)%N][i%N] for j in range(4) if i//N != (i+N)//N and i%N != (i+1)%N])
    priorities[i][0] = h_site * J_up
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[site_nbr][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[site_nbr][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][1] += (1 + h_site)*J_up

  return(priorities)




#score: {'data2D.txt': 0.00328287037037037}
#island_id: 0
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = np.sum([J[j][i//N,i//N]*h[(i+N+j-5)%N][i%N] for j in range(4)])

    priorities[i][0] = (1 + h_site)*nn_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.12923780864197548}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N]>0 else total_spin

  return(priorities)




#score: {'data2D.txt': -0.0074624999999999995}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_col = (i % N + ((i//N-1)%2)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_col][j]
      else:
        total_spin -= h[site_nbr_col][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.15631805555555578}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin -= sum([J[3,i//N,j] for j in range(N) if i//N==j or i%N==j])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_lr = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr_ud = (i % N + ((i//N-1)%2 - 1)) % N
    if i % N == 0 or J[3,i%N,i//N] < 0:
      total_spin_lr = h[site_nbr_lr][i%N]
      priorities[i][0] -= total_spin_lr
      priorities[i][1] += total_spin_lr
    else:
      priorities[i][0] += total_spin_lr
      priorities[i][1] -= total_spin_lr
    
    if i//N == 0 or J[2,i//N,i%N] < 0:
      total_spin_ud = h[site_nbr_ud][i//N]
      priorities[i][0] -= total_spin_ud
      priorities[i][1] += total_spin_ud
    else:
      priorities[i][0] += total_spin_ud
      priorities[i][1] -= total_spin_ud
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.06800910493827163}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[i//N][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.00040879629629629523}
#island_id: 3
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_nbr2 = (i + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        h_site += J[k,i//N,i%N]*h[site_nbr2][i%N]
      else:
        h_site -= J[k,i//N,i%N]*h[site_nbr2][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001946450617283951}
#island_id: 3
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%N - 1)) % N

    priorities[i][0] = h_site + J[0,i%N,i//N]*h[left_nbr][i%N] + J[1,i%N,i//N]*h[right_nbr][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': 0.005357253086419752}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.03957422839506172}
#island_id: 1
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = np.sum(h[i//N,N-1-i%N])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': -0.003404783950617284}
#island_id: 1
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k, i % N, i // N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3, i % N, j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': 0.23835231481481475}
#island_id: 1
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin = h[i//N][i%N]
    if site_spin > 0:
      priorities[i] = [total_spin - site_spin, -total_spin + site_spin]
    else:
      priorities[i] = [-total_spin - site_spin, total_spin + site_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.014034722222222223}
#island_id: 0
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    spin_priority = total_energy + nn_energy
    magnetism_priority = -2 if h[site_nbr][i%N] > 0 else 2
    priorities[i][0] += spin_priority * magnetism_priority
    priorities[i][1] -= magnetism_priority
  return(priorities)




#score: {'data2D.txt': 0.03640077160493827}
#island_id: 0
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.0381266975308642}
#island_id: 0
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + nn_energy > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 2
    elif total_energy - nn_energy < 0:
      priorities[i][0] -= 2
      priorities[i][1] += 2
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0435591049382716}
#island_id: 0
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    energy_diff = total_energy + nn_energy
    magnetism_term = 2 * (np.sign(energy_diff) - np.sign(h[site_nbr][i%N]))
    priorities[i][0] += energy_diff + magnetism_term
    priorities[i][1] -= 2 * np.sign(energy_diff)
  return(priorities)




#score: {'data2D.txt': -0.0009782407407407411}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) 
        priorities[i*N+j][1] -= 2*total_spin - (sum([abs(J[k,j,i]) for k in range(3)]))
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) 
        priorities[i*N+j][1] += 2*total_spin + (sum([abs(J[k,j,i]) for k in range(3)]))
  return(priorities)




#score: {'data2D.txt': -0.0009782407407407411}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0009782407407407411}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + ((j+N-1)%N - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 4*total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 8*total_spin
      else:
        priorities[i*N+j][0] -= 4*total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 8*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': 0.0928430555555556}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    magnetism = h[i//N][i%N]
    interaction = J[:, i//N, i%N].sum()
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.011016512345679012}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    for k in range(3):
      site = ((i//N)%N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    priorities[i][0] = 3.5*total_spin
    priorities[i][1] = -2.5*total_spin
  return(priorities)




#score: {'data2D.txt': 0.1416804012345679}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    site_nbr=((i//N)%N)
    for j in range(4):
      if (j==0 and i%N!=0) or (j==1 and i%N!=N-1) or (j==2 and i%N!=0) or (j==3 and i%N!=N-1):
        total_spin += J[j,i//N,i%N]*h[site_nbr][i%N]
      else:
        if h[i//N][i%N] > 0:
          total_spin -= J[j,i//N,i%N]
        else:
          total_spin += J[j,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = 3.5*total_spin
      priorities[i][1] = -2.5*total_spin
    else:
      priorities[i][0] = -3.5*total_spin
      priorities[i][1] = 2.5*total_spin
  return(priorities)




#score: {'data2D.txt': 0.07503225308641975}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = 4*total_spin
      priorities[i][1] = -3*total_spin
    else:
      priorities[i][0] = -4*total_spin
      priorities[i][1] = 3*total_spin
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([-J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0] / (np.exp(total_spin) + 1)
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0] / (np.exp(-total_spin) + 1)

  return(priorities)




#score: {'data2D.txt': -0.22995385802469126}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    total_energy = h[i//N][i%N]
    
    for j in [0, 1, 2]:
      if J[j,i//N,site_nbr] > 0:
        nn_energy = h[site_nbr][i%N]
      else:
        nn_energy = -h[site_nbr][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,site_nbr] > 0).astype(int)
    
    if i < N2/2:
      priorities[i][1] = -total_energy - nn_energy_sum * nn_count
    else:
      priorities[i][0] = total_energy + nn_energy_sum * nn_count
  
  return(priorities)




#score: {'data2D.txt': -0.0023819444444444417}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    if i < N*N/2:
      priorities[i][1] = -priority_sum
    else:
      priorities[i][0] = -priority_sum
  
  return(priorities)




#score: {'data2D.txt': -0.0076915123456790125}
#island_id: 1
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i // N + ((i % N-1)%2 - 1)) % N
    site_nbr_col = i % N
    if J[3,site_nbr_row,site_nbr_col] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    priorities[i][1] = -total_spin
    priorities[i][0] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0003523148148148152}
#island_id: 1
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i//N]
    else:
      total_spin -= h[site_nbr][i//N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.15185447530864218}
#island_id: 1
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.06279861111111114}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,i//N,(site_nbr2+(j-1)%2-N)%N] if J[j,i//N,(site_nbr2+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr2+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr2][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k1 = (k % N + ((k//N-1)%2 - 1)) % N
      site_nbr_k2 = (k // N + ((k%N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k1+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k1+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k1][k%N]
      energy_diff += sum(J[j,k//N,(site_nbr_k2+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k2+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k2+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k2][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.03182854938271606}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,i//N,(site_nbr2+(j-1)%2-N)%N] if J[j,i//N,(site_nbr2+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr2+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr2][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0017245370370370368}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]) * 3.5
      priorities[i][1] -= 2.5 * np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] -= (np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]) * 3.5
      priorities[i][1] += 2.5 * np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]
    return(priorities)




#score: {'data2D.txt': 0.013060648148148155}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= 4.5 * total_spin
      priorities[i][1] += 3.5 * total_spin

    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
       priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0005279320987654321}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (total_spin * 3.5) + np.sum((J[:,i//N,:]*h[:,i%N]).T,axis=1).dot(h[site_nbr])
      priorities[i][1] -= (2.5 * total_spin) - np.sum((J[:,i//N,:]*h[:,i%N]).T,axis=1).dot(-h[site_nbr])
    else:
      priorities[i][0] -= (total_spin * 3.5) + np.sum((J[:,i//N,:]*-h[:,i%N]).T,axis=1).dot(h[site_nbr])
      priorities[i][1] += (2.5 * total_spin) - np.sum((J[:,i//N,:]*-h[:,i%N]).T,axis=1).dot(-h[site_nbr])

  return(priorities)




#score: {'data2D.txt': -0.0010050925925925921}
#island_id: 0
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    for j, site in enumerate(site_nbrs):
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.00773564814814815}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%N - 1)) % N
    
    site_energy = h[site_nbr][i%N] 
    left_energy = J[0,i%N,i//N]*h[left_nbr][i%N]
    right_energy = J[1,i%N,i//N]*h[right_nbr][i%N]

    priority_site_up = site_energy + left_energy - right_energy
    priority_site_down = -site_energy - left_energy + right_energy

    priorities[i][0] = priority_site_up
    priorities[i][1] = priority_site_down

  return(priorities)




#score: {'data2D.txt': -0.00035108024691358044}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%N - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + (J[0,i%N,i//N]*h[left_nbr][i%N]) + (J[1,i%N,i//N]*h[right_nbr][i%N])
    if J[2,i%N,i//N] > 0:
      priorities[i][1] = -priorities[i][0] - 2*(h[left_nbr][i%N] + h[right_nbr][i%N])
    else:
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001946450617283951}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%N - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + J[0,i%N,i//N]*h[left_nbr][i%N] + J[1,i%N,i//N]*h[right_nbr][i%N]
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.001946450617283951}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%N - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + J[0,i%N,i//N]*h[left_nbr][i%N] + J[1,i%N,i//N]*h[right_nbr][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': 0.0007992283950617285}
#island_id: 2
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0] / (np.exp(total_spin) + np.exp(-total_spin))
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0] / (np.exp(-total_spin) + np.exp(total_spin))

  return(priorities)




#score: {'data2D.txt': 0.001516820987654321}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr1][i%N]
      priorities[i][1] = -priorities[i][0] / (np.exp(total_spin) + 1)
    else:
      priorities[i][0] = -total_spin - h[site_nbr2][i//N]
      priorities[i][1] = -priorities[i][0] / (np.exp(-total_spin) + 1)

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + h[site_nbr][i%N]) * np.exp(total_spin) / (np.exp(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = (-total_spin - h[site_nbr][i%N]) * np.exp(-total_spin) / (np.exp(-total_spin) + 1)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00030354938271604946}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.05844490740740748}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.007430092592592594}
#island_id: 1
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    magnetism = 2 * (h[i//N][i%N] > 0) - 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += magnetism * h[site_nbr][j]
      else:
        total_spin -= magnetism * h[site_nbr][j]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.007507253086419754}
#island_id: 1
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.06976620370370373}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.06976620370370373}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.09845447530864204}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * (1/3) + h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.006928240740740742}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = -total_spin
    
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(3)]
    
    for neighbor in site_nbrs:
      if h[neighbor][i%N] > 0:
        priorities[i][0] += magnetism
        priorities[i][1] -= magnetism
      else:
        priorities[i][0] -= magnetism
        priorities[i][1] += magnetism
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11396250000000013}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.09481929012345693}
#island_id: 2
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.0009782407407407411}
#island_id: 2
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': 0.0051415123456790114}
#island_id: 0
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0, :N, i//N][i%N]) * h[site_nbr][i%N]
    total_spin_right = np.sum(J[1, :N, i//N][i%N]) * h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.004442746913580248}
#island_id: 0
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N:i//N+1,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,(i//N+N-1)%N:i//N+1,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.0022260802469135795}
#island_id: 0
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N:i//N+2,i%N:i%N+2].flatten())*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N:i//N+2,i%N:i%N+2].flatten())*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.002275771604938272}
#island_id: 0
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right) - np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right) + np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.0061973765432098765}
#island_id: 0
#version_generated: 2
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(J[:,site_nbr,i%N])
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      total_spin = -np.sum(J[:,site_nbr,i%N])
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.02573348765432099}
#island_id: 0
#version_generated: 2
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * np.sum(J[:,site_nbr,i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5 + 2.5
      priorities[i][1] -= (total_spin + 1) * 2.5
    else:
      priorities[i][0] -= total_spin * 3.5 - 2.5
      priorities[i][1] += -(total_spin + 1) * 2.5

  return(priorities)




#score: {'data2D.txt': -0.19697083333333334}
#island_id: 1
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1561655864197533}
#island_id: 1
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + ((i+N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N] + h[site_nbr3][i%N] + h[site_nbr4][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.02717299382716049}
#island_id: 1
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i//N,(i+1)%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

    if J[2,i//N-1,i%N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]

    if J[3,i//N,(i+1)%N] > 0:
      priorities[i][0] += h[i//N][(i+1)%N]
      priorities[i][1] -= h[i//N][(i+1)%N]
    else:
      priorities[i][0] -= h[i//N][(i+1)%N]
      priorities[i][1] += h[i//N][(i+1)%N]

  return(priorities)




#score: {'data2D.txt': 0.002537191358024691}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = 0
    for k in range(4):
      if k == 0:
        h_site += J[k,i//N,i%N]*h[site_nbr][i%N]
      else:
        site_nbr2 = (i + ((k-1)%2 - 1)) % N
        h_site += J[k,i//N,i%N]*h[site_nbr2][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.06602145061728396}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_nbr2 = (i + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        h_site += J[k,i//N,i%N]*h[site_nbr2][i%N]
      else:
        h_site -= J[k,i//N,i%N]*h[site_nbr2][i%N]

    priorities[i][1] = np.sum(J[:,i//N,i%N]) * 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + priorities[i][1]
    else:
      priorities[i][0] = -h_site - priorities[i][1]

  return(priorities)




#score: {'data2D.txt': -0.010890277777777778}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      for j in range(3):
        site_nbr2 = (i + ((j-1)%2 - 1)) % N
        if J[j,i//N,i%N] > 0:
          priorities[i][0] += J[j,i//N,i%N]*h[site_nbr2][i%N]
        else:
          priorities[i][0] -= J[j,i//N,i%N]*h[site_nbr2][i%N]
      if h_site := priorities[i][0]:
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][1] = 0
    else:
      for j in range(3):
        site_nbr2 = (i + ((j-1)%2 - 1)) % N
        if J[j,i//N,i%N] < 0:
          priorities[i][0] -= J[j,i//N,i%N]*h[site_nbr2][i%N]
        else:
          priorities[i][0] += J[j,i//N,i%N]*h[site_nbr2][i%N]
      if h_site := priorities[i][0]:
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][1] = 0
  return(priorities)




#score: {'data2D.txt': -0.003599537037037037}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(3):
      if J[j,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046830709876543246}
#island_id: 0
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.008303240740740743}
#island_id: 0
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,k//N]*n for k,n in zip(range(3),nns)])

    priorities[i][0] = h_site + nn_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.14482114197530882}
#island_id: 0
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = -h_site + nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046889969135802505}
#island_id: 0
#version_generated: 2
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19569953703703732}
#island_id: 2
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr1][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016356481481481482}
#island_id: 2
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) + sum([abs(J[k,j,i]) for k in range(3)])
        priorities[i*N+j][1] += 2*total_spin
      if i > 0:
        priorities[i*N+j][0] -= h[i-1][j]
        priorities[i*N+j][1] += 2*h[i-1][j]
      if j > 0:
        priorities[i*N+j][0] -= h[i][j-1]
        priorities[i*N+j][1] += 2*h[i][j-1]
      if i < N-1:
        priorities[i*N+j][0] += h[i+1][j]
        priorities[i*N+j][1] -= 2*h[i+1][j]
      if j < N-1:
        priorities[i*N+j][0] += h[i][j+1]
        priorities[i*N+j][1] -= 2*h[i][j+1]
  return(priorities)




#score: {'data2D.txt': -0.0016146604938271614}
#island_id: 3
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i//N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - h[site_nbr1][i%N] - h[site_nbr2][i//N]
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + h[site_nbr1][i%N] + h[site_nbr2][i//N]
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': -0.01031280864197531}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      total_spin += h[site_nbr][i%N]
      total_spin -= h[(i+1)%N][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      total_spin += h[(i+1)%N][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    row_spin = h[site_nbr_row][i%N]
    col_spin = h[i//N][i%N]
    
    total_spin = row_spin + col_spin
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    total_spin = J[3,i%N,i//N]*h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11713935185185198}
#island_id: 1
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.001936265432098765}
#island_id: 1
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin = h[site_nbr][i%N]
    else:
      total_spin = -h[site_nbr][i%N]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       total_spin += h[site_nbr][i%N]
     else:
       total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 1
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    neighbor_spin_sum = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
      
    for k in range(4):
      neighbor_site = (i % N + (k%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        neighbor_spin_sum += 1
      else:
        neighbor_spin_sum -= 1
        
      if h[neighbor_site][i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
        
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0005489197530864196}
#island_id: 1
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
     if J[k,i%N,i//N] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
     site_nbr = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
      priorities[i][0] += h[site_nbr][j]
      priorities[i][1] -= h[site_nbr][j]
     else:
      priorities[i][0] -= h[site_nbr][j]
      priorities[i][1] += h[site_nbr][j]
    
    # Add the site's interactions with its 2D nearest neighbors
    for j in range(3):
      for k in range(j+1,3):
        if J[k,i%N,j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.0016146604938271614}
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i//N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - h[site_nbr1][i%N] - h[site_nbr2][i//N]
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + h[site_nbr1][i%N] + h[site_nbr2][i//N]
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': 0.0014016975308641974}
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k, i//N, i//N]*h[(k+N-1)%N][i//N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - np.sum(h[site_nbr1:site_nbr1+2]) - np.sum(h[site_nbr2:site_nbr2+2])
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + np.sum(h[site_nbr1:site_nbr1+2]) + np.sum(h[site_nbr2:site_nbr2+2])
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': -0.0016146604938271614}
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i//N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - h[site_nbr1][i%N] - h[site_nbr2][i//N]
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + h[site_nbr1][i%N] + h[site_nbr2][i//N]
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': -0.0016146604938271614}
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i//N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin - h[site_nbr1][i%N] - h[site_nbr2][i//N]
      priorities[i][1] = np.exp(-priorities[i][0])
    else:
      priorities[i][0] = total_spin + h[site_nbr1][i%N] + h[site_nbr2][i//N]
      priorities[i][1] = 1 / (np.exp(priorities[i][0]) + 1)
  return(priorities)




#score: {'data2D.txt': -0.004508487654320987}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i//N,(site_nbr-1)%N] > 0:
      total_spin += 1
    elif J[0,i//N,(site_nbr-1)%N] < 0:
      total_spin -= 1
    if J[2,i//N,site_nbr] > 0:
      total_spin += 1
    elif J[2,i//N,site_nbr] < 0:
      total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.008857561728395063}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
      else:
        total_spin -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin - 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.008857561728395063}
#island_id: 0
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
      else:
        total_spin -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  return(priorities)




#score: {'data2D.txt': -0.00031249999999999984}
#island_id: 2
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] - h[site_nbr2][j]
      interaction_energy = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin + interaction_energy
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= total_spin - interaction_energy
        priorities[i*N+j][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': 0.16313904320987677}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i//N,(i-1)%N] > 0:
      total_spin += 1
    elif i % N == 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.19569953703703732}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr1][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.007503858024691358}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%N) % N
      total_spin = h[site_nbr1][j] if sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) > 0 else -h[site_nbr1][j]
      priorities[i*N+j][0] = total_spin + sum([abs(J[k,j,i]) for k in range(3)])
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.21020354938271624}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr1][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin + sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(4)]) - sum([abs(J[k,j,i]) for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 2
      else:
        priorities[i*N+j][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.06173101851851854}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + priority_term
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': 0.06173101851851854}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + priority_term
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': 0.16018009259259267}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_total += h[site_nbr][j]
      if site_nbr_total > 0:
        site_spin = 1
      else:
        site_spin = -1
      
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      priorities[i*N+j][0] = site_spin + (site_spin * site_nbr_total) + priority_term
      priorities[i*N+j][1] = 2*site_spin
  return(priorities)




#score: {'data2D.txt': 0.06173101851851854}
#island_id: 2
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        total_spin = 1
      else:
        total_spin = -1
        
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + priority_term
      priorities[i*N+j][1] = 2*total_spin
  return(priorities)




#score: {'data2D.txt': 0.29702608024691307}
#island_id: 2
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 3
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])) / 2
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.001047376543209877}
#island_id: 3
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(4):
      if i // N == (k % N) and k != i % N:
        neighbors_spin = J[k, i % N, i // N] * h[(k + N - 1) % N][i % N]
      elif k < 2:
        neighbors_spin = J[3, i % N, i // N] * (h[(site_nbr+N-1)%N][i%N] if k == 0 else h[site_nbr][i%N])
      else:
        continue
      h_site += neighbors_spin

    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002326388888888889}
#island_id: 3
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])) / 2
    neighbors_sum = sum([J[k,i%N,i//N]*h[k//N,k%N] for k in range(4)])
    priorities[i][0] += neighbors_sum / 8.0
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0013915123456790122}
#island_id: 3
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum([h[site_nbrs[k]][i%N] for k in range(4)])
    if all([J[k,i%N,i//N]*h[site_nbrs[k]][i%N] >= 0 for k in range(4)]):
      priorities[i][0] = total_spin / 2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = max(total_spin, -total_spin) / 2
      priorities[i][1] = min(-total_spin, total_spin) / 2
  return(priorities)




#score: {'data2D.txt': -0.0018757716049382718}
#island_id: 3
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_spin_minus_1 = (h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])) / 2
    priority_spin_plus_1 = -priority_spin_minus_1

    if priority_spin_minus_1 > priority_spin_plus_1:
      priorities[i][0] = priority_spin_minus_1
      priorities[i][1] = 1
    elif priority_spin_plus_1 > priority_spin_minus_1:
      priorities[i][0] = priority_spin_plus_1
      priorities[i][1] = -1
    else:
      priorities[i][0] = 0.5 * (priority_spin_minus_1 + priority_spin_plus_1)
      if np.random.rand() < 0.5:
        priorities[i][1] = 1
      else:
        priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.11205416666666662}
#island_id: 1
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N]) + h[i//N][i%N]
    
    if np.sum(J[:,i//N,i%N]) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      priorities[i*N+j][0] += h[site_nbr1][j]
      priorities[i*N+j][1] -= h[site_nbr1][j]
      
      if i > 0:
        priorities[i*N+j][0] += h[site_nbr2][j]
        priorities[i*N+j][1] -= h[site_nbr2][j]
        
  for i in range(N):
    for j in range(N-1,-1,-1):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      priorities[i*N+j][0] += h[site_nbr1][j]
      priorities[i*N+j][1] -= h[site_nbr1][j]
      
      if i < N-1:
        priorities[i*N+j][0] += h[site_nbr2][j]
        priorities[i*N+j][1] -= h[site_nbr2][j]
        
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.001513117283950617}
#island_id: 1
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add contributions from nearest neighbors
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Add contribution from site magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0012850308641975308}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i//N,i%N]*h[site_nbr][i%N]
    for j in range(3):
      total_spin += J[j+1,i//N,i%N]*h[(i + ((j-1)%2 - 1)) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5*total_spin
      priorities[i][1] -= 3.5*total_spin
    else:
      priorities[i][0] -= 4.5*total_spin
      priorities[i][1] += 3.5*total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.011644290123456792}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += J[3,i//N,i%N]
    else:
      total_spin -= J[3,i//N,i%N]
    for j in range(4):
      site_nbr = ((i//N)%N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,i%N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4*total_spin
      priorities[i][1] -= 3*total_spin
    else:
      priorities[i][0] -= 4*total_spin
      priorities[i][1] += 3*total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.003391203703703703}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] * J[0,i//N,i%N] + h[site_nbr2][i%N] * J[3,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5*total_spin
      priorities[i][1] -= 3.5*total_spin
    else:
      priorities[i][0] -= 4.5*total_spin
      priorities[i][1] += 3.5*total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0006288580246913583}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site's own magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N]
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N]

  # Calculate interactions with neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    neighbors = [(k, (k+i-N)//N) for k in range(4)]
    for neighbor in neighbors:
      priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]

  # Calculate priority based on total magnetism
  priorities[:,1] = -priorities[:,0]
  
  return(priorities)




#score: {'data2D.txt': -0.013447067901234568}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  for i in range(N**2):
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        priorities[i][0] += J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
      else:
        priorities[i][0] -= J[j,i//N,i%N]*h[(j+N-1)%N][i%N]

  for i in range(N**2):
    if h[i%N][i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.014635030864197532}
#island_id: 0
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0003581790123456815}
#island_id: 0
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = 0
    for j, site_nbr in enumerate(site_nbrs):
      if h[site_nbr][i%N] > 0:
        total_spin += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      else:
        total_spin -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin
  return(priorities)




#score: {'data2D.txt': 0.0062433641975308644}
#island_id: 0
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.16579922839506198}
#island_id: 1
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * N + sum(h[j][i%N] for j in range(N) if J[3,i%N,j] > 0)
      priorities[i][1] = -total_spin * N - sum(h[j][i%N] for j in range(N) if J[3,i%N,j] < 0)
    else:
      priorities[i][0] = -total_spin * N - sum(h[j][i%N] for j in range(N) if J[3,i%N,j] > 0)
      priorities[i][1] = total_spin * N + sum(h[j][i%N] for j in range(N) if J[3,i%N,j] < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09966805555555565}
#island_id: 1
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if h[site][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.11374922839506187}
#island_id: 1
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(2):
     site_nbr1 = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr1][i%N]
       priorities[i][1] -= h[site_nbr1][i%N]
     else:
       priorities[i][0] -= h[site_nbr1][i%N]
       priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
     site_nbr2 = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       priorities[i][0] += h[site_nbr2][j]
       priorities[i][1] -= h[site_nbr2][j]
     else:
       priorities[i][0] -= h[site_nbr2][j]
       priorities[i][1] += h[site_nbr2][j]
  
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    priority_up = 1/(1+np.exp((J_up - J_down)*h_site))
    priority_down = 1-priority_up

    priorities[k][0] = h_site*priority_up
    priorities[k][1] = (1-h_site)*priority_down

  return(priorities)




#score: {'data2D.txt': -0.005906944444444445}
#island_id: 0
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    J_up = np.sum([J[i,k%N,k//N]*h_site for i in [0,1]]) + J[2,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in [2,3]]) - J[2,k//N,k//N]

    priorities[k][0] = (1/(1+np.exp((J_up - J_down)*h_site)))*2*h_site
    priorities[k][1] = 1-(priorities[k][0])
  
  return(priorities)




#score: {'data2D.txt': -0.004241203703703704}
#island_id: 0
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0, 0] for _ in range(N * N)]

  for k in range(N ** 2):
    site_nbr = (k % N + ((k // N - 1) % 2 - 1)) % N
    if h[site_nbr][k % N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i, k % N, k // N] * h_site for i in nns]) + J[3, k // N, k // N]
    J_down = -np.sum([J[i, k % N, k // N] * (-h_site) for i in nns]) - J[3, k // N, k // N]

    priorities[k][0] = 2 * h_site / (1 + np.exp((J_up - J_down) * h_site))
    priorities[k][1] = 1 - priorities[k][0]

  return priorities




#score: {'data2D.txt': 0.11853533950617284}
#island_id: 0
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08728966049382715}
#island_id: 0
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.004913734567901234}
#island_id: 0
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [0,1]:
      if i+k < N*N:
        total_energy += J[k,i//N,i%N] * h[(i+k)%N//N][(i+k)%N%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 7.7623456790123e-05}
#island_id: 1
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0015646604938271609}
#island_id: 1
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute the interaction terms
    interaction_terms = np.sum(J[:,i%N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_terms, -total_spin - interaction_terms]
    else:
      priorities[i] = [-total_spin - interaction_terms, total_spin + interaction_terms]
      
  return(priorities)




#score: {'data2D.txt': 0.14444151234567923}
#island_id: 1
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -total_spin + np.sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = total_spin - np.sum(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.0004300925925925925}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_J = sum([J[k][j][i]*h[(k+N-1)%N][j] for k in range(4)])
      priority_spin = -np.sign(total_J)
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
  return priorities




#score: {'data2D.txt': -0.21766064814814826}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = (total_J + priority_spin) / 2
      priorities[i*N+j][1] = np.abs(total_J + priority_spin) - 1
  return(priorities)




#score: {'data2D.txt': -0.02123287037037037}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = (total_J + priority_spin) / 2
      priorities[i*N+j][1] = abs(priority_spin)
  return(priorities)




#score: {'data2D.txt': 0.29702608024691307}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.11531342592592606}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k+2,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
     else:
      total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.16548996913580274}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i,N-j-1] > 0:
        priorities[i*N+j][0] += h[site_nbr][N-j-1]
        priorities[i*N+j][1] -= h[site_nbr][N-j-1]
      else:
        priorities[i*N+j][0] -= h[site_nbr][N-j-1]
        priorities[i*N+j][1] += h[site_nbr][N-j-1]

  return(priorities)




#score: {'data2D.txt': -0.0014023148148148144}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    site_nbr2 = (i % N + ((i//N+1)%N-1)) % N
    if J[3,i%N,i//N] > 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] += 2*h[site_nbr][i%N]
        priorities[i][1] -= 2*h[site_nbr][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr][i%N]
        priorities[i][1] += 2*h[site_nbr][i%N]
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] += -2*h[site_nbr2][i%N]
        priorities[i][1] -= -2*h[site_nbr2][i%N]
      else:
        priorities[i][0] -= -2*h[site_nbr2][i%N]
        priorities[i][1] += -2*h[site_nbr2][i%N]
        
    site_nbr3 = (i % N + ((i//N-1)%N-1)) % N
    if J[0,i%N,i//N] > 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] += -2*h[site_nbr3][i%N]
        priorities[i][1] -= -2*h[site_nbr3][i%N]
      else:
        priorities[i][0] += 2*h[site_nbr3][i%N]
        priorities[i][1] -= 2*h[site_nbr3][i%N]
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] -= -2*h[site_nbr3][i%N]
        priorities[i][1] += -2*h[site_nbr3][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr3][i%N]
        priorities[i][1] += 2*h[site_nbr3][i%N]
        
    site_nbr4 = (i % N + ((i//N+1)%N-1)) % N
    if J[1,i%N,i//N] > 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] += -2*h[site_nbr4][i%N]
        priorities[i][1] -= -2*h[site_nbr4][i%N]
      else:
        priorities[i][0] += 2*h[site_nbr4][i%N]
        priorities[i][1] -= 2*h[site_nbr4][i%N]
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] -= -2*h[site_nbr4][i%N]
        priorities[i][1] += -2*h[site_nbr4][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr4][i%N]
        priorities[i][1] += 2*h[site_nbr4][i%N]
        
    site_nbr5 = (i % N + ((i//N-1)%N-1)) % N
    if J[2,i%N,i//N] > 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] += -2*h[site_nbr5][i%N]
        priorities[i][1] -= -2*h[site_nbr5][i%N]
      else:
        priorities[i][0] += 2*h[site_nbr5][i%N]
        priorities[i][1] -= 2*h[site_nbr5][i%N]
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] -= -2*h[site_nbr5][i%N]
        priorities[i][1] += -2*h[site_nbr5][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr5][i%N]
        priorities[i][1] += 2*h[site_nbr5][i%N]
    
    return priorities




#score: {'data2D.txt': 0.13494861111111128}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,(i-1)%N] > 0:
      total_spin += 1
    elif (i % N) == 0:
        total_spin -= 1
    else:
      total_spin -= 1
    
    if J[2,i//N,(i+1)%N] > 0:
      total_spin += 1
    elif (i % N) == N-1:
        total_spin -= 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-N)%N] > 0:
      total_spin += 1
    elif (i // N) == 0:
        total_spin -= 1
    elif (i % N) == 0:
        total_spin -= 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust based on magnetism and site interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.0016199074074074078}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin = total_spin + J[k,i%N,i//N]
        priorities[i][0] += 2*total_spin
        priorities[i][1] -= 2*total_spin
      else:
        total_spin = total_spin - J[k,i%N,i//N]
        priorities[i][0] -= 2*total_spin
        priorities[i][1] += 2*total_spin
    
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.163503240740741}
#island_id: 1
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add diagonal and horizontal interactions
    site_nbr = (i % N + ((3)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+N-1)%2 - 1)) % N
    total_spin2 = h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+total_spin2, -(total_spin+total_spin2)]
    else:
      priorities[i] = [-total_spin-total_spin2, total_spin+total_spin2]
  return(priorities)




#score: {'data2D.txt': 0.037921141975308645}
#island_id: 0
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] = total_energy - nn_energy
      priorities[i][1] -= 3
    elif total_energy + 2*nn_energy < 0:
      priorities[i][0] = total_energy + nn_energy
      priorities[i][1] += 3
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = total_energy - 1
        priorities[i][1] -= 2
      else:
        priorities[i][0] = total_energy + 1
        priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': -0.0034063271604938272}
#island_id: 0
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[site_nbr][k] if k==0 else h[site_nbr][(k+1)%3]) for k in range(3))
    total_energy = h[site_nbr][i%N]
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.015843055555555558}
#island_id: 0
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2
    else:
      if np.random.rand() < 0.5:
        priorities[i][0] += total_energy
        priorities[i][1] -= 2
      else:
        priorities[i][0] -= total_energy
        priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.29702608024691307}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': -0.3419819444444434}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 2
      else:
        priorities[i*N+j][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
  return(priorities)




#score: {'data2D.txt': 0.027622376543209873}
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      neighbor_spin_sum = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      if neighbor_spin_sum > 0:
        priority_spin += 2
      else:
        priority_spin -= 2
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0] - 1
    else:
      priorities[i][1] = priorities[i][0] + 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][1] = abs(priorities[i][1])
  
  return(priorities)




#score: {'data2D.txt': -0.19979984567901235}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    
    if sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) > 0:
      priorities[i][1] = -priorities[i][0] - 1
    else:
      priorities[i][1] = priorities[i][0] + 1
  
  return(priorities)




#score: {'data2D.txt': -0.22370231481481487}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0] - 1
    else:
      priorities[i][1] = priorities[i][0] + 1
  
  return(priorities)




#score: {'data2D.txt': 0.1006195987654321}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0] - sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    else:
      priorities[i][1] = priorities[i][0] + sum(-J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.00378070987654321}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
      if h[i%N][i%N] > 0:
        total_energy -= 2 * k
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11853533950617284}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004664043209876544}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07383966049382715}
#island_id: 0
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0, 1]:
      if k == 0:
        total_energy += J[k, i//N, i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
      else:
        total_energy -= J[k, i//N, i%N] * (h[(i-k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(N)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.29702608024691307}
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.0867097222222223}
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      neighbors_sum = sum([J[0,j,i]*(2*h[(i+(k-1))%N][j]) + J[1,j,i]*(2*h[(i+1)%N][j]) + J[2,j,i]*(2*h[(i+N-1)%N][j]) for k in range(3)])
      
      priorities[i*N+j][0] = total_J + neighbors_sum + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.27914212962962937}
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      if J[0,j,i] + J[2,j,i] > 0:
        total_J += h[i][j]
      else:
        total_J -= h[i][j]
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': -0.1786841049382718}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        total_spin = 1
      else:
        total_spin = -1
        
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      priorities[i*N+j][0] = (total_spin + 0.5*priority_term)*np.exp(-sum([J[k,j,i]**2 for k in range(3)]))
      priorities[i*N+j][1] = -priorities[i*N+j][0]
  return(priorities)




#score: {'data2D.txt': 0.30233441358024626}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_sum = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_sum > 0:
        total_spin = 1
      else:
        total_spin = -1
        
      priority_term = (sum([J[k, j, i]*h[(k+N-1)%N][j] for k in range(3)]) -
               sum([abs(J[k, j, i]) for k in range(3)])) * 2
      site_nbr_sum -= total_spin
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = site_nbr_sum + priority_term
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -site_nbr_sum - priority_term
        priorities[i*N+j][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.11895879629629633}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      priority_term = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)]) - sum([abs(J[k,j,i]) for k in range(3)])
      
      if total_spin == -1:
        priorities[i*N+j][0] = (site_nbr_total + priority_term) * 2
        priorities[i*N+j][1] = -(site_nbr_total + priority_term)
      else:
        priorities[i*N+j][0] = site_nbr_total + priority_term
        priorities[i*N+j][1] = -site_nbr_total - priority_term
  return(priorities)




#score: {'data2D.txt': 0.0012989197530864193}
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = sum(J[k,i//N,i%N] * h[site_nbr][k] for k in range(4))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011918364197530866}
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N]
    
    if i%N > 0:
      total_spin += J[1,i//N,i%N] * (h[site_nbr1][i%N] - h[site_nbr2][i%N])
    
    if i//N > 0 and i % N < N-1:
      total_spin += J[2,i//N,i%N] * (h[site_nbr1][i%N] + h[site_nbr2][i%N])
    
    if i % N < N-1:
      total_spin += J[3,i//N,i%N] * (h[site_nbr1][i%N] - h[site_nbr2][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16556589506172864}
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-2)%2 - 1)) % N
    if J[3,i%N,(i//N+1)%N] > 0:
      priorities[i][0] += h[site_nbr_row][(i//N+1)%N]
      priorities[i][1] -= h[site_nbr_row][(i//N+1)%N]
    else:
      priorities[i][0] -= h[site_nbr_row][(i//N+1)%N]
      priorities[i][1] += h[site_nbr_row][(i//N+1)%N]
    
    site_nbr_col = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,(i//N-1)%N] > 0:
      priorities[i][0] += h[site_nbr_col][(i//N-1)%N]
      priorities[i][1] -= h[site_nbr_col][(i//N-1)%N]
    else:
      priorities[i][0] -= h[site_nbr_col][(i//N-1)%N]
      priorities[i][1] += h[site_nbr_col][(i//N-1)%N]
    
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 1
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the energy of the current spin configuration
    energy = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        energy += 2*h[site_nbr][i%N]
      else:
        energy -= 2*h[site_nbr][i%N]
    
    # Calculate the total spin of the nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        energy -= h[site_nbr][j]
      else:
        energy += h[site_nbr][j]
    
    # Calculate the priority based on the energy and total spin
    for k in range(2):
      priorities[i][k] = -energy + total_spin*k
  
  return(priorities)




#score: {'data2D.txt': -0.01216219135802469}
#island_id: 1
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin + sum(J[j, i%N, i//N] * h[(j+((i-1)%2 - 1)) % N][i%N] for j in range(4))
    priorities[i][1] = -total_spin - sum(J[j, i%N, i//N] * h[(j+((i-1)%2 - 1)) % N][i%N] for j in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16316219135802493}
#island_id: 1
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,(i//N+N-1)%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,(i%N+(i//N-1)%2-1)%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.01775077160493827}
#island_id: 0
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += (total_energy + nn_energy) * N
      priorities[i][1] -= 2*N
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] -= (total_energy - nn_energy) * N
      priorities[i][1] += 2*N
    else:
      if np.random.rand() < 0.5:
        priorities[i][0] += (total_energy + nn_energy) * N
        priorities[i][1] -= 2*N
      else:
        priorities[i][0] -= (total_energy - nn_energy) * N
        priorities[i][1] += 2*N
  return(priorities)




#score: {'data2D.txt': 0.03640077160493827}
#island_id: 0
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    majority_vote = 1 if np.mean([total_energy + 2*nn_energy, -total_energy - 2*nn_energy]) > 0 else -1
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2
    else:
      priorities[i][0] += majority_vote * total_energy
      if majority_vote == 1:
        priorities[i][1] -= 2
      else:
        priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.01513256172839506}
#island_id: 0
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    energy_diff = total_energy + 2*nn_energy
    if energy_diff > 0:
      priorities[i][0] += energy_diff / (abs(energy_diff) + 1)
      priorities[i][1] -= abs(energy_diff) - 1
    else:
      priorities[i][0] += np.tanh(total_energy / (abs(total_energy) + 1))
      priorities[i][1] -= 2 * np.tanh(total_energy / (abs(total_energy) + 1))
  return(priorities)




#score: {'data2D.txt': 0.02398811728395062}
#island_id: 3
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum([h[site_nbrs[k]][i%N] for k in range(4)])
    J_sum = sum([J[k,i//N,i%N]*h[site_nbrs[k]][i%N] for k in range(4)])
    if J_sum >= 0:
      priorities[i][0] = total_spin / 2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = max(total_spin, -total_spin) / 2
      priorities[i][1] = min(-total_spin, total_spin) / 2
  return(priorities)




#score: {'data2D.txt': -0.001287808641975308}
#island_id: 3
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum([h[site_nbrs[k]][i%N] * J[k,i//N][i%N//N] for k in range(4)])
    if all([J[k,i%N,i//N]*h[site_nbrs[k]][i%N] >= 0 for k in range(4)]):
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = max(total_spin, -total_spin)
      priorities[i][1] = min(-total_spin, total_spin)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin_up = sum([J[k,i%N,i//N]*h[site_nbrs[k]][i%N] if J[k,i%N,i//N]*h[site_nbrs[k]][i%N] > 0 else -J[k,i%N,i//N]*h[site_nbrs[k]][i%N] for k in range(4)])
    total_spin_down = sum([J[k,i%N,i//N]*h[site_nbrs[k]][i%N] if J[k,i%N,i//N]*h[site_nbrs[k]][i%N] < 0 else -J[k,i%N,i//N]*h[site_nbrs[k]][i%N] for k in range(4)])
    if total_spin_up > total_spin_down:
      priorities[i][0] = total_spin_up
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin_down
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.02520817901234568}
#island_id: 2
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      neighbors = [(i-1,N*j), (i+1,N*j),(i, N*(j-1)), (i, N*(j+1))]
      if any(k<0 or k>=N for k in [neighbor[0] for neighbor in neighbors]):
        left_up_spin = 1
      else:
        left_up_spin = -1
        
      if any(k<0 or k>=N for k in [neighbor[0] for neighbor in neighbors[1:]]):
        right_down_spin = 1
      else:
        right_down_spin = -1
        
      priorities[i*N+j][0] = total_J + priority_spin + left_up_spin + right_down_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': -0.2977408950617279}
#island_id: 2
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      total_spin = 0
      if site_nbr_total > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priority_spin = (total_J + total_spin) / abs(total_J + total_spin)
      priorities[i*N+j][0] = 2*priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.05695540123456794}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,(i+1)%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    if J[2,i//N,(i+N)%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[3,i//N,(i-1)%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.00772175925925926}
#island_id: 1
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += sum([h[(i+N)%N][j] for j in range(N)])
    else:
      total_spin -= sum([h[(i+N)%N][j] for j in range(N)])
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04210632716049383}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        continue
      priority_total[0] += J[k,i//N,neighbor]
      if k==3:
        priority_total[1] -= 2*J[k,i//N,neighbor]
      else:
        priority_total[1] -= J[k,i//N,neighbor]

    priorities[i][0] = -priority_total[1]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006601388888888889}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        continue
      priority_total[0] += J[k,i//N,neighbor]
      if k==3:
        priority_total[1] -= 2*J[k,i//N,neighbor]
      else:
        priority_total[1] -= J[k,i//N,neighbor]

    priorities[i][0] = np.sum([x for x in priority_total]) 
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.13143472222222222}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    neighbors_energy = 0
    for k in [-1, 0, 1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        neighbors_energy += J[abs(k), i//N, x%N] * h[x%N][y]
    priorities[i][0] = total_energy + neighbors_energy
    priorities[i][1] = -total_energy - neighbors_energy
  return priorities




#score: {'data2D.txt': 0.00020632716049382688}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.12989891975308643}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_energy = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy += h[site_nbr][i%N]
    for k in [-1, 0, 1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = total_energy
    priorities[i][1] = -total_energy
  return(priorities)




#score: {'data2D.txt': 0.06266064814814815}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else h[(i-k+1)%N][i%N]) for k in range(3))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06877237654320988}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] 
    for k in range(3):
      if k == 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 1:
        total_energy += J[k,i//N,i%N] * h[(i+k+2)%N][i%N]
      else:
        total_energy += J[k,i//N,i%N] * h[(i+k-2)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_plus = h[site_nbr][i%N] + sum(J[k,i//N,i%N]*h[(i+k-1)%N][i%N] for k in range(3))
    energy_minus = -2*h[site_nbr][i%N] + sum(J[k,i//N,i%N]*h[(i+k-1)%N][i%N] for k in range(3))
    priorities[i][0] = energy_plus
    priorities[i][1] = energy_minus
  return(priorities)




#score: {'data2D.txt': -0.012461574074074073}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if J[0, i//N, i%N] != 0:
      priorities[i][0] = total_energy - sum(J[k, i//N, i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    else:
      priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1518933641975311}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr1 = (i % N + ((2)%2 - 1)) % N
    site_nbr2 = (i % N + ((3)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr1][i%N]
      total_spin -= h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr1][i%N]
      total_spin += h[site_nbr2][i%N]
    
    if J[1,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
      total_spin -= h[(i//N+1)%N][i%N]
    else:
      total_spin -= h[i//N][i%N]
      total_spin += h[(i//N+1)%N][i%N]
    
    if J[2,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
      total_spin -= h[(i//N-1)%N][i%N]
    else:
      total_spin -= h[i//N][i%N]
      total_spin += h[(i//N-1)%N][i%N]
    
    if J[3,i%N,i//N] > 0:
      total_spin += h[(i//N-1)%N][i%N]
      total_spin -= h[(i//N+1)%N][i%N]
    else:
      total_spin -= h[(i//N-1)%N][i%N]
      total_spin += h[(i//N+1)%N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.000481018518518519}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0, i%N, i//N]
    
    if i < N:
      total_spin += h[site_nbr1][0] + J[1, i%N, 0]
      total_spin += J[2, i%N, 0] * (h[site_nbr1][0] - h[site_nbr2][i%N])
    else:
      total_spin -= J[3, i%N, i//N] * (h[site_nbr1][i%N] - h[site_nbr2][0])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.013439351851851853}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_sum = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_sum > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      priority_term = (sum([J[k, j, i]*h[(k+N-1)%N][j] for k in range(3)]) -
               sum([abs(J[k, j, i]) for k in range(3)])) * 2
      site_nbr_sum -= total_spin
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = (site_nbr_sum + priority_term) ** 1.5
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -(site_nbr_sum + priority_term) ** 1.5
        priorities[i*N+j][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.30233441358024626}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_sum = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_sum > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      priority_term = (sum([J[k, j, i]*h[(k+N-1)%N][j] for k in range(3)]) -
               sum([abs(J[k, j, i]) for k in range(3)])) * 2
      site_nbr_sum -= total_spin
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = site_nbr_sum + priority_term
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -site_nbr_sum - priority_term
        priorities[i*N+j][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.0033763888888888893}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_sum = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_sum > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      priority_term = (sum([J[k, j, i]*h[(k+N-1)%N][j] for k in range(3)]) -
               sum([abs(J[k, j, i]) for k in range(3)])) * 2
      site_nbr_sum -= total_spin
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = site_nbr_sum + priority_term
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -site_nbr_sum - priority_term
        priorities[i*N+j][1] = total_spin
      
  # Additional improvement: sort spins based on their priority
  for i in range(N*N):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': -0.3296455246913571}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_sum = sum([J[k, j, i]*h[(k+N-1)%N][j] for k in range(3)]) + h[i][j]
      if site_nbr_sum > 0:
        total_spin = -1
      else:
        total_spin = 1
      
      priority_term = (sum([abs(J[k, j, i]) for k in range(3)])) * 2
      site_nbr_sum -= total_spin
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = site_nbr_sum + priority_term
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -site_nbr_sum - priority_term
        priorities[i*N+j][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.3382486111111101}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
        
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      # Calculate the energy difference between spin up and down
      delta_energy = (total_spin + total_J) * h[i][j]
      
      # Calculate the priority based on the energy difference
      priorities[i*N+j][0] = delta_energy + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': -0.08948225308641981}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      if J[0,j,i]+J[1,j,i]+J[2,j,i]>0:
        priorities[i*N+j][0] = total_spin + total_J + priority_spin
        priorities[i*N+j][1] = -2*priority_spin
      else:
        priorities[i*N+j][0] = total_spin + total_J - priority_spin
        priorities[i*N+j][1] = 2*priority_spin
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.0021103395061728395}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][0] = (h_site + neighbors_sum) / 2
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004936574074074074}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_sum = sum([J[k,i%N,(i+N-1)%N]%N*k for k in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + neighbors_sum / 8.0
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001293055555555555}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][0] = (h_site + neighbors_sum / 8.0) * np.sign(h_site)
  return(priorities)




#score: {'data2D.txt': 0.3382486111111101}
#island_id: 2
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
  return(priorities)




#score: {'data2D.txt': 0.3382486111111101}
#island_id: 2
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
        
  return(priorities)




#score: {'data2D.txt': 0.3382486111111101}
#island_id: 2
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.1641964506172842}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr_row][i//N]
      priorities[i][1] -= h[site_nbr_row][i//N]
    else:
      priorities[i][0] -= h[site_nbr_row][i//N]
      priorities[i][1] += h[site_nbr_row][i//N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i%N]
      priorities[i][1] -= h[site_nbr_col][i%N]
    else:
      priorities[i][0] -= h[site_nbr_col][i%N]
      priorities[i][1] += h[site_nbr_col][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.011688425925925925}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = -total_spin * (h[i//N][i%N]>0) + h[site_nbr][i%N]
    priorities[i][1] = total_spin * (h[i//N][i%N]<0) - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the sum of interactions from nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust the priority based on magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2781828703703699}
#island_id: 2
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
  # Add some extra information based on the interaction with neighboring sites
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([J[k,j,i]*h[site_nbr][k] for k in range(3)])
        priorities[i*N+j][1] -= 2*sum([abs(J[k,j,i])*h[site_nbr][k] for k in range(3)])
      else:
        priorities[i*N+j][0] -= sum([J[k,j,i]*h[site_nbr][k] for k in range(3)])
        priorities[i*N+j][1] += 2*sum([abs(J[k,j,i])*h[site_nbr][k] for k in range(3)])
  
  return(priorities)




#score: {'data2D.txt': 0.27333225308641934}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Add some extra information based on the interaction with neighboring sites
      for k in range(3):
        if h[k][j] > 0:
          priorities[i*N+j][0] += J[k,j,i]*h[(k+N-1)%N][j]
          priorities[i*N+j][1] -= 2*abs(J[k,j,i])*h[(k+N-1)%N][j]
        else:
          priorities[i*N+j][0] -= J[k,j,i]*h[(k+N-1)%N][j]
          priorities[i*N+j][1] += 2*abs(J[k,j,i])*h[(k+N-1)%N][j]
  return(priorities)




#score: {'data2D.txt': 0.18927299382716076}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = sum([h[site_nbr1][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Add some extra information based on the interaction with neighboring sites
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([J[k,j,i]*h[site_nbr1][k] for k in range(3)])
        priorities[i*N+j][1] -= 2*sum([abs(J[k,j,i])*h[site_nbr1][k] for k in range(3)])
      else:
        priorities[i*N+j][0] -= sum([J[k,j,i]*h[site_nbr1][k] for k in range(3)])
        priorities[i*N+j][1] += 2*sum([abs(J[k,j,i])*h[site_nbr1][k] for k in range(3)])
      if j < N-1:
        site_nbr2 = (i + ((j+1)%2 - 1)) % N
        if h[i][j] > 0:
          priorities[i*N+j][0] += sum([J[k,j,i]*h[site_nbr2][k] for k in range(3)])
          priorities[i*N+j][1] -= 2*sum([abs(J[k,j,i])*h[site_nbr2][k] for k in range(3)])
        else:
          priorities[i*N+j][0] -= sum([J[k,j,i]*h[site_nbr2][k] for k in range(3)])
          priorities[i*N+j][1] += 2*sum([abs(J[k,j,i])*h[site_nbr2][k] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.1798436728395064}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Calculate the interactions with neighboring sites
      for k in range(3):
        site_nbr_2 = (i + ((k-1)%2 - 1)) % N
        if h[i][j] > 0:
          priorities[i*N+j][0] += sum([J[k,j,i]*h[site_nbr_2][k] for k in range(3)])
          priorities[i*N+j][1] -= 2*sum([abs(J[k,j,i])*h[site_nbr_2][k] for k in range(3)])
        else:
          priorities[i*N+j][0] -= sum([J[k,j,i]*h[site_nbr_2][k] for k in range(3)])
          priorities[i*N+j][1] += 2*sum([abs(J[k,j,i])*h[site_nbr_2][k] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1155498456790125}
#island_id: 1
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0007057098765432113}
#island_id: 0
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012643518518518535}
#island_id: 0
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[2, i//N, i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[2, i//N, i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0007859567901234579}
#island_id: 0
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1, i//N, i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1, i//N, i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16464336419753106}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((3)%2 - 1)) % N
    site_nbr2 = (i // N + ((3-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1642717592592595}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i+N-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%(N-1),(i//N)+(i%N)//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,(i+1)%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657177469135805}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i-1)%N)%N) % N
    site_nbr_right = (i % N + ((i+1)%N)%N) % N
    
    if i % N > 0:
      priorities[i][0] += h[site_nbr_left][i//N]
      priorities[i][1] -= h[site_nbr_left][i//N]
    
    if i % N < N-1:
      priorities[i][0] += h[site_nbr_right][i//N]
      priorities[i][1] -= h[site_nbr_right][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.22659182098765454}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Add some extra information based on the interaction with neighboring sites
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j] > 0:
          priorities[i*N+j][0] += J[k,j,i]*h[site_nbr][j]
          priorities[i*N+j][1] -= 2*abs(J[k,j,i])*h[site_nbr][j]
        else:
          priorities[i*N+j][0] -= J[k,j,i]*h[site_nbr][j]
          priorities[i*N+j][1] += 2*abs(J[k,j,i])*h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.22659182098765454}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Add some extra information based on the interaction with neighboring sites
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j] > 0:
          priorities[i*N+j][0] += J[k,j,i]*h[site_nbr][j]
          priorities[i*N+j][1] -= 2*abs(J[k,j,i])*h[site_nbr][j]
        else:
          priorities[i*N+j][0] -= J[k,j,i]*h[site_nbr][j]
          priorities[i*N+j][1] += 2*abs(J[k,j,i])*h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.22659182098765454}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(3)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      if total_spin > 0:
        priorities[i*N+j][1] = -2*priority_spin * min(total_spin, abs(total_spin))
      else:
        priorities[i*N+j][1] = -2*priority_spin * max(total_spin, -total_spin)
      
      # Add some extra information based on the interaction with neighboring sites
      for k in range(3):
        site_nbr_k = (i + ((k-1)%2 - 1)) % N
        if h[i][j] > 0:
          priorities[i*N+j][0] += J[k,j,i]*h[site_nbr_k][j]
          priorities[i*N+j][1] -= 2*abs(J[k,j,i])*h[site_nbr_k][j]
        else:
          priorities[i*N+j][0] -= J[k,j,i]*h[site_nbr_k][j]
          priorities[i*N+j][1] += 2*abs(J[k,j,i])*h[site_nbr_k][j]
  return(priorities)




#score: {'data2D.txt': -0.0021362654320987657}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      # Prioritize spins that align with the magnetism and minimize energy
      if h[i][j] > 0:
        priorities[i*N+j][0] = -2 * priority_spin + total_J
        priorities[i*N+j][1] = 2 * priority_spin
      else:
        priorities[i*N+j][0] = 2 * priority_spin + total_J
        priorities[i*N+j][1] = -2 * priority_spin
  return(priorities)




#score: {'data2D.txt': 0.29702608024691307}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = 1
      else:
        priority_spin = -1
        
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = 2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.3262717592592586}
#island_id: 2
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr_total = sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(3)]) + h[i][j]
      if site_nbr_total > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
      
  return(priorities)




#score: {'data2D.txt': 0.1730038580246915}
#island_id: 2
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(N)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_spin + total_J + priority_spin
      priorities[i*N+j][1] = 2*priorities[i*N+j][0]
  return(priorities)




#score: {'data2D.txt': 0.3411970679012335}
#island_id: 2
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(N)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = -1
      else:
        priority_spin = 1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin + (total_spin/abs(total_spin))
      priorities[i*N+j][1] = -2*priority_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(N)]) + h[i][j]
      if h[i][j] > 0:
        priority_spin = 1
      else:
        priority_spin = -1
      
      total_J = sum([J[k,j,i]*h[(k+N-1)%N][j] for k in range(3)])
      
      priorities[i*N+j][0] = total_J + priority_spin
      priorities[i*N+j][1] = -2*priority_spin
  return(priorities)




#score: {'data2D.txt': -0.006601388888888889}
#island_id: 0
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        continue
      priority_total[0] += J[k,i//N,neighbor]
      if k==3:
        priority_total[1] -= 2*J[k,i//N,neighbor]
      else:
        priority_total[1] -= J[k,i//N,neighbor]

    priorities[i][0] = np.sum([x for x in priority_total]) 
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.006601388888888889}
#island_id: 0
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = [h[site_nbr][i%N], 1]
    else:
      total_spin = [-h[site_nbr][i%N], -1]

    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        continue
      total_spin[0] += J[k,i//N,neighbor]
      if k==3:
        total_spin[1] -= 2*J[k,i//N,neighbor]
      else:
        total_spin[1] -= J[k,i//N,neighbor]

    priorities[i][0] = np.sum([x for x in total_spin]) 
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009486111111111113}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,site_nbr,i%N] * h[site_nbr][k%N] for k in range(3))
    total_spin = sum(h[site_nbr][j] for j in range(N))
    if total_spin > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= nn_energy + total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += nn_energy - total_spin
  return(priorities)




#score: {'data2D.txt': 0.0007695987654320986}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][k%N] for k in range(3))
    total_spin = np.sum(h[site_nbr])
    priorities[i][0] += total_spin + nn_energy
    if h[site_nbr].mean() > 0:
      priorities[i][1] -= sum(J[k,i//N,i%N] for k in range(3)) - total_spin
    else:
      priorities[i][1] += sum(J[k,i//N,i%N] for k in range(3)) + total_spin
  return(priorities)




#score: {'data2D.txt': -0.017285648148148147}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][k%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= sum(J[k,i//N,i%N] for k in range(3))
    else:
      priorities[i][0] -= total_energy
      priorities[i][1] += sum(J[k,i//N,i%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009560185185185193}
#island_id: 3
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    priorities[i][0] = h_site + 2*total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 1
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin *= 2
    priorities[i][int(total_spin > 0)] = total_spin
  return priorities




#score: {'data2D.txt': -0.11210756172839519}
#island_id: 1
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism from neighboring sites
    neighbors_magnetism = np.sum(J[:,i//N,i%N]) if J[0,i//N,i%N] > 0 else -np.sum(J[:,i//N,i%N])
    
    # Adjust the priority based on the site's own magnetism and neighborhood interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [h[site_nbr][i%N] + neighbors_magnetism, -h[site_nbr][i%N] - neighbors_magnetism]
    else:
      priorities[i] = [-h[site_nbr][i%N] - neighbors_magnetism, h[site_nbr][i%N] + neighbors_magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.020854783950617285}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0028054012345679}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) / np.count_nonzero(nns)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) / np.count_nonzero(nns)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum([J[j,i//N,site_nbr] for j in range(3) if J[j,i//N,site_nbr] == h[site_nbr][i%N]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[j,i//N,site_nbr] for j in range(3) if J[j,i//N,site_nbr] == -h[site_nbr][i%N]])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00021157407407407447}
#island_id: 2
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1-2*h[i//N][i%N])*h_site + sum([J[k,i%N,i//N]*(2*h[(k+N-1)%N][i%N]-h[i//N][i%N]) for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.004781018518518519}
#island_id: 2
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i%N,i//N] for k in range(4)]
    
    if sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    priorities[i][0] = h_site + J[3,i//N,i//N]*h[(i+N-1)%N][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.013060648148148155}
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= 4.5 * total_spin
      priorities[i][1] += 3.5 * total_spin

    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
      priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': 0.013060648148148155}
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= 4.5 * total_spin
      priorities[i][1] += 3.5 * total_spin

    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
      priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0005992283950617288}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4.5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= 4.5 * total_spin
      priorities[i][1] += 3.5 * total_spin

    for k in range(2):
      site = (i % N + ((k)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1.5 * total_spin
      priorities[i][1] += 1.5 * total_spin
    else:
      priorities[i][0] += 1.5 * total_spin
      priorities[i][1] -= 1.5 * total_spin

  return(priorities)




#score: {'data2D.txt': -0.006148302469135804}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_energy = sum([J[j,i//N,site_nbr] * h[(site_nbr + j) % N][i%N] for j in range(4)])
    total_energy = h_site + nn_energy
    
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.015444290123456793}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): # consider all four nearest neighbors
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0] if J[2,i//N,site_nbr] > 0 else priorities[i][0]
 
  return(priorities)




#score: {'data2D.txt': 0.024441820987654326}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.07332854938271607}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -h_site
    priorities[i][1] = total_energy
  
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.05336157407407408}
#island_id: 2
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = sum([h[k][i%N] for k in range(N)])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = sum([-h[k][i%N] for k in range(N)])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 2
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03838842592592593}
#island_id: 2
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if J[0,i%N,i//N]>0 else -h[i//N][i%N]
    
    for k in range(3):
      total_spin += 2*J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.038235648148148144}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      if k == 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 1:
        total_energy += J[k,i//N,i%N] * h[(i+k+2)%N][i%N]
      else:
        total_energy += J[k,i//N,i%N] * h[(i+k-2)%N][i%N]
    if J[0,i//N,i%N] > 0:
      priorities[i][1] -= 1
    elif J[0,i//N,i%N] < 0:
      priorities[i][1] += 1
    if J[1,i//N,i%N] > 0:
      priorities[i][0] -= 1
    elif J[1,i//N,i%N] < 0:
      priorities[i][0] += 1
    if J[2,i//N,i%N] > 0:
      priorities[i][1] -= 1
    elif J[2,i//N,i%N] < 0:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.006466820987654321}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] 
    nn_sum = 0
    for k in range(3):
      if k == 0:
        nn_sum += J[k,i//N,i%N]
      elif k == 1:
        nn_sum -= J[k,i//N,i%N]
      else:
        nn_sum -= J[k,i//N,i%N]
    priorities[i][0] = total_energy + nn_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06877237654320988}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] 
    for k in range(3):
      if k == 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 1:
        total_energy += J[k,i//N,i%N] * h[(i+k+2)%N][i%N]
      else:
        total_energy += J[k,i//N,i%N] * h[(i+k-2)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -total_energy if np.sum(h==h[site_nbr][i%N]) % 2 == 0 else -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06877237654320988}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      if k == 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 1:
        total_energy += J[k,i//N,i%N] * h[(i+k+2)%N][i%N]
      else:
        total_energy += J[k,i//N,i%N] * h[(i+k-2)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([abs(h[site_nbr][j]) + abs(total_spin) for j in range(N)]) 
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([abs(h[site_nbr][j]) + abs(total_spin) for j in range(N)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -2.2685185185184587e-05}
#island_id: 3
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - site_spin
      priorities[i][1] = -priorities[i][0]

  # Additional optimization
  for i in range(N**2):
    if priorities[i].sum() > 0:
      priorities[i] = priorities[i]/np.linalg.norm(priorities[i])
    else:
      priorities[i] = -priorities[i]/np.linalg.norm(-priorities[i])

  return(priorities)




#score: {'data2D.txt': 0.001092746913580247}
#island_id: 3
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      site_spin = sum([J[k,i%N,(i+N-1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      site_spin = sum([J[k,i%N,(i+N-1)%N]*h[(k+N-1)%N][(i+1)%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0013041666666666661}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]*h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.022147376543209876}
#island_id: 0
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
      priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
      priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0010050925925925921}
#island_id: 0
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': 0.08241095679012357}
#island_id: 1
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((N-1) % 2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
    
  return(priorities)




#score: {'data2D.txt': -0.13255046296296322}
#island_id: 1
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism at the current site
    total_spin += h[i//N][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.049059104938271605}
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(3):  
      if (J[j,i%N,i//N] > 0) == h[site_nbr][j]:
        total_spin += J[j,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.02613996913580247}
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % N < N // 2:
      row_sum = sum(h[i//N])
      col_sum = sum(h[j][i%N] for j in range(N))
      if row_sum > 0:
        priorities[i][0] += h_site + site_spin
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    elif i % N >= N // 2:
      row_sum = sum(h[j][i//N] for j in range(N))
      col_sum = sum(h[i//N])
      if row_sum > 0:
        priorities[i][0] += h_site + site_spin
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    else:
      if i // N < N // 2:
        row_sum = sum(h[j][i//N] for j in range(N))
        col_sum = sum(h[i//N])
        if row_sum > 0:
          priorities[i][0] += h_site + site_spin
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
      else:
        row_sum = sum(h[i//N])
        col_sum = sum(h[j][i%N] for j in range(N))
        if row_sum > 0:
          priorities[i][0] += h_site + site_spin
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.010992746913580249}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    if sum([(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    J_sum = sum(J[k,i//N,i//N] for k in range(4))
    
    if J_sum > 0:
      priorities[i][0] = h_site + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0021504629629629634}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    if sum([J[k,i//N,i//N]*(-1)**((k+1)%2) for k in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    J_sum = sum(J[k,i//N,i//N] for k in [0,1,3])
    
    priorities[i][0] = h_site + J_sum*h[(i+N-1)%N][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.012550154320987656}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i//N][i%N] for k in range(4)]

    if sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    priorities[i][0] = h_site + J[3,i//N][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.18389675925925927}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i//N,i//N] for k in range(4)]

    # Calculate the interaction energy
    interaction_energy = sum([site_nbr_J[j]*(-1)**((j+1)%2)*site_nbr_h[j] for j in range(4)])

    # Calculate the magnetism at this site
    h_site = np.sum(h[i//N][i%N])

    priorities[i][0] = interaction_energy + h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009831018518518518}
#island_id: 0
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    if total_energy > 0:
      priorities[i][0] = total_energy
      priorities[i][1] = -priorities[i][0]
    else:
      site_nbr_opp = (i % N + ((i//N-1)%2)) % N
      total_energy_opposite = sum(J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] if J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_opp][i%N]
      priorities[i][0] = total_energy_opposite
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0013195987654320987}
#island_id: 0
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    for j in range(4):
      site_nbr_j = (i % N + ((i//N-1)%2 + (j-2)%2 - 1)) % N
      total_energy += sum(J[j,i//N,(site_nbr_j+(k-1)%2-N)%N] if J[j,i//N,(site_nbr_j+(k-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr_j+(k-1)%2-N)%N] for k in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j, i//N, (site_nbr+(j-1)%2-N)%N] * h[site_nbr][i%N] if J[j, i//N, (site_nbr+(j-1)%2-N)%N]>0 else -J[j, i//N, (site_nbr+(j-1)%2-N)%N] for j in range(4))
    priorities[i][0] = total_energy
    if sum(J[j, i//N, (site_nbr+(j-1)%2-N)%N] * h[site_nbr][i%N] if J[j, i//N, (site_nbr+(j-1)%2-N)%N]>0 else -J[j, i//N, (site_nbr+(j-1)%2-N)%N] for j in range(4)) > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00880324074074074}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.2888486111111106}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priority_total[i][0] += h_site + site_spin
      priority_total[i][1] -= (h_site + site_spin)
    else:
      priority_total[i][0] -= (h_site + site_spin)
      priority_total[i][1] += (h_site + site_spin)

  return(priority_total)




#score: {'data2D.txt': 0.33298719135802374}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004096759259259259}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.010761882716049383}
#island_id: 1
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum(J[1:,i//N,i%N]) + h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.05844490740740748}
#island_id: 1
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.0003239197530864195}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = sum(J[k,i//N,i%N]*h[(k+i)%4][i//N] for k in range(4))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = i // N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.007162808641975309}
#island_id: 2
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    if sum([J[k,i//N,i//N]*(-1)**((k+1)%2) for k in range(4)]) > 0:
      priorities[i][0] = np.mean(site_nbr_h)
    else:
      priorities[i][0] = -np.mean(site_nbr_h)

    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.003827623456790123}
#island_id: 2
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i%N,i//N] for k in range(4)]

    h_site = np.mean(site_nbr_h)
    J_sum = sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)])
    priorities[i][0] = h_site + J_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.004781018518518519}
#island_id: 2
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i%N,i//N] for k in range(4)]

    if sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    priorities[i][0] = h_site + J[3,i//N,i//N]*h[(i+N-1)%N][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018091049382716051}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i//N,i%N] for k in range(4)]

    h_site = np.mean(site_nbr_h)
    J_sum = sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)])
    priorities[i][0] = h_site + J_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.007365895061728397}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i%N,i//N] for k in range(4)]

    h_sum = np.sum(site_nbr_h)
    J_sum = sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)])

    if np.abs(h_sum + J_sum) > 0:
      priorities[i][0] = (h_sum + J_sum) / (2 * np.abs(h_sum + J_sum))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 0
      priorities[i][1] = 0

  return(priorities)




#score: {'data2D.txt': -0.007244907407407407}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    J_sum = sum([J[k,i//N,k-(k+1)%2]*(-1)**((k+1)%2) for k in range(4)])

    priorities[i][0] = np.sum(site_nbr_h) + J_sum
    if i % (N*N//10) == 0:
      print(f"Processed {i/N**2:.2f}% of the grid.")
  return(priorities)




#score: {'data2D.txt': 0.33304830246913486}
#island_id: 3
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]

  # Improve the algorithm by selecting the spin with lower energy
  for i in range(N**2):
    if priorities[i][1] < priorities[i][0]:
      priorities[i] = [priorities[i][0], -priorities[i][0]]

  return(priorities)




#score: {'data2D.txt': 0.33298719135802374}
#island_id: 3
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001034722222222222}
#island_id: 3
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]
  
  # Sort the priorities based on the absolute value of the first column
  priorities = priorities[np.argsort(np.abs(priorities[:,0]))]
  
  return(priorities)




#score: {'data2D.txt': 0.33275848765432}
#island_id: 3
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    sum_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + sum_spin - h_site
    else:
      priorities[i][0] = site_nbr + sum_spin + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return(total_spin)




#score: {'data2D.txt': 0.1286841049382718}
#island_id: 0
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0004603395061728403}
#island_id: 0
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0039322530864197534}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if J[3,i%N,i//N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22081990740740753}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_spin = h[site_nbr][i%N]

    # Counting the number of spins that are aligned with the current spin
    aligned_spins = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        aligned_spins += 1
      else:
        aligned_spins -= 1

    # Counting the number of spins that are anti-aligned with the current spin
    anti_aligned_spins = 0
    for k in range(4):
      if J[k,i%N,i//N] < 0:
        anti_aligned_spins += 1
      else:
        anti_aligned_spins -= 1

    # Calculating priorities based on the magnetism and site interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + aligned_spins, -total_spin - aligned_spins]
    else:
      priorities[i] = [-total_spin - aligned_spins, total_spin + anti_aligned_spins]

  return(priorities)




#score: {'data2D.txt': -0.0021128086419753083}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with nearest neighbors
    left_spin = J[0,i%N,i//N] if i%N > 0 else 0
    right_spin = J[2,i%N,i//N] if i%N < N-1 else 0
    up_spin = J[3,i//N,i%N] if i//N > 0 else 0
    down_spin = J[1,i//N,i%N] if i//N < N-1 else 0
    
    total_spin += left_spin + right_spin + up_spin + down_spin
    
    # Update priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16166496913580272}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] if J[k,i//N,i%N] > 0 else -h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total spin with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on site magnetism and total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.1652702160493829}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif (i+1)%N == N:
        total_spin -= 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif (i+1)%N == N:
        total_spin -= 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16575108024691382}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3-1)%2 - 1)) % N
    total_spin += h[site_nbr2][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16223996913580271}
#island_id: 1
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.02819490740740742}
#island_id: 1
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[2,i//N,(i+1)%N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]

    site_nbr4 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i//N,(i+1)%N] > 0:
      priorities[i][0] += h[site_nbr4][i%N]
      priorities[i][1] -= h[site_nbr4][i%N]
    else:
      priorities[i][0] -= h[site_nbr4][i%N]
      priorities[i][1] += h[site_nbr4][i%N]

  return(priorities)




#score: {'data2D.txt': -0.002760648148148148}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i%N,i//N] * (h[site_nbr][j] == h[i//N][i%N]) for j in range(3))
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.04509367283950617}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(3):  
      if (J[j,i%N,i//N] > 0) == h[site_nbr][j]:
        total_spin += J[j,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.19272330246913605}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += -site_nbr
      priorities[i][1] -= site_nbr + total_spin
    else:
      priorities[i][0] -= site_nbr + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N][i%N] += 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      total_spin[i//N][i%N] -= 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priority_total[i][1] -= sum_spin
    else:
      priority_total[i][1] += sum_spin
  
  return priority_total




#score: {'data2D.txt': 0.33275848765432}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    sum_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + sum_spin - h_site
    else:
      priorities[i][0] = site_nbr + sum_spin + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.33275848765432}
#island_id: 3
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - h_site
    else:
      priorities[i][0] = site_nbr + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.005568055555555555}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    spin_energy = majority_spin * np.sum([h[s][i%N] - J_sum/len(site_nbrs) for s in site_nbrs])
    
    priorities[i][0] = spin_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.002316203703703703}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,k]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0035881172839506174}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    total_spin = np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))])
    J_sum = sum([(J[k,i//N,i//N]-total_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = total_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.06506311728395062}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total energy
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    
    # Determine the priority based on the total energy and magnetism
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      # Determine the priority based on the magnetism
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = -1
        priorities[i][1] = 1
  
  return(priorities)




#score: {'data2D.txt': 0.07818564814814814}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      prev_spin = 0
      if i > 0:
        prev_spin = priorities[(i-1)//N*N + (i-1)%N][0]
      total_priority = -prev_spin
      if np.random.rand() < 0.5:  # assign random spin
        if np.random.rand() < 0.5:  # choose direction
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = 1
          priorities[i][1] = -1
      else:  # flip the previous spin
        if prev_spin == -1 and np.random.rand() < 0.5:
          priorities[i][0] = 1
          priorities[i][1] = -1
        elif prev_spin == 1 and np.random.rand() < 0.5:
          priorities[i][0] = -1
          priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.0022109567901234563}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j = (k+i-N)//N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0027449074074074077}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j = (k+i-N)//N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    priorities[i][1] = -total_spin
    priorities[i][0] = -priorities[i][1]
  return(priorities)




#score: {'data2D.txt': 0.33298719135802374}
#island_id: 3
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3333128086419744}
#island_id: 3
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + total_spin
    else:
      priorities[i][0] = site_nbr + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.3332535493827151}
#island_id: 3
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin_sum
    else:
      priorities[i][0] = site_nbr + site_spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0001757716049382716}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    h_site = np.mean([(-1)**((j+1)%2)*site_nbr_h[j] for j in range(4)])
    if sum(J[k,i//N,i//N]*(-1)**((k+1)%2) for k in range(4)) > 0:
      J_site = np.mean([J[k,i//N,i//N]*(-1)**((k+1)%2) for k in range(4)])
    else:
      J_site = -np.mean([J[k,i//N,i//N]*(-1)**((k+1)%2) for k in range(4)])

    priorities[i][0] = h_site + J_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.27600879629629593}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i%N,i//N] for k in range(4)]

    if sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    neighbors_spin_sum = sum([J[k,i%N,i//N]*-site_nbr_h[j] for k,j in zip(range(4),range(4))])
    priorities[i][0] = 2*h[i//N][i%N] + neighbors_spin_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002439351851851852}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    site_nbr_J = [J[k,i//N,i//N] for k in range(4)]

    if sum([site_nbr_J[j]*(-1)**((j+1)%2) for j in range(4)]) > 0:
      h_site = np.mean(site_nbr_h)
    else:
      h_site = -np.mean(site_nbr_h)

    total_spin = sum([J[k,i//N,i//N]*h[(i+N-1-k)%N][j] for k,j in zip(range(4),range(N))])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00021157407407407447}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1-2*h[i//N][i%N])*h_site + sum([J[k,i%N,i//N]*(2*h[(k+N-1)%N][i%N]-h[i//N][i%N]) for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00011898148148148213}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1-2*h[i//N][i%N])*h_site + sum([J[k,i//N,i//N]*(2*h[(k+N-1)%N][i%N]-h[i//N][i%N]) for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009535493827160498}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1-2*h[i//N][i%N])*h_site + sum([J[k,i%N,i//N]*(2*h[(k+N-1)%N][i%N]-h[i//N][i%N]) for k in range(3)])
    if i % N > 0:
      priorities[i][0] -= J[0, i%N-1, i//N]*h[(i//N-1)%N][(i%N-1)]
    if i // N < N - 1:
      priorities[i][0] -= J[0, i%N, (i//N+1)%N]*h[(i//N+1)%N][i%N]
    if i % N > 0 and i % N < N-1:
      priorities[i][0] -= J[0, i%N-1, i//N]*h[(i//N-1)%N][(i%N-1)] + J[0, i%N+1, i//N]*h[(i//N+1)%N][i%N+1]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0004461419753086423}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*(h[(k+N-1)%N][i%N]-h[site_nbr][i%N]) for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = (2*h[i//N][i%N])*h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(2*h[i//N][i%N])*h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002056327160493827}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (1-2*h[i//N][i%N])*h_site + sum([J[k,i%N,i//N]*(2*h[(k+N-1)%N][i%N]-h[i//N][i%N]) for k in range(3)])
    neighbors = [j for j in range(N) if (abs(i % N - j) == 1 or (i % N + j) % N == 0)]
    for neighbor in neighbors:
      priorities[i][0] += J[1,i//N,neighbor]*(2*h[site_nbr][neighbor]-h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0019365740740740747}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h_site = (1-2*h[i//N][i%N])*h_site
    for k in range(3):
      total_h_site += 2*h[(k+N-1)%N][i%N]*J[k,i%N,i//N]
    
    priorities[i][0] = total_h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004271141975308644}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_up = J[0,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    right_down = J[2,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    priorities[i][0] = (1-2*h[i//N][i%N])*h[site_nbr][i%N] + left_up + right_down
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001990586419753087}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.00031249999999999984}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = np.arange(N**2)
  site_nbr = (site_nbr % N + ((site_nbr // N - 1) % 2 - 1)) % N
  row_idx = site_nbr // N
  col_idx = site_nbr % N
  
  total_spin = h[row_idx, col_idx].copy()
  
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      total_spin[i] += 1
      total_spin -= 2
    else:
      total_spin[i] -= 1
      total_spin[i] += 2
  
  priorities = np.stack((total_spin, -total_spin), axis=1)
  
  return(priorities)




#score: {'data2D.txt': -0.14344675925925945}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(-total_spin, 0)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = min(total_spin, 0)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = [h[(k+N-1)%N][i%N] for k in range(3)]
    total_interaction = sum([J[k,i%N,i//N]*n for k,n in enumerate(neighbors_spin)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_interaction
      priorities[i][1] = 1 - total_interaction
    else:
      priorities[i][0] = total_interaction
      priorities[i][1] = 1 + total_interaction

  return(priorities)




#score: {'data2D.txt': -0.0014837962962962966}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin_up = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      total_spin_down = sum([J[k,i//N,i%N]*(-h[(k+N-1)%N][i%N]) for k in range(3)])
      priorities[i][0] = total_spin_up
      priorities[i][1] = -total_spin_up - total_spin_down
    else:
      total_spin_up = sum([J[k,i//N,i%N]*(-h[(k+N-1)%N][i%N]) for k in range(3)])
      total_spin_down = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -total_spin_up
      priorities[i][1] = -priorities[i][0] - total_spin_down

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = site_nbr + site_spin - np.sum(np.abs(J[:,i//N,i//N]))
      priorities[i][1] = site_nbr + site_spin - np.sum(np.abs(J[:,i//N,i//N]))
    else:
      priorities[i][0] = site_nbr + site_spin + np.sum(np.abs(J[:,i//N,i//N]))
      priorities[i][1] = site_nbr + site_spin + np.sum(np.abs(J[:,i//N,i//N]))
  return(priorities)




#score: {'data2D.txt': 0.009231635802469135}
#island_id: 3
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,(i+N-1)%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + total_spin - sum(h[site_nbr])
    else:
      priorities[i][0] = site_nbr + total_spin + sum(h[site_nbr])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0010057098765432098}
#island_id: 0
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nns.append(h[site_nbr][nn_site])
      else:
        nns.append(-h[site_nbr][nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0018631172839506179}
#island_id: 0
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
     nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03838842592592593}
#island_id: 2
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if J[0,i%N,i//N]>0 else -h[i//N][i%N]
    
    for k in range(3):
      total_spin += 2*J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03838842592592593}
#island_id: 2
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if J[0,i%N,i//N]>0 else -h[i//N][i%N]
    
    for k in range(3):
      total_spin += 2*J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0] if np.sum(priorities[:i]) <= i else 1-priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03267608024691358}
#island_id: 2
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if J[0,i%N,i//N]>0 else -h[i//N][i%N]
    
    for k in range(3):
      total_spin += 2*J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    
    priorities[i][0] = h_site + total_spin
    if J[0,i%N,i//N]>0:
     priorities[i][1] = -priorities[i][0]+1
    else:
     priorities[i][1] = -priorities[i][0]-1

  return(priorities)




#score: {'data2D.txt': -0.007472376543209877}
#island_id: 2
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_up = J[0,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    right_down = J[2,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    up_left = J[3,(i//N)%N,i%N]*(h[i//N][site_nbr] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    down_right = J[3,(i//N)%N,i%N]*(h[i//N][site_nbr] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    priorities[i][0] = (1-2*h[i//N][i%N])*h[site_nbr][i%N] + left_up + right_down + up_left + down_right
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0041841049382716055}
#island_id: 2
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_up = J[0,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    right_down = J[2,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    up = J[1,i//N,(i+1)%N]*(h[i//N][i%N] - h[(i//N-1)%N][(i+1)%N]) if i < N and (i+1) % N != 0 else 0
    down = J[3,i//N,(i-1)%N]*(h[i//N][i%N] - h[(i//N+1)%N][(i-1)%N]) if i > 0 and (i-1) % N == N-1 else 0
    priorities[i][0] = (1-2*h[i//N][i%N])*h[site_nbr][i%N] + left_up + right_down + up + down
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.003195216049382717}
#island_id: 2
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_up = J[0,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    right_down = J[2,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    left = J[1,i%N,i//N]*(h[site_nbr][i%N] - h[i//N,(i-1)%N]) if i > 0 else 0
    right = J[3,i%N,i//N]*(h[site_nbr][i%N] - h[(i+1)//N,(i+1)%N]) if i < N**2-1 else 0
    priorities[i][0] = (1-2*h[i//N][i%N])*h[site_nbr][i%N] + left_up + right_down + left + right
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.02484645061728395}
#island_id: 2
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_up = J[0,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N-1)%N][(i+1)%N]) if i > 0 and i % N != 0 else 0
    right_down = J[2,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N+1)%N][(i+1)%N]) if i < N**2-1 and (i+1) % N == 0 else 0
    up = J[3,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N)%N][i%N]) if i % N != 0 else 0
    down = J[1,i%N,i//N]*(h[site_nbr][i%N] - h[(i//N)%N][(i+1)%N]) if (i+1) % N == 0 else 0
    priorities[i][0] = (1-2*h[i//N][i%N])*h[site_nbr][i%N] + left_up + right_down + up + down
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209706790123474}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    total_energy = site_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      total_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00141929012345679}
#island_id: 2
#version_generated: 2
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    if i % N == 0:
      priorities[i][1] = -priorities[i][0]
    elif (i % N) % 2 == 0:
      priorities[i][1] = priorities[(i-1)//N*N+(i%N)-1][1]
    else:
      priorities[i][1] = -priorities[(i-1)//N*N+(i%N)-1][1]
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.006281944444444445}
#island_id: 2
#version_generated: 2
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  # Add a term based on the magnetism at each site
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] += majority_spin
    priorities[i][1] -= majority_spin
  
  return(priorities)




#score: {'data2D.txt': 0.14444151234567923}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum([J[j,i//N,i//N] for j in range(4)])
      priorities[i][1] = -total_spin + sum([J[j,i//N,i//N] for j in range(4)])
    else:
      priorities[i][0] = -total_spin + sum([J[j,i//N,i//N] for j in range(4)])
      priorities[i][1] = total_spin - sum([J[j,i//N,i//N] for j in range(4)])
    
  return(priorities)




#score: {'data2D.txt': 0.060170216049382746}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_val = h[site_nbr1][i%N]
    else:
      h_val = -h[site_nbr1][i%N]

    priorities[i][0] += h_val
    priorities[i][1] -= h_val

    if J[1,i%N,i//N] > 0:
      h_val = h[site_nbr2][i%N]
    else:
      h_val = -h[site_nbr2][i%N]

    priorities[i][0] += h_val
    priorities[i][1] -= h_val

    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N-1)%2 - 1)) % N

    if J[2,i%N,i//N] > 0:
      h_val = h[site_nbr3][i%N]
    else:
      h_val = -h[site_nbr3][i%N]

    priorities[i][0] += h_val
    priorities[i][1] -= h_val

    if J[3,i//N,i%N] > 0:
      h_val = h[i//N][i%N]
    else:
      h_val = -h[i//N][i%N]

    priorities[i][0] += h_val
    priorities[i][1] -= h_val

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with the four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priority based on magnetism and interaction strength
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0002964506172839509}
#island_id: 0
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.012510030864197531}
#island_id: 0
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  # Calculate total spin at each site
  total_spin = np.sum(h, axis=1)

  # Calculate priority for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.sum(J[:, i//N, i%N]) * total_spin[site_nbr]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum(J[:, i//N, i%N]) * total_spin[site_nbr]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00020910493827160453}
#island_id: 0
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 3
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = (1 - h_site) * site_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = (-1 - h_site) * site_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0017526234567901264}
#island_id: 3
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum(h[site_nbr])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum(h[site_nbr])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.20933163580246913}
#island_id: 3
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_energy = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_energy[i][0] += h[site_nbr][i%N]
      total_energy[i][1] -= 1
    else:
      total_energy[i][0] -= h[site_nbr][i%N]
      total_energy[i][1] += 1
    for j in range(3):
      if J[j,i//N,i%N] > 0:
        total_energy[i][0] += J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
        total_energy[i][1] -= 2
      else:
        total_energy[i][0] -= J[j,i//N,i%N]*h[(j+N-1)%N][i%N]
        total_energy[i][1] += 2
  return(total_energy)




#score: {'data2D.txt': 0.33298719135802374}
#island_id: 3
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Compute the priority values
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h_site
    else:
      priorities[i][0] = site_nbr + site_spin + h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.33286249999999906}
#island_id: 3
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h[site_nbr][i%N]
    else:
      site_spin = sum([J[k,i%N,i//N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = site_nbr + site_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.2954896604938265}
#island_id: 3
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = np.sum([J[k, i%N, (i//N)%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
  return priorities




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.14101805555555574}
#island_id: 0
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = sum(J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] if J[j,i//N,(i%N + ((j-1)%2 - 1)) % N]>0 else -J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] for j in range(4))
    total_spin *= h[(i%N + ((i//N-1)%2 - 1)) % N][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.327130401234567}
#island_id: 3
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h[site_nbr][i%N]
    else:
      site_spin = sum([J[k,i%N,i//N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = site_nbr + site_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    # add magnetic term
    priorities[i][0] += 2*h[site_nbr][i%N]
    priorities[i][1] -= 2*h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.3324680555555546}
#island_id: 3
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      site_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h[site_nbr][i%N]
    else:
      site_spin = sum([J[k,i//N,i%N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = site_nbr + site_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.33286249999999906}
#island_id: 3
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      site_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -site_nbr
      priorities[i][1] = site_nbr + site_spin - h[site_nbr][i%N]
    else:
      site_spin = sum([J[k,i%N,i//N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = site_nbr + site_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.004275771604938272}
#island_id: 1
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr_col = i // N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr_row][j]
        priorities[i][1] -= h[site_nbr_row][j]
      else:
        priorities[i][0] -= h[site_nbr_row][j]
        priorities[i][1] += h[site_nbr_row][j]
    
    site_nbr_diag = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.06870509259259265}
#island_id: 1
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(N):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[3,i%N,k] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.09802021604938273}
#island_id: 0
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for k in [-1, 0, 1]:
        x = i+k*N
        y = (i%N)+k
        if 0 <= x < N**2 and 0 <= y < N:
          priorities[i][0] += J[abs(k),i//N,x%N]
          priorities[i][1] -= J[abs(k),i//N,x%N]
  return(priorities)




#score: {'data2D.txt': 0.13934027777777777}
#island_id: 0
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_energy = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy += h[site_nbr][i%N]
    for k in [-1, 0, 1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.005249228395061728}
#island_id: 0
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_energy = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy += h[site_nbr][i%N]
    for k in [-1, 0, 1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    total_neighbor_energy = 0
    for k in [-1, 0, 1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_neighbor_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    if total_energy > 0:
      priorities[i][0] = total_neighbor_energy + total_energy
      priorities[i][1] = -total_energy
    elif total_energy < 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = total_energy + total_neighbor_energy
    else:
      if total_neighbor_energy > 0:
        priorities[i][0] = total_neighbor_energy
        priorities[i][1] = -total_neighbor_energy
      elif total_neighbor_energy < 0:
        priorities[i][0] = -total_neighbor_energy
        priorities[i][1] = total_neighbor_energy
      else:
        if np.random.rand() > 0.5:
          priorities[i][0] = total_energy
          priorities[i][1] = -total_energy
        else:
          priorities[i][0] = -total_energy
          priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.08212885802469137}
#island_id: 0
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': -0.008025462962962963}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    spin_up_energy = np.sum([h[s][i%N] + (-1)**((j+1)%2) * J[k,i//N,i//N] for s,k,j in zip(site_nbrs,range(4),range(4))])
    spin_down_energy = np.sum([h[s][i%N] + 1**((j+1)%2) * J[k,i//N,i//N] for s,k,j in zip(site_nbrs,range(4),range(4))])
    
    priorities[i][0] = spin_up_energy - spin_down_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0030263888888888892}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    majority_h = np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))])
    if majority_h > 0:
      J_sum += majority_spin
    else:
      J_sum -= majority_spin
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    if i % (N*N//10) == 0:
      print(f"Processed {i/N**2:.2%} of the grid.")
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.03701188271604938}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.004359413580246913}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.025800771604938277}
#island_id: 2
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.005815586419753086}
#island_id: 2
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    if i % (N*N/N) == 0:
      priorities[i][0] += h.flatten()[i]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.03701188271604938}
#island_id: 2
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site and its neighbors
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.1635760802469138}
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-i%2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.1958072530864199}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if np.sum(h[site_nbrs]) == 0:
      priorities[i][0] = majority_spin + J_sum
    else:
      priorities[i][0] = (np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))])) + np.sign(h.flatten()[i]) )/2
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005815586419753086}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    if i % (N*N/N) == 0:
      priorities[i][0] += h.flatten()[i]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0008374999999999999}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    if i % (N*N/N) == 0:
      priorities[i][0] += h.flatten()[i]
    priorities[i][1] = -priorities[i][0]
  
  # Sort the sites based on their priorities and return
  sorted_indices = np.argsort(priorities[:, 0])
  return(priorities[sorted_indices, :])




#score: {'data2D.txt': -0.005815586419753086}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    if i % (N*N/N) == 0:
      priorities[i][0] += h.flatten()[i]
    priorities[i][1] = -priorities[i][0] * N
  return(priorities)




#score: {'data2D.txt': 0.1156964506172841}
#island_id: 1
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.11174706790123468}
#island_id: 1
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.09099583333333341}
#island_id: 0
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2 - (np.sum(nns) == 0)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
      if np.sum(nns) == 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.020854783950617285}
#island_id: 0
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.016537808641975307}
#island_id: 0
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4):
     if j == 0:
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     elif j == 1 or j == 3:
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     else:
      nn_site = site_nbr
     nns.append(J[j,i//N,site_nbr])
    
    if h[i//N][i%N] > 0:
     priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2
     priorities[i][1] = -priorities[i][0]
    else:
     priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
     priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0005248456790123459}
#island_id: 0
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      site = (i % N + (k)%2 - 1) % N
      total_spin += J[k, i//N, i%N] * h[site][i%N]
    
    if np.sum(h[i//N]) > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.00019367283950617347}
#island_id: 0
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin of the current site
    total_spin = h[site_nbr][i%N] * np.sum(J[:,i//N,i%N])
    
    # Update priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Update priorities based on interactions with nearest neighbors
    for k in range(2):
      site = (i % N + ((k)%2 - 1)) % N
      
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += np.sum(J[:,i//N,site])
        priorities[i][1] -= 2*np.sum(J[:,i//N,site])
      else:
        priorities[i][0] -= np.sum(J[:,i//N,site])
        priorities[i][1] += 2*np.sum(J[:,i//N,site])
  
  return(priorities)




#score: {'data2D.txt': -0.0021115740740740743}
#island_id: 0
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] += np.sum(J[:,i//N,site])
       priorities[i][1] -= 2*np.sum(J[:,i//N,site])
     else:
       priorities[i][0] -= np.sum(J[:,i//N,site])
       priorities[i][1] += 2*np.sum(J[:,i//N,site])
  
  return(priorities)




#score: {'data2D.txt': 0.014265277777777778}
#island_id: 0
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin + sum(J[k,i//N,i%N] for k in range(2) if k != site_nbr)
      priorities[i][1] -= total_spin - 2*sum(J[k,i//N,i%N] for k in range(2) if k != site_nbr)
    else:
      priorities[i][0] -= total_spin + sum(J[k,i//N,i%N] for k in range(2) if k != site_nbr)
      priorities[i][1] += total_spin - 2*sum(J[k,i//N,i%N] for k in range(2) if k != site_nbr)
  
  return(priorities)




#score: {'data2D.txt': -0.03701188271604938}
#island_id: 2
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site and its neighbors
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.0016989197530864204}
#island_id: 2
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the priority based on the site's magnetism and its neighbors' magnetism
    priorities[i][0] = majority_spin * np.sum([h[s][i%N] for s in site_nbrs]) + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.03701188271604938}
#island_id: 2
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    # Calculate the majority spin
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    
    # Calculate J_sum
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Assign priorities based on the majority spin and J_sum
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  # Add a term to the priority based on the magnetism at the site and its neighbors
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.003402932098765432}
#island_id: 2
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site and its neighbors
  site_nbr_h.extend(h.flatten())
  priorities[:, 0] += np.convolve(site_nbr_h, [-1,1], mode='valid')[:N*N]
  
  return(priorities)




#score: {'data2D.txt': 0.1286841049382718}
#island_id: 0
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1286841049382718}
#island_id: 0
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.15001774691358044}
#island_id: 0
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j//3,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0007433641975308639}
#island_id: 0
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if k == 0:
        nn_site = (site_nbr + ((k-1)%2 - 1)) % N
      elif k == 1 or k == 3:
        nn_site = (site_nbr + (k-1)) % N
      else:
        nn_site = (site_nbr + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[nn_site][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0006270061728395062}
#island_id: 2
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the priority based on the site's magnetism and its neighbors' magnetism
    if np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]) > 0:
      priorities[i][0] = majority_spin * np.sum([h[s][i%N] for s in site_nbrs]) + J_sum
    else:
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.005818981481481482}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    
    # Calculate the priority based on the site's magnetism and its neighbors' magnetism
    priorities[i][0] = majority_spin * np.sum([abs(h[s][i%N]) for s in site_nbrs])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.00034120370370370343}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the priority based on the site's magnetism and its neighbors' magnetism
    priorities[i][0] = np.sum([h[s][i%N] * (-1)**((j+1)%2) for s,j in zip(site_nbrs,range(4))]) + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0002680555555555553}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the priority based on the site's magnetism and its neighbors' magnetism
    priorities[i][0] = majority_spin * np.sum([h[s][i%N] for s in site_nbrs]) + J_sum + np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0007273148148148143}
#island_id: 3
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = (1+h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(1-h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002545833333333333}
#island_id: 2
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Add a term to the priority based on the magnetism at the site
    priorities[i][0] = majority_spin + J_sum + h[i%N][i//N]
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.025800771604938277}
#island_id: 2
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.02154398148148148}
#island_id: 2
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin == 1:
      spin = 1
    else:
      spin = -1
    
    priorities[i][0] = J_sum + spin * np.sum([h[s][i//N] for s in site_nbrs])
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.025800771604938277}
#island_id: 2
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': 0.0006035493827160492}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.1369729938271607}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin_neighbor = np.sum(J[:,i//N,i//N],axis=0)
    total_spin += total_spin_neighbor
    priorities[i][0] = -total_spin if h[i//N][i%N] > 0 else total_spin
    priorities[i][1] = total_spin if h[i//N][i%N] > 0 else -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.11253009259259272}
#island_id: 1
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N

    total_spin = h[site_nbr_row][site_nbr_col]

    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr_row = (i % N + ((k-1)%2 - 1)) % N
      if J[k, i%N, i//N] > 0:
        priorities[i][0] += h[site_nbr_row][i%N]
        priorities[i][1] -= h[site_nbr_row][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row][i%N]
        priorities[i][1] += h[site_nbr_row][i%N]

    for j in range(N):
      site_nbr_col = (i % N + ((j-1)%2 - 1)) % N
      if J[3, i%N, j] > 0:
        priorities[i][0] += h[site_nbr_col][j]
        priorities[i][1] -= h[site_nbr_col][j]
      else:
        priorities[i][0] -= h[site_nbr_col][j]
        priorities[i][1] += h[site_nbr_col][j]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1587754629629632}
#island_id: 1
#version_generated: 2
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i-1)%N, (i+1)%N, (i+N)%N, (i-N)%N]
    for j in site_nbrs:
      if J[3,i%N,j] > 0:
        total_spin += h[j][i%N]
      else:
        total_spin -= h[j][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1
    
    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] += max(0, min(priorities[i][0], priority_sum)) * 2
    else:
      priorities[i][0] -= max(0, min(priorities[i][0], -priority_sum)) * 2

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_spin = 1 if i%N > 0 and J[0,(i-1)%N,i//N] > 0 else -1
    right_spin = 1 if (i+1)%N < N and J[0,(i+1)%N,i//N] > 0 else -1
    top_spin = 1 if i//N > 0 and J[3,i%N,(i-1)//N] > 0 else -1
    bottom_spin = 1 if (i+N-1)//N < N and J[3,i%N,(i+1)//N] > 0 else -1

    priority_sum = h_site + sum([spin for spin in [left_spin, right_spin, top_spin, bottom_spin]])
    
    priorities[i][0] = max(0, min(priorities[i][0], priority_sum))
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001005401234567901}
#island_id: 1
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site][i%N]
        priorities[i][1] -= h[site][i%N]
      else:
        priorities[i][0] -= h[site][i%N]
        priorities[i][1] += h[site][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1631075617283953}
#island_id: 1
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N

    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N

    if h[site_nbr_row][site_nbr_col] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  for i in range(N):
    site_nbr_row = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i,j] > 0:
        priorities[i*N+j][0] += h[site_nbr_row][j]
        priorities[i*N+j][1] -= h[site_nbr_row][j]
      else:
        priorities[i*N+j][0] -= h[site_nbr_row][j]
        priorities[i*N+j][1] += h[site_nbr_row][j]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.0009325617283950617}
#island_id: 2
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    J_sum = sum([(-1)**((j+1)%2) * (J[k,i//N,i//N]-h[s][i//N]) for s,k,j in zip(site_nbrs,range(4),range(4))])
    priorities[i][0] += J_sum
  return(priorities)




#score: {'data2D.txt': 0.08864521604938279}
#island_id: 2
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    # Calculate the majority spin
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    
    # Calculate J_sum and its absolute value
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    J_abs_sum = abs(J_sum)
    
    # Calculate the priority based on the majority spin, J_sum, and magnetism
    priorities[i][0] = (majority_spin + 0.5 * J_abs_sum - h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11741867283950631}
#island_id: 2
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    # Calculate the majority spin
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    
    # Calculate J_sum
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Assign priorities based on the majority spin and J_sum, taking into account the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][0] = majority_spin + J_sum - 1
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = majority_spin + J_sum + 1
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.002389043209876543}
#island_id: 2
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]

    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))

    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])

    # New idea: Use the absolute value of the magnetism at the site and its neighbors
    # to adjust the priority
    magnetism_sum = np.abs(h.flatten()[i])

    priorities[i][0] = majority_spin + J_sum - magnetism_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0119875}
#island_id: 1
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      for k in range(N):
        if (i % N + ((k-1)%2 - 1)) % N == k:
          total_spin += J[j,i%N,k]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0002989197530864198}
#island_id: 1
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      spin = h[site_nbr][i%N]
    elif J[0,i%N,i//N] < 0:
      spin = -h[site_nbr][i%N]
    else:
      spin = 0
    if h[i//N][i%N] > 0:
      priorities[i] = [spin, -spin]
    else:
      priorities[i] = [-spin, spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.22019274691358032}
#island_id: 1
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i // N + ((i % N - 1) % N)) * N + i % N
    total_spin2 = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin2 += 1
      else:
        total_spin2 -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin2, -total_spin - total_spin2]
    else:
      priorities[i] = [-total_spin - total_spin2, total_spin + total_spin2]
  
  return(priorities)




#score: {'data2D.txt': -0.08245910493827165}
#island_id: 1
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = total_spin + magnetism
    priorities[i][1] = -total_spin - magnetism
  
  return(priorities)




#score: {'data2D.txt': 0.015316820987654321}
#island_id: 0
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j][0] += 1.5 * np.sum(J[:,site,j])*h[site][j]
      priorities[i*N+j][1] -= 1.5 * np.sum(J[:,site,j])*h[site][j]
    else:
      priorities[i*N+j][0] -= 1.5 * np.sum(J[:,site,j])*h[site][j]
      priorities[i*N+j][1] += 1.5 * np.sum(J[:,site,j])*h[site][j]

  return(priorities)




#score: {'data2D.txt': 0.0713427469135803}
#island_id: 0
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * (np.sum(J[:,site_nbr,i%N]) - h[site_nbr][i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.003315277777777778}
#island_id: 0
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] * (np.sum(J[:,i//N,i%N]) + np.sum(J[:,site_nbr,i%N]))
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.003395524691358024}
#island_id: 0
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (total_spin + np.sum(J[:,site_nbr,i%N])) * 3.5
      priorities[i][1] -= 2.5 * (total_spin + np.sum(J[:,site_nbr,i%N]))
    else:
      priorities[i][0] -= (total_spin + np.sum(J[:,site_nbr,i%N])) * 3.5
      priorities[i][1] += 2.5 * (total_spin + np.sum(J[:,site_nbr,i%N]))

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += (np.sum(J[:,site_nbr,j]) + np.sum(J[:,i,j])) * h[i][j]
        priorities[i*N+j][1] -= 3.5 * (np.sum(J[:,site_nbr,j]) + np.sum(J[:,i,j])) * h[i][j]
      else:
        priorities[i*N+j][0] -= (np.sum(J[:,site_nbr,j]) + np.sum(J[:,i,j])) * h[i][j]
        priorities[i*N+j][1] += 2.5 * (np.sum(J[:,site_nbr,j]) + np.sum(J[:,i,j])) * h[i][j]

  return(priorities)




#score: {'data2D.txt': 0.1579479938271607}
#island_id: 1
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1, 2]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [3]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03065941358024692}
#island_id: 1
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = np.sum(h[i//N])
    interaction = np.sum(J[:, i//N, i%N])
    
    priorities[i][0] = total_spin + magnetism/2 - interaction/8
    priorities[i][1] = -total_spin - magnetism/2 - interaction/8
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the interaction with the nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # add the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Iterate over all neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Update priorities based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.07395509259259266}
#island_id: 1
#version_generated: 2
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11301435185185199}
#island_id: 1
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N+1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N+1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0024757716049382717}
#island_id: 2
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site and its interactions with neighbors
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    priority_total = np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))])
    
    priorities[i][0] += priority_total
    priorities[i][1] -= priority_total
  
  return(priorities)




#score: {'data2D.txt': -0.025800771604938277}
#island_id: 2
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
    # Add a term to the priority based on the magnetism at the site
    priorities[i][0] += h.flatten()[i//N*N+i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.025800771604938277}
#island_id: 2
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  priorities[:, 0] += h.flatten()
  
  return(priorities)




#score: {'data2D.txt': 0.001280092592592593}
#island_id: 2
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  # Add a term to the priority based on the magnetism at the site
  h_avg = np.sum(h)/N**2
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.03997546296296296}
#island_id: 3
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = (1+h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)]) + sum([J[j,(i+3)%N,i//N]*int(h[site_nbr][(i+3)%N]%N>0) for j in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(1-h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)]) + sum([J[j,(i+3)%N,i//N]*int(h[site_nbr][(i+3)%N]%N<0) for j in range(2)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.2330958333333333}
#island_id: 3
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)]) + (1+h_site)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)]) - (1-h_site)
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0017486111111111116}
#island_id: 3
#version_generated: 2
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,((i+N-1)//N)%N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([J[k,i%N,((i+N-1)//N)%N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0007273148148148143}
#island_id: 3
#version_generated: 2
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = (1+h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(1-h_site)*sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Compute total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Compute priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.08375848765432099}
#island_id: 1
#version_generated: 2
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = i // N
    total_spin = 0
    
    if J[0,i//N,i%N] > 0:
      total_spin += h[site_nbr1][i%N]
    else:
      total_spin -= h[site_nbr1][i%N]
    
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11366651234567914}
#island_id: 1
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,site_nbr_row,site_nbr_col] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr_row = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr_row][j]
        priorities[i][1] -= h[site_nbr_row][j]
      else:
        priorities[i][0] -= h[site_nbr_row][j]
        priorities[i][1] += h[site_nbr_row][j]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i//N]
        priorities[i][1] -= h[site_nbr][i//N]
      else:
        priorities[i][0] -= h[site_nbr][i//N]
        priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.15503503086419776}
#island_id: 1
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add contributions from four neighbors
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Add contribution from diagonal neighbor
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.02807330246913581}
#island_id: 1
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    if J[2,i//N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i//N]
      priorities[i][1] -= h[site_nbr1][i//N]
    else:
      priorities[i][0] -= h[site_nbr1][i//N]
      priorities[i][1] += h[site_nbr1][i//N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[(i+1)%N,i//N]
      priorities[i][1] -= h[(i+1)%N,i//N]
    else:
      priorities[i][0] -= h[(i+1)%N,i//N]
      priorities[i][1] += h[(i+1)%N,i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.0001254629629629636}
#island_id: 1
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin

    for j in range(N):
      site_nbr4 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr4][j]
        priorities[i][1] -= h[site_nbr4][j]
      else:
        priorities[i][0] -= h[site_nbr4][j]
        priorities[i][1] += h[site_nbr4][j]

  return(priorities)




#score: {'data2D.txt': 0.11533317901234581}
#island_id: 1
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.002315586419753086}
#island_id: 3
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]>0) for k in range(3)]) + sum([J[j,(i+3)%N,i//N]*int(h[site_nbr][(i+3)%N]%N>0) for j in range(2)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]<0) for k in range(3)]) + sum([J[j,(i+3)%N,i//N]*int(h[site_nbr][(i+3)%N]%N<0) for j in range(2)]))
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.07518595679012349}
#island_id: 1
#version_generated: 2
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

    # Add the priority based on the magnetism
    if total_spin > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    elif total_spin < 0:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 1
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.00325570987654321}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    total_energy = h_site + sum(nn_values)
    priority_total = np.array([total_energy, -total_energy])
    
    if i % 2 == 0:
      priorities[i] = priority_total
    else:
      priorities[i] = -priority_total
      
  return(priorities)




#score: {'data2D.txt': 0.007106635802469136}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    total_energy = h[site_nbr][i%N] + sum(nn_values)
    priority_total = np.array([total_energy, -total_energy])
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': -0.02594984567901235}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.025446759259259263}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N
    nn_site_right = (site_nbr + ((3)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N] + h[nn_site_right][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.03011095679012346}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.03011095679012346}
#island_id: 0
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001649228395061728}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_magnetism = h[site_nbr][i%N]
    
    priorities[i][0] = total_energy + total_magnetism
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009353858024691358}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_energy = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy[i][0] += sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    total_energy[i][1] -= 2*total_energy[i][0]
  return(total_energy)




#score: {'data2D.txt': -0.009831018518518518}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    if total_energy > 0:
      priorities[i][0] = total_energy
      priorities[i][1] = -priorities[i][0]
    else:
      site_nbr_opp = (i % N + ((i//N-1)%2)) % N
      total_energy_opposite = sum(J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] if J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_opp][i%N]
      priorities[i][0] = total_energy_opposite
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.010029783950617283}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_energy_plus = sum(J[j,i//N,(i % N + ((j-1)%2 - 1)) % N] if J[j,i//N,(i % N + ((j-1)%2 - 1)) % N]>0 else -J[j,i//N,(i % N + ((j-1)%2 - 1)) % N] for j in range(4)) * h[i%N][i//N]
    total_energy_minus = sum(J[j,i//N,(i % N + ((3-j)%2 - 1)) % N] if J[j,i//N,(i % N + ((3-j)%2 - 1)) % N]>0 else -J[j,i//N,(i % N + ((3-j)%2 - 1)) % N] for j in range(4)) * h[i%N][i//N]
    if total_energy_plus > total_energy_minus:
      priorities[i][0] = total_energy_plus
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_energy_minus
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0004797839506172836}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,(i%N+N)%N] * h[site_nbr][(i%N+N)%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_energy
      priorities[i][1] -= 2 - sum(J[k,i//N,(i%N+N)%N] for k in range(3))
    else:
      priorities[i][0] -= total_energy
      priorities[i][1] += 2 + sum(J[k,i//N,(i%N+N)%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': 0.08863688271604939}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,(i%N+N)%N] * h[site_nbr][(i%N+N)%N] for k in range(3))
    total_energy = nn_energy + h[site_nbr][i%N]
    priorities[i][0] += -total_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2 - sum(J[k,i//N,(i%N+N)%N] for k in range(3))
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,(i%N+N)%N] for k in range(3))
  return(priorities)




#score: {'data2D.txt': -0.012345524691358026}
#island_id: 0
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for k in range(4): 
      if k == 0:
        nn_energy = J[0,i//N,(i%N+N)%N] * h[site_nbr][(i%N+N)%N]
      elif k == 1:
        nn_energy = J[1,i//N,(i%N+N-1)%N] * h[site_nbr][(i%N+N-1)%N]
      elif k == 2:
        nn_energy = J[2,i//N,(i%N)] * h[site_nbr][i%N]
      else:
        nn_energy = J[3,i//N,(i%N+1)%N] * h[site_nbr][(i%N+1)%N]
      total_energy += nn_energy
    priorities[i][0] += total_energy + h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2 - sum(J[k,i//N,(i%N+N)%N] for k in range(4))
    else:
      priorities[i][1] += 2 + sum(J[k,i//N,(i%N+N)%N] for k in range(4))
  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.056755401234567925}
#island_id: 2
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    # Add the magnetism term
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.006281944444444445}
#island_id: 2
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i%N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    if sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) > 0:
      priorities[i][0] += np.sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    else:
      priorities[i][0] -= np.sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
  return(priorities)




#score: {'data2D.txt': 0.11192021604938285}
#island_id: 1
#version_generated: 2
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.00959675925925926}
#island_id: 3
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_k = (k + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h_site + J[k,i%N,i//N]*h[site_k][i%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h_site - J[k,i%N,i//N]*h[site_k][i%N]
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.0015094135802469141}
#island_id: 3
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      spin_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 3
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0012307098765432106}
#island_id: 3
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005568055555555556}
#island_id: 3
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Calculate the priority for each site based on its magnetism and interaction with neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= len([k for k in range(3) if J[k,i%N,i//N]>0])
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += len([k for k in range(3) if J[k,i%N,i//N]<0])

  return(priorities)




#score: {'data2D.txt': 0.0015094135802469141}
#island_id: 3
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      spin_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00645570987654321}
#island_id: 3
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = h[site_nbr][i%N] + total_spin
    priorities[i][1] = 1 if h[site_nbr][i%N] > 0 else -1

  return(priorities)




#score: {'data2D.txt': -0.007191820987654321}
#island_id: 3
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Add magnetism priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.0005390432098765438}
#island_id: 3
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
    else:
      spin_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum

  priorities[:,1] = -priorities[:,0]
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4):  
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = 2*h_site + total_energy

  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    
    # Add a term to account for the interactions with sites that are diagonally opposite
    diag_sites = [(site_nbr + (j-1)%2 - 1) % N for j in range(N)]
    diag_energies = [J[0, i//N, site] if J[0, i//N, site] > 0 else -J[0, i//N, site] 
             for site in diag_sites]
    
    total_energy += sum(diag_energies)
    
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = 2*h_site + total_energy

  return(priorities)




#score: {'data2D.txt': 0.004215277777777778}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = 2*h_site + total_energy

  # Add some new spin prioritization based on the site's interaction with its neighbors.
  for i in range(N**2):
    if J[0,i//N,(i%N)%N] > 0:
      priorities[i][0] += h[(i%N)%N][i//N]
    else:
      priorities[i][0] -= h[(i%N)%N][i//N]

  return(priorities)




#score: {'data2D.txt': 0.0071041666666666675}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns)
    priorities[i][0] = (2*h_site + total_energy) * np.exp(total_energy)
    priorities[i][1] = -(2*h_site + total_energy) * np.exp(-total_energy)

  return(priorities)




#score: {'data2D.txt': -0.052634413580246925}
#island_id: 2
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
    
    # Check for symmetry in J
    if i % N < 3:
      j_sum_left = sum([(J[k,i//N,(i+1)%N]-majority_spin*h[s][(i+1)%N])*(-1)**((k+1)%2) for k,s in zip(range(4),[s for s,k in enumerate(site_nbrs) if (k+1)%2 == 0])])
      j_sum_right = sum([(J[k,i//N,(i-1)%N]-majority_spin*h[s][(i-1)%N])*(-1)**((k+1)%2) for k,s in zip(range(4),[s for s,k in enumerate(site_nbrs) if (k+1)%2 == 1])])
      priorities[i][0] += j_sum_left - j_sum_right
      priorities[i][1] -= j_sum_left - j_sum_right
      
  return(priorities)




#score: {'data2D.txt': -0.056755401234567925}
#island_id: 2
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term, but only if it's not zero
    h_val = h[i//N][i%N]
    if h_val != 0:
      priorities[i][0] += h_val
      priorities[i][1] -= h_val
    
  return(priorities)




#score: {'data2D.txt': -0.053213117283950624}
#island_id: 2
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin > 0:
      priorities[i][0] = np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 1 - np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - J_sum
      priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.056755401234567925}
#island_id: 2
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00785138888888889}
#island_id: 3
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site_k = (k + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += total_spin[site_nbr*N+site_k][0] + J[k,i%N,i//N]*h[site_k][i%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= total_spin[site_nbr*N+site_k][0] - J[k,i%N,i//N]*h[site_k][i%N]
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.003974537037037037}
#island_id: 3
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(3):
      site_k = (k + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -1 if np.all([J[j, i%N, i//N]*h[site_k][i%N] for j in range(3)]) > 0 else 1

  return(priorities)




#score: {'data2D.txt': 0.11538441358024704}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.03160632716049383}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] if J[k,i//N,i%N] > 0 else -h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbrs))

    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0015748456790123453}
#island_id: 0
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1286841049382718}
#island_id: 0
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0033516975308641975}
#island_id: 0
#version_generated: 2
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1286841049382718}
#island_id: 0
#version_generated: 2
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N]*h[nn_site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.23876188271604928}
#island_id: 3
#version_generated: 2
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Calculate the priority for each site based on its magnetism and interaction with neighbors
  total_spin = np.zeros((N,N))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.005568055555555556}
#island_id: 3
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] += total_spin
      priorities[i][1] -= len([k for k in range(3) if J[k,i%N,i//N]>0])
    else:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] -= total_spin
      priorities[i][1] += len([k for k in range(3) if J[k,i%N,i//N]<0])

  return(priorities)




#score: {'data2D.txt': 0.00016620370370370357}
#island_id: 3
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Add magnetism priority and remove redundant computation
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][1] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': -0.007191820987654321}
#island_id: 3
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Add magnetism priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.007846450617283951}
#island_id: 3
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site
  total_spin = np.zeros(2)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  # Calculate spin-spin interactions for each site
  spin_spin_interactions = np.zeros(2)
  for i in range(N**2):
    total_spin[0] = 0
    total_spin[1] = 0
    for j in range(3):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin[0] += h[site_nbr][i%N]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin[0] -= h[site_nbr][i%N]
        priorities[i][0] -= 1
    
    if total_spin[0] > 0:
      priorities[i][1] -= 1
    elif total_spin[0] < 0:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.007191820987654321}
#island_id: 3
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Add magnetism priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.005568055555555556}
#island_id: 3
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,int(np.floor(i/N))]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[0,i%N,int(np.floor(i/N))]>0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N]>0:
      priorities[i][0] += sum([J[k,i%N,int(np.floor(i/N))]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= len([k for k in range(3) if J[k,i%N,int(np.floor(i/N))]>0])
    else:
      priorities[i][0] -= sum([J[k,i%N,int(np.floor(i/N))]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += len([k for k in range(3) if J[k,i%N,int(np.floor(i/N))]<0])
  
  return(priorities)




#score: {'data2D.txt': -0.005568055555555556}
#island_id: 3
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  # Calculate the priority for each site based on its magnetism and interaction with neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= len([k for k in range(3) if J[k,i%N,i//N]>0])
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] += len([k for k in range(3) if J[k,i%N,i//N]<0])

  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 3
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.05243842592592595}
#island_id: 2
#version_generated: 2
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
    
    # Check for symmetry in J
    if i % N < 3:
      j_sum_left = sum([(J[k,i//N,(i+1)%N]-majority_spin*h[s][(i+1)%N])*(-1)**((k+1)%2) for k,s in zip(range(4),[s for s,k in enumerate(site_nbrs) if (k+1)%2 == 0])])
      j_sum_right = sum([(J[k,i//N,(i-1)%N]-majority_spin*h[s][(i-1)%N])*(-1)**((k+1)%2) for k,s in zip(range(4),[s for s,k in enumerate(site_nbrs) if (k+1)%2 == 1])])
      priorities[i][0] += j_sum_left - j_sum_right
      priorities[i][1] -= j_sum_left - j_sum_right
    
    # Add the interaction with nearest neighbors
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if i < N:
      j_sum_up = J[0,i//N,i//N]
    else:
      j_sum_up = 0
      
    if i >= N*N-N:
      j_sum_down = J[3,i//N,i//N]
    else:
      j_sum_down = 0
    
    priorities[i][0] += j_sum_up + j_sum_down
    priorities[i][1] -= j_sum_up + j_sum_down
  
  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      if J[0,i%N,i//N] > 0:
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      if J[0,i%N,i//N] > 0:
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0018344135802469135}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum(h[k][i%N] for k in range(3))
    sum_Jh = sum(J[k,i%N,i//N]*h[k][i%N] for k in range(3))
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = sum_h + sum_Jh
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum_h - sum_Jh
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.060893055555555575}
#island_id: 2
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.056755401234567925}
#island_id: 2
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009831018518518518}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    if total_energy > 0:
      priorities[i][0] = total_energy
      priorities[i][1] = -priorities[i][0]
    else:
      site_nbr_opp = (i % N + ((i//N-1)%2)) % N
      total_energy_opposite = sum(J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] if J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_opp][i%N]
      priorities[i][0] = total_energy_opposite
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009353858024691358}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    total_energy_opposite = sum(J[j,i//N,(site_nbr+(3-j)%2-N)%N] if J[j,i//N,(site_nbr+(3-j)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(3-j)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + total_energy_opposite
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014276234567901236}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N] * h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      site_nbr_opp = (i % N + ((i//N-1)%2)) % N
      total_spin_opposite = 0
      for j in range(4):
        total_spin_opposite += J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] * h[site_nbr_opp][i%N]
      priorities[i][0] = total_spin_opposite
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00024490740740740706}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_nbr_opp = (i % N + ((i//N-1)%2)) % N
    total_energy_opposite = sum(J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] if J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr_opp+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_opp][i%N]
    priorities[i][0] = total_energy + total_energy_opposite
    if total_energy > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012307098765432106}
#island_id: 3
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum_h
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.009938734567901234}
#island_id: 3
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -sum([np.exp(-J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([np.exp(J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012307098765432106}
#island_id: 3
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0013084876543209881}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin == 1:
      priorities[i][0] = np.sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.0012350308641975313}
#island_id: 2
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
    if sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) > 0:
      priorities[i][0] += np.sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    else:
      priorities[i][0] -= np.sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
  return(priorities)




#score: {'data2D.txt': 0.002158179012345679}
#island_id: 2
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    majority_h = np.sign(np.sum([h[s][i//N] for s in site_nbrs]))
    J_sum += sum([(J[k,i//N,i//N]-majority_h*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.004302623456790124}
#island_id: 2
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if np.abs(J_sum) > 0.5:
      priorities[i][0] = majority_spin
      priorities[i][1] = -majority_spin
    else:
      site_nbr_h.sort()
      spin = np.sign(np.sum([h[s][i//N] for s in site_nbrs]))
      if np.mean(site_nbr_h) > 0.5:
        spin *= -1
      priorities[i][0] = spin
      priorities[i][1] = -spin
  
  return(priorities)




#score: {'data2D.txt': 0.002578549382716049}
#island_id: 2
#version_generated: 2
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    priorities[i][0] = majority_spin + J_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.000672067901234568}
#island_id: 0
#version_generated: 2
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    
    # Calculate the priority based on the number of neighbors with same spin
    nn_count = sum(n == h_site for n in nns)
    priorities[i][0] = J_up * (1 + 2*nn_count) - J_down * (1 - 2*nn_count)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011680555555555552}
#island_id: 0
#version_generated: 2
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = (1 + np.tanh(J_up * h_site + J_down * (-h_site))) / 2
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011680555555555552}
#island_id: 0
#version_generated: 2
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = (2*J_up*h_site + 2*J_down*(-h_site))/2
    priorities[i][1] = -(priorities[i][0])

  return(priorities)




#score: {'data2D.txt': -0.0013084876543209881}
#island_id: 2
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin == 1:
      priorities[i][0] = np.sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([(-1)**((j+1)%2) * site_nbr_h[j//2] for j in range(8)]) - J_sum
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.016677932098765433}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    priority_flip = np.where(total_energy + 2*nn_energy > 0, (total_energy + nn_energy) * N - 2*N, 
                 np.where(total_energy - 2*nn_energy > 0, -(total_energy - nn_energy) * N + 2*N, 
                      (total_energy + nn_energy) * N - 2*N if np.random.rand() < 0.5 else -(total_energy - nn_energy) * N + 2*N))
    priorities[i][0] = priority_flip
  return(priorities)




#score: {'data2D.txt': 0.04145293209876543}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    energy_diff = total_energy + 2*nn_energy
    if np.abs(energy_diff) > 1e-6:
      sign = -np.sign(energy_diff)
      priorities[i][0] += sign * (total_energy + nn_energy) * N
      priorities[i][1] -= 2*N * sign
    else:
      random_sign = np.random.choice([-1, 1])
      priorities[i][0] += random_sign * total_energy * N
      priorities[i][1] -= 2*N * random_sign
  return(priorities)




#score: {'data2D.txt': 0.016948919753086423}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += (total_energy + nn_energy) * N
      priorities[i][1] -= 2*N
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] -= (total_energy - nn_energy) * N
      priorities[i][1] += 2*N
    else:
      if np.random.rand() < 0.5:
        priorities[i][0] += (total_energy + nn_energy) * N
        priorities[i][1] -= 2*N
      else:
        priorities[i][0] -= (total_energy - nn_energy) * N
        priorities[i][1] += 2*N
  return(priorities)




#score: {'data2D.txt': 0.017002623456790125}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] += (total_energy + nn_energy) * N
      priorities[i][1] -= 2*N
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] -= (total_energy - nn_energy) * N
      priorities[i][1] += 2*N
    else:
      if np.random.rand() < 0.5:
        priorities[i][0] += (total_energy + nn_energy) * N
        priorities[i][1] -= 2*N
      else:
        priorities[i][0] -= (total_energy - nn_energy) * N
        priorities[i][1] += 2*N
  return(priorities)




#score: {'data2D.txt': 0.009967129629629628}
#island_id: 3
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -sum([np.exp(-2*J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([np.exp(2*J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.009967129629629628}
#island_id: 3
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -sum([np.exp(-2*J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([np.exp(2*J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += np.exp(J[k,i%N,i//N]) * (sum_h + 1)
        priorities[i][1] -= np.exp(J[k,i%N,i//N]) * (sum_h + 1)
      else:
        priorities[i][0] -= np.exp(-J[k,i%N,i//N]) * (sum_h - 1)
        priorities[i][1] += np.exp(-J[k,i%N,i//N]) * (sum_h - 1)

  return(priorities)




#score: {'data2D.txt': -0.044325154320987686}
#island_id: 3
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin[i][0] - sum([J[k,i%N,i//N] for k in range(3)]) + 1
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_spin[i][0] + sum([J[k,i%N,i//N] for k in range(3)]) - 1
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.060893055555555575}
#island_id: 2
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.060893055555555575}
#island_id: 2
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.047444290123456793}
#island_id: 2
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
    
    # Add the interaction with the four neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.018689351851851853}
#island_id: 2
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term and modify the priority based on the sum of J
    if np.sum(J[:, i//N, i//N]) > 0:
      priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = majority_spin - J_sum - dist_to_majority - h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004138425925925926}
#island_id: 3
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = h[site_nbr][i%N] + total_spin
    if i < N*N // 2:
      priorities[i][1] = -priorities[N*N-i-1][1]
    else:
      priorities[i][1] = -priorities[N*N-i-1][0]

  return(priorities)




#score: {'data2D.txt': -0.00026805555555555594}
#island_id: 3
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(np.multiply(J, h))
      priorities[i][1] = -np.ones_like(h)[site_nbr][i%N].sum()
    else:
      priorities[i][0] = -total_spin - np.sum(np.multiply(J, h))
      priorities[i][1] = 1 + np.ones_like(h)[site_nbr][i%N].sum()

  return(priorities)




#score: {'data2D.txt': -0.008916203703703702}
#island_id: 3
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin_down = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin_up
      priorities[i][1] = -1
    else:
      priorities[i][0] = total_spin_down
      priorities[i][1] = 1

  return(priorities)




#score: {'data2D.txt': -0.0025075617283950614}
#island_id: 3
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h[site_nbr][i%N] + total_spin
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= sum([J[k,i%N,i//N] for k in range(3)])
    else:
      priorities[i][1] += sum([J[k,i%N,i//N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.02248935185185185}
#island_id: 0
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    nn_spin = 0
    for d in [(1,0), (-1,0), (0,1), (0,-1)]:
      if i % N + d[0] >= N or i % N + d[0] < 0 or i // N + d[1] >= N or i // N + d[1] < 0:
        continue
      nn_spin += J[2,i//N+d[1],i%N+d[0]]

    priorities[i][0] = h[site_nbr][i%N] + energy_nn + nn_spin
    priorities[i][1] = -priorities[i][0] - 2*h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.018725154320987657}
#island_id: 0
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    for j in range(2):
      if J[j,i//N,i%N] > 0 and np.sign(h[site_nbr][i%N]) != np.sign(J[j,i//N,i%N]):
        priorities[i][j] = -energy_nn
      elif J[j,i//N,i%N] < 0 and np.sign(h[site_nbr][i%N]) == np.sign(J[j,i//N,i%N]):
        priorities[i][j] = energy_nn
      else:
        priorities[i][j] = h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.07971527777777779}
#island_id: 0
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = 0
    if J[0,i%N,i//N] > 0:
      energy_nn += h[i//N][i%N]
    else:
      energy_nn -= h[i//N][i%N]

    priorities[i][0] = (h[site_nbr][i%N] + energy_nn) / 2
    priorities[i][1] = -priorities[i][0] - J[1,i//N,i%N]
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    total_spin = np.sum(J[:,i//N,i//N]) * (sum_h if J[0,i//N,i//N] > 0 else -sum_h)
    priorities[i][0] += np.exp(total_spin) * (1 if sum_h > 0 else -1)
    priorities[i][1] -= np.exp(total_spin) * (1 if sum_h > 0 else -1)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for k in range(4):
      if k == 0:
        if J[k,i%N,i//N] > 0:
          priorities[i][0] += np.exp(J[k,i%N,i//N]) * (sum_h + 1)
          priorities[i][1] -= np.exp(J[k,i%N,i//N]) * (sum_h + 1)
        else:
          priorities[i][0] -= np.exp(-J[k,i%N,i//N]) * (sum_h - 1)
          priorities[i][1] += np.exp(-J[k,i%N,i//N]) * (sum_h - 1)
      elif k == 1:
        if J[k,i%N,(i//N+1)%N] > 0:
          priorities[i][0] += np.exp(J[k,i%N,(i//N+1)%N]) * (sum_h + 1)
          priorities[i][1] -= np.exp(J[k,i%N,(i//N+1)%N]) * (sum_h + 1)
        else:
          priorities[i][0] -= np.exp(-J[k,i%N,(i//N+1)%N]) * (sum_h - 1)
          priorities[i][1] += np.exp(-J[k,i%N,(i//N+1)%N]) * (sum_h - 1)
      elif k == 2:
        if J[k,i%(N-1),i//N] > 0:
          priorities[i][0] += np.exp(J[k,i%(N-1),i//N]) * (sum_h + 1)
          priorities[i][1] -= np.exp(J[k,i%(N-1),i//N]) * (sum_h + 1)
        else:
          priorities[i][0] -= np.exp(-J[k,i%(N-1),i//N]) * (sum_h - 1)
          priorities[i][1] += np.exp(-J[k,i%(N-1),i//N]) * (sum_h - 1)
      elif k == 3:
        if J[k,(i+1)%N,i//N] > 0:
          priorities[i][0] += np.exp(J[k,(i+1)%N,i//N]) * (sum_h + 1)
          priorities[i][1] -= np.exp(J[k,(i+1)%N,i//N]) * (sum_h + 1)
        else:
          priorities[i][0] -= np.exp(-J[k,(i+1)%N,i//N]) * (sum_h - 1)
          priorities[i][1] += np.exp(-J[k,(i+1)%N,i//N]) * (sum_h - 1)

  return(priorities)




#score: {'data2D.txt': -0.001486574074074074}
#island_id: 3
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    interaction_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        interaction_sum += J[k,i%N,i//N]
      else:
        interaction_sum -= J[k,i%N,i//N]
    priorities[i][0] = sum_h + interaction_sum
    priorities[i][1] = -sum_h - interaction_sum
  return(priorities)




#score: {'data2D.txt': 0.1580223765432101}
#island_id: 0
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    neighbors_energy = sum(J[j,i//N,((i+N-1)%N+(j-1)%2-N)%N] if J[j,i//N,((i+N-1)%N+(j-1)%2-N)%N]>0 else -J[j,i//N,((i+N-1)%N+(j-1)%2-N)%N] for j in range(4)) * h[(i+1)%N][i%N]
    priorities[i][0] = total_energy + site_energy + neighbors_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004372993827160495}
#island_id: 3
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum(h[k][i%N] for k in range(3))
    sum_Jh = sum(J[k,i%N,i//N]*h[k][i%N] for k in range(3))
    if J[0,i%N,i//N] > 0:
      priorities[i][1] = sum_h + sum_Jh
      priorities[i][0] = -priorities[i][1]
    else:
      priorities[i][1] = -sum_h - sum_Jh
      priorities[i][0] = -priorities[i][1]

  return(priorities)




#score: {'data2D.txt': -0.0014544753086419763}
#island_id: 3
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum(h[k][i%N] for k in range(3))
    J_sum = sum(J[k,i%N,i//N]*h[k][i%N] for k in range(3))
    if np.sum(h[site_nbr]) > 0:
      priorities[i][0] = sum_h + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum_h - J_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0007868827160493825}
#island_id: 3
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum(h[k][i%N] for k in range(3))
    J_sum = sum(J[k,i%N,i//N] for k in range(3))
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = (sum_h + J_sum) / abs(sum_h + J_sum)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(sum_h + J_sum) / abs(sum_h + J_sum)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013668209876543207}
#island_id: 2
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin > 0:
      priorities[i][0] = np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 1 - np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - J_sum
      priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term and use symmetry to reduce computation
    if i % (N*N // 2) < N:
      site_nbr_h = [h[s][i//N] for s in site_nbrs]
      J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
      if majority_spin > 0:
        priorities[i][0] += np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) + J_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = 1 - np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - J_sum
        priorities[i][1] = -priorities[i][0]
    
    return(priorities)




#score: {'data2D.txt': -0.053213117283950624}
#island_id: 2
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    if majority_spin > 0:
      priorities[i][0] = np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 1 - np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - J_sum
      priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism term
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.009938734567901234}
#island_id: 3
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = np.sum(h[i%N])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -sum([np.exp(-J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = sum([np.exp(J[k,i%N,i//N]) for k in range(3)]) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.exp(-sum([J[k,i%N,i//N] for k in range(3)])) + spin_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.exp(sum([J[k,i%N,i//N] for k in range(3)])) + spin_sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009476388888888888}
#island_id: 3
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    J_sum = sum([np.exp(-J[k,i%N,i//N]) for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_sum_h + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = spin_sum_h - J_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14794490740740765}
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N) % N
    total_spin = h[site_nbr1][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr1][i//N]
      total_spin -= h[i//N][i%N]
    else:
      total_spin -= h[site_nbr1][i//N]
      total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.3287239197530855}
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_list = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in range(4):
      site_nbr = site_nbr_list[k]
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16587175925925948}
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0015668209876543214}
#island_id: 3
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    J_sum = sum([np.exp(-J[k,i%N,i//N]) for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_sum_h + J_sum
      priorities[i][1] = np.log(np.sum(np.exp(priorities[i])))
    else:
      priorities[i][0] = spin_sum_h - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009476388888888888}
#island_id: 3
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    J_sum = sum([np.exp(-J[k,i%N,i//N]) for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_sum_h + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = spin_sum_h - J_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.008204475308641974}
#island_id: 3
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    J_sum = sum([np.exp(-J[k,i%N,i//N]) for k in range(3)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_sum_h + J_sum
      priorities[i][1] = np.exp(spin_sum_h) / (np.exp(spin_sum_h) + np.exp(-J_sum))
    else:
      priorities[i][0] = spin_sum_h - J_sum
      priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009337808641975308}
#island_id: 3
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    J_sum = sum([np.exp(-J[k,i%N,i//N]) for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -spin_sum_h + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = spin_sum_h - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.000535030864197531}
#island_id: 1
#version_generated: 2
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if J[3,i//N,j] > 0:
      if priorities[i][0] < priorities[i][1]:
        priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
    else:
      if priorities[i][0] > priorities[i][1]:
        priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.03298533950617285}
#island_id: 1
#version_generated: 2
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    priority = np.array([-magnetism, magnetism]) + np.array([total_spin, -total_spin])
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priority[0] += h[site_nbr][i%N]
        priority[1] -= h[site_nbr][i%N]
      else:
        priority[0] -= h[site_nbr][i%N]
        priority[1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority[0] += h[site_nbr][j]
        priority[1] -= h[site_nbr][j]
      else:
        priority[0] -= h[site_nbr][j]
        priority[1] += h[site_nbr][j]
    
    priorities[i] = priority

  return(priorities)




#score: {'data2D.txt': -0.1155791666666668}
#island_id: 1
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin and update priorities
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Update priorities based on neighbors and magnetism
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Sort priorities in descending order
    priorities[i] = priorities[i][np.argsort(np.abs(priorities[i]))][::-1]
  
  return(priorities)




#score: {'data2D.txt': -0.060893055555555575}
#island_id: 2
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_h = [h[s][i%N] for s in site_nbrs]
    
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.060893055555555575}
#island_id: 2
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    
    # Calculate the majority spin
    majority_spin = np.sign(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]))
    
    J_sum = sum([(J[k,i//N,i//N]-majority_spin*h[s][i//N])*(-1)**((k+1)%2) for k,s in zip(range(4),site_nbrs)])
    
    # Calculate the distance to the majority spin
    dist_to_majority = np.abs(np.sum([(-1)**((j+1)%2) * h[s][i//N] for s,j in zip(site_nbrs,range(4))]) - majority_spin)
    
    # Add the magnetism term
    priorities[i][0] = majority_spin + J_sum + dist_to_majority + h[i//N][i%N]
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.018646759259259262}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N%N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      if i % N > 0 and J[2, i//N,i%N] * h[(i+1)%N][i%N] < 0:
        priorities[i][0] -= J[2, i//N,i%N]
      if i % N < N-1 and J[1, i//N,i%N] * h[(i-1)%N][i%N] < 0:
        priorities[i][0] -= J[1, i//N,i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      if i % N > 0 and J[2, i//N,i%N] * h[(i+1)%N][i%N] > 0:
        priorities[i][0] += J[2, i//N,i%N]
      if i % N < N-1 and J[1, i//N,i%N] * h[(i-1)%N][i%N] > 0:
        priorities[i][0] += J[1, i//N,i%N]
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': -0.00022978395061728384}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] < 0:
        priorities[i][0] -= J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] < 0:
        priorities[i][0] -= J[1, i//N, i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] > 0:
        priorities[i][0] += J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] > 0:
        priorities[i][0] += J[1, i//N, i%N]
    priorities[i][1] -= 2 if h[site_nbr][i%N] > 0 else -2
  return(priorities)




#score: {'data2D.txt': 0.018646759259259262}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      if i % N > 0 and J[2,i//N,i%N] * h[(i+1)%N][i%N] < 0:
        priorities[i][0] -= J[2,i//N,i%N]
      if i % N < N-1 and J[1,i//N,i%N] * h[(i-1)%N][i%N] < 0:
        priorities[i][0] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      if i % N > 0 and J[2,i//N,i%N] * h[(i+1)%N][i%N] > 0:
        priorities[i][0] += J[2,i//N,i%N]
      if i % N < N-1 and J[1,i//N,i%N] * h[(i-1)%N][i%N] > 0:
        priorities[i][0] += J[1,i//N,i%N]
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': 0.02459614197530864}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin + nn_energy
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin - nn_energy
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.009256635802469135}
#island_id: 0
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[1,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priority_spin_1 = h[site_nbr][i%N] + total_energy
    priority_spin_2 = -(h[site_nbr][i%N] + total_energy)
    priorities[i][0] = priority_spin_1
    priorities[i][1] = priority_spin_2
  return(priorities)




#score: {'data2D.txt': 0.009256635802469135}
#island_id: 0
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[1,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0024044753086419754}
#island_id: 0
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[(j+1)%2,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.009256635802469135}
#island_id: 0
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[1,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00035632716049382757}
#island_id: 2
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.08874830246913588}
#island_id: 1
#version_generated: 2
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    
    site_spin = h[i//N][i%N]
    
    if J[1,i%N,i//N] > 0:
      site_spin += 1
    elif J[1,i%N,i//N] < 0:
      site_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      site_spin += 1
    elif J[2,i%N,i//N] < 0:
      site_spin -= 1
    
    if J[3,i%N,(i//N)%N] > 0:
      site_spin += 1
    elif J[3,i%N,(i//N)%N] < 0:
      site_spin -= 1
    
    priorities[i][0] = site_spin + h_site
    priorities[i][1] = -site_spin + h_site
  
  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[site_nbr][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]

  return(priorities)

  # Add the improved logic here
  for i in range(N**2):
   site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
   if h[site_nbr][i%N] > 0:
    h_site = 1
   else:
    h_site = -1

   nns = []
   for j in range(4):
    nn_site = (site_nbr + ((j-1)%2 - 1)) % N
    if i//N != (i+N)//N and i%N != (i+1)%N:
     nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
    elif j == 0:
     nns.append(2*J[0][i//N,i//N]*h[site_nbr][i%N])
    else:
     nns.append(0)

   J_up = np.sum(nns)
   priorities[i][0] = (1 + h_site)*J_up
   priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.006853549382716049}
#island_id: 0
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[site_nbr][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    priorities[i][0] = (1 + h_site)*J_up
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00035632716049382757}
#island_id: 2
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009140432098765432}
#island_id: 2
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(3):
      if h[(j+N-1)%N][i%N] > 0:
        priorities[i][0] += J[j,i%N,i//N]
        priorities[i][1] -= J[j,i%N,i//N]
      else:
        priorities[i][0] -= J[j,i%N,i//N]
        priorities[i][1] += J[j,i%N,i//N]
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site
      priorities[i][1] -= h_site
    else:
      priorities[i][0] -= h_site
      priorities[i][1] += h_site
  return(priorities)




#score: {'data2D.txt': 0.004149228395061728}
#island_id: 2
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002615740740740743}
#island_id: 2
#version_generated: 2
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if np.sum(h[i//N]) > 0:
      priorities[i][0] = h[site_nbr][i%N] + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.008394907407407406}
#island_id: 2
#version_generated: 2
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08583194444444445}
#island_id: 0
#version_generated: 2
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 4.5 * total_spin
        priorities[i*N+j][1] -= 3.5 * total_spin
      else:
        priorities[i*N+j][0] -= 4.5 * total_spin
        priorities[i*N+j][1] += 2.5 * total_spin
  return(priorities)




#score: {'data2D.txt': -0.15719830246913602}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (total_spin * 3.5) ** 2
      priorities[i][1] -= 2.5 * total_spin ** 2
    else:
      priorities[i][0] -= (total_spin * 3.5) ** 2
      priorities[i][1] += 2.5 * total_spin ** 2

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])**2*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])**2*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])**2*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])**2*h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.015316820987654321}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] -= 3.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= np.sum(J[:,site_nbr,j])*h[site_nbr][j]
        priorities[i*N+j][1] += 2.5 * np.sum(J[:,site_nbr,j])*h[site_nbr][j]

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j][0] += 1.5 * np.sum(J[:,site,j])*h[site][j]
      priorities[i*N+j][1] -= 1.5 * np.sum(J[:,site,j])*h[site][j]
    else:
      priorities[i*N+j][0] -= 1.5 * np.sum(J[:,site,j])*h[site][j]
      priorities[i*N+j][1] += 1.5 * np.sum(J[:,site,j])*h[site][j]

  return(priorities)




#score: {'data2D.txt': 0.005435956790123458}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    total_energy = h_site
    if sum(nn_spins) > 0:
      total_energy += max([n for n in nn_spins])
    else:
      total_energy -= min([n for n in nn_spins])

    if J[1,i//N,site_nbr] > 0:
      total_energy += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
    else:
      total_energy -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  # Apply a slight modification to the priorities
  for i in range(N**2):
    if np.abs(priorities[i][0]) > 10:
      priorities[i][0] = 5 * np.sign(priorities[i][0])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    for k in range(3):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0003371913580246908}
#island_id: 3
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': 0.07749367283950617}
#island_id: 0
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      min_val = float('inf')
      for s in [-1, 1]:
        energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * s * h[(i+k-1)%N][i%N] for k in range(3))
        if abs(energy) < min_val:
          min_val = abs(energy)
          priorities[i][0] = s
          priorities[i][1] = -s
  return(priorities)




#score: {'data2D.txt': 0.07782608024691359}
#island_id: 0
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      prev_spin = 0
      if i > 0:
        prev_spin = priorities[(i-1)//N*N + (i-1)%N][0]
      total_priority = -prev_spin
      if np.random.rand() < 0.5:  # assign random spin
        if np.random.rand() < 0.5:  # choose direction
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = 1
          priorities[i][1] = -1
      else:  # flip the previous spin
        if prev_spin == -1 and np.random.rand() < 0.5:
          priorities[i][0] = 1
          priorities[i][1] = -1
        elif prev_spin == 1 and np.random.rand() < 0.5:
          priorities[i][0] = -1
          priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': -0.004785956790123457}
#island_id: 3
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,(i+((k-1)%2)-1)//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h[i//N][i%N]
    for k in range(3):
     site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
     else:
       total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.05931774691358028}
#island_id: 3
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += J[0,i%N,i//N]*h[i//N][i%N]
    else:
      total_spin -= J[0,i%N,i//N]*h[i//N][i%N]

    for k in range(1,4):
     site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
     if J[k-1,i%N,i//N] > 0:
       total_spin += J[k-1,i%N,i//N]*h[site_nbr2][i%N]
     else:
       total_spin -= J[k-1,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004227314814814815}
#island_id: 3
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][0] = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)]) + h[site_nbr][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.055378549382716045}
#island_id: 0
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      sum_spin = 0
      for j in range(4):
        site_nbr_nbr = (site_nbr + ((j-1)%2 - 1)) % N
        sum_spin += J[j,i//N,i%N]*h[site_nbr_nbr][i%N]
      priorities[i][0] += 3.5*sum_spin
      priorities[i][1] -= 2.5*sum_spin
    else:
      sum_spin = 0
      for j in range(4):
        site_nbr_nbr = (site_nbr + ((j-1)%2 - 1)) % N
        sum_spin += J[j,i//N,i%N]*h[site_nbr_nbr][i%N]
      priorities[i][0] -= 3.5*sum_spin
      priorities[i][1] += 2.5*sum_spin
  return(priorities)




#score: {'data2D.txt': 0.031508179012345684}
#island_id: 0
#version_generated: 2
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = ((i // N) % N + ((j - 1) % 2 - 1)) % N
      if J[j, i // N, i % N] * h[site_nbr][i % N] > 0:
        total_spin += J[j, i // N, i % N]
      else:
        total_spin -= J[j, i // N, i % N]
    if h[i // N][i % N] > 0:
      priorities[i][0] += 3.5 * total_spin
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= 3.5 * total_spin
      priorities[i][1] += 2.5 * total_spin
  return priorities




#score: {'data2D.txt': -0.004227314814814815}
#island_id: 3
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][0] = total_spin + h[site_nbr][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0005501543209876553}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]**2 for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]**2 for k in range(4)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00035632716049382757}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00035632716049382757}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0002884259259259259}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001649228395061728}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_magnetism = h[site_nbr][i%N]
    
    priorities[i][0] = total_energy + total_magnetism
    priorities[i][1] = -priorities[i][0]

  # Sort the sites by their total energy and magnetism in descending order
  sorted_sites = np.argsort(-priorities)

  # Calculate the priority for each site based on its rank
  for i in range(N**2):
    priorities[sorted_sites[i]][0] -= i
    priorities[sorted_sites[i]][1] += i

  return(priorities)




#score: {'data2D.txt': -0.12809182098765434}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(2*J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]==h[site_nbr][i%N] else -2*J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001649228395061728}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_magnetism = h[site_nbr][i%N]
    
    priorities[i][0] = (total_energy + total_magnetism) / 2
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.010218981481481482}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr2][k] for k in range(3)])
      else:
        total_spin = h_site - np.sum([J[k,i%N,i//N]*h[site_nbr2][k] for k in range(3)])

      if J[j,i%N,i//N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.0024171296296296293}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(2):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(2)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004227314814814815}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N]
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr][i%N]

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002346759259259259}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.28818132716049333}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin**2
      priorities[i][1] = -total_spin**2
    else:
      priorities[i][0] = -total_spin**2
      priorities[i][1] = total_spin**2

  return(priorities)




#score: {'data2D.txt': 0.0003371913580246908}
#island_id: 3
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': 0.1611458333333336}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%N - 1)) % N
    site_nbr_up = (i % N + ((i//N-N)%N - 1)) % N if i%N != 0 else (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+N)%N - 1)) % N if i%N != N-1 else (i % N + ((i//N+1)%N - 1)) % N
    
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr_left][i%N]
        total_spin -= h[site_nbr_right][i%N]
        total_spin += h[site_nbr_up][i//N]
        total_spin -= h[site_nbr_down][i//N]
      else:
        total_spin -= h[site_nbr_left][i%N]
        total_spin += h[site_nbr_right][i%N]
        total_spin -= h[site_nbr_up][i//N]
        total_spin += h[site_nbr_down][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.2943131172839501}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][j] > 0:
        if J[3,i%N,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.0002884259259259259}
#island_id: 2
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002884259259259259}
#island_id: 2
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002884259259259259}
#island_id: 2
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.004463117283950618}
#island_id: 2
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2*total_spin - total_spin
  return(priorities)




#score: {'data2D.txt': 0.0315266975308642}
#island_id: 2
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0031375000000000005}
#island_id: 3
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      priorities[i][j] = h_site + sum([J[k,i%N,(i//N+j)%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      if j == 0:
        priorities[i][j] *= -1
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0024171296296296293}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(2):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(2)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005019598765432099}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    h_site = h[site_nbr][i%N]

    if np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(2)]) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

    priorities[i][0] = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(2)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0010337962962962961}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,(i+N-1)%N,i//N]*h[(k+N-1)%N][(i+N-1)%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,(i+N-1)%N,i//N]*h[(k+N-1)%N][(i+N-1)%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.007774845679012346}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = 2*h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = 2*h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08358935185185186}
#island_id: 0
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [0,1]:
      if J[k,i//N,i%N] != 0:
        total_energy += J[k,i//N,i%N] * h[(i+k-1)%N][i%N]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.03622824074074074}
#island_id: 0
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(3):
      if k == 0:
        total_energy += J[0,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 2:
        total_energy -= J[2,i//N,i%N] * h[(i+k-1)%N][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_energy += J[1, i//N, i%N] * h[site_nbr][j]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.027602314814814816}
#island_id: 0
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in range(4): 
      if k == 0:
        total_energy += J[0,i//N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 3: 
        total_energy -= J[2,i//N,i%N] * h[(i+k-1)%N][i%N]
    for k in range(4): 
      if k == 0:
        total_energy += J[1,(i+N)%N,i%N] * h[(i+k-1)%N][i%N]
      elif k == 3: 
        total_energy -= J[2,(i+N)%N,i%N] * h[(i+k-1)%N][i%N]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) < 0:
        priorities[i][0] = 2*h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]
    else:
      if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) < 0:
        priorities[i][0] = -2*h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002615740740740743}
#island_id: 2
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if np.sum(h[i//N]) > 0:
      priorities[i][0] = h[site_nbr][i%N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_sum += 1
      else:
        neighbor_sum -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+neighbor_sum, -total_spin-neighbor_sum]
    else:
      priorities[i] = [-total_spin-neighbor_sum, total_spin+neighbor_sum]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00035632716049382757}
#island_id: 2
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin + J[0,i%N,i//N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.000336574074074073}
#island_id: 2
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N]
      priorities[i][1] = np.sum(J[:,i//N,i//N]) - priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N]
      priorities[i][1] = -np.sum(J[:,i//N,i//N]) - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002964969135802471}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(2):
        if J[k,i%N,i//N] > 0:
          total_spin += J[k,i%N,i//N]*h[site_nbr][k]
        else:
          total_spin -= J[k,i%N,i//N]*h[site_nbr][k]
      priorities[i][0] = total_spin
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(2):
        if J[k,i%N,i//N] > 0:
          total_spin -= J[k,i%N,i//N]*h[site_nbr][k]
        else:
          total_spin += J[k,i%N,i//N]*h[site_nbr][k]
      priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.0024171296296296293}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(2):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    h_site_with_magnetism = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(2)])
    priorities[i][0] = h_site_with_magnetism
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.16823132716049383}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if k==0 or k==1:
        site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      elif k==2:
        site_nbr2 = (i % N + (i//N-1)%2) % N
      else:
        site_nbr2 = ((i+1)%N + (i//N-1)%2) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h[i//N][i%N] + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014078703703703694}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if k < 2:
        site_nbr2 = (i % N + ((i//N-1+k)%2 - 1)) % N
      else:
        site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N

      priorities[i][0] += J[k,i%N,i//N]*h[site_nbr2][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0013837962962962962}
#island_id: 1
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += h[i//N][i%N]
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[3,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    return(priorities)




#score: {'data2D.txt': 0.08940108024691364}
#island_id: 1
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
     else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
     total_spin += h[site_nbr][i%N]
     priorities[i][0] -= h[site_nbr][i%N]
     priorities[i][1] += h[site_nbr][i%N]
    else:
     total_spin -= h[site_nbr][i%N]
     priorities[i][0] += h[site_nbr][i%N]
     priorities[i][1] -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
     priorities[i][0] = total_spin
     priorities[i][1] = -total_spin
    else:
     priorities[i][0] = -total_spin
     priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.010500462962962963}
#island_id: 1
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin -= h[i//N][i%N]
    else:
      total_spin += h[i//N][i%N]

    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(4):
      site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      
      if J[j,i%N,i//N] > 0:
        total_spin = h_site + np.sum([J[k,i%N,i//N]*h[site_nbr2][k] for k in range(4)])
      else:
        total_spin = h_site - np.sum([J[k,i%N,i//N]*h[site_nbr2][k] for k in range(4)])

      if J[j,i%N,i//N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
        
  return(priorities)




#score: {'data2D.txt': -0.003982253086419753}
#island_id: 3
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h_site + np.sum([J[k,i%N,i//N]*h[(k+((i//N+k)//N-1)%2-1)%N][i%N] for k in range(4)])
    if total_spin > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.03717608024691359}
#island_id: 1
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0,1,-1))
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.004463117283950618}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2*total_spin - total_spin
  return(priorities)




#score: {'data2D.txt': 0.02876404320987654}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= (total_spin + np.sum(J[:, i//N, i//N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -(total_spin + np.sum(J[:, i//N, i//N]))
  return(priorities)




#score: {'data2D.txt': 0.004463117283950618}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2*total_spin - total_spin
  return(priorities)




#score: {'data2D.txt': 0.004463117283950618}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2*total_spin - total_spin
  return(priorities)




#score: {'data2D.txt': 0.0315266975308642}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1262949074074074}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.027801697530864197}
#island_id: 2
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*(h[(k+N-1)%N][i%N] + h[site_nbr][i%N]) for k in range(3)]) + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,i%N]*(h[(k+N-1)%N][i%N] + h[site_nbr][i%N]) for k in range(3)]) + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009372993827160494}
#island_id: 0
#version_generated: 2
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 5 * total_spin
      priorities[i][1] -= 4 * total_spin
    else:
      priorities[i][0] -= 5 * total_spin
      priorities[i][1] += 4 * total_spin

    for k in range(2):
      site = (i % N + ((k)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2 * np.sum(J[:,site,i%N])*h[site][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1.5 * total_spin
      priorities[i][1] += 1.5 * total_spin
    else:
      priorities[i][0] += 1.5 * total_spin
      priorities[i][1] -= 1.5 * total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 10
      priorities[i][1] -= 8
    else:
      priorities[i][0] -= 10
      priorities[i][1] += 8

  return(priorities)




#score: {'data2D.txt': 0.0021359567901234576}
#island_id: 0
#version_generated: 2
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
    if np.sum(h[i//N]) > 0:
      priorities[i][0] += 5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    else:
      priorities[i][0] -= 5 * total_spin
      priorities[i][1] += 3.5 * total_spin

    for k in range(4):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
       priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.006693981481481481}
#island_id: 0
#version_generated: 2
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add the magnetism term
    priorities[i][0] += 3 * total_spin
    priorities[i][1] -= 3 * total_spin
    
    # Calculate the interaction terms for nearest neighbors
    for k in range(2):
      site = (i % N + ((k)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 3 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 2 * np.sum(J[:,site,i%N])*h[site][i%N]
        
  return(priorities)




#score: {'data2D.txt': 0.02501064814814815}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr4 = (i // N)
    
    if h[site_nbr1][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr1][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[site_nbr2][j]
        priorities[i][1] -= h[site_nbr2][j]
      else:
        priorities[i][0] -= h[site_nbr2][j]
        priorities[i][1] += h[site_nbr2][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.13333503086419773}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i // N + ((i%N+1)%N - 1)) % N
    site_nbr4 = (i % N + ((i//N+1)%N - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N] + h[site_nbr3][i%N] + h[site_nbr4][i%N]
    
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,(i+1)%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,(i+1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-1+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16563472222222247}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i - 1) % N
    site_nbr_right = (i + 1) % N
    
    if i % N != 0 and J[3,i%N,(i-1)//N] > 0:
      total_spin += h[site_nbr_left][i%N]
    elif i % N != 0 and J[3,i%N,(i-1)//N] < 0:
      total_spin -= h[site_nbr_left][i%N]

    if i % N != N - 1 and J[3,i%N,(i+1)//N] > 0:
      total_spin += h[site_nbr_right][i%N]
    elif i % N != N - 1 and J[3,i%N,(i+1)//N] < 0:
      total_spin -= h[site_nbr_right][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = -total_spin + np.sum(h[i//N])
    priorities[i][1] = total_spin + np.sum(h[i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.1652754629629632}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    site_nbr_up = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[3,i//N,i%N], -total_spin - J[3,i//N,i%N]]
    else:
      priorities[i] = [-total_spin - J[3,i//N,i%N], total_spin + J[3,i//N,i%N]]

  return(priorities)




#score: {'data2D.txt': 0.013547376543209878}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with neighbors
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust spin based on magnetism and neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 2*sum(J[:, i//N, i%N]), total_spin + 2*sum(J[:, i//N, i%N])]
    else:
      priorities[i] = [total_spin + 2*sum(J[:, i//N, i%N]), total_spin - 2*sum(J[:, i//N, i%N])]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Magnetism term
    total_spin = h[site_nbr][i%N]
    
    # Interaction terms
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Orientation of the nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Assign priorities
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08212885802469137}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': -0.005014351851851851}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.zeros((1,2))
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_spin += np.array([h[x%N][y], -h[x%N][y]])
    priorities[i][1] -= total_spin[0,0]
  return(priorities)




#score: {'data2D.txt': 0.012080092592592592}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_sum = 0.5 * (h[(i-1)%N][i%N] + h[(i+1)%N][i%N] + 
             h[i%(N*N)//N][(i+N-1)%N] + h[i%(N*N)//N][(i+N+1)%N])
    priorities[i][0] = -total_energy - nn_sum
    priorities[i][1] = total_energy + nn_sum
  return(priorities)




#score: {'data2D.txt': -0.007774845679012346}
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = 2*h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.007774845679012346}
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = 2*h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004087191358024691}
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0011748456790123454}
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -spin_sum
      priorities[i][1] = spin_sum
    else:
      priorities[i][0] = spin_sum
      priorities[i][1] = -spin_sum
  return(priorities)




#score: {'data2D.txt': 0.1262949074074074}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      sum_spin_neighbors = np.sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors])
      priorities[i][0] = sum_spin_neighbors + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      sum_spin_neighbors = np.sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors])
      priorities[i][0] = -sum_spin_neighbors + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1262949074074074}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1262949074074074}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      J_neighbor_sum = sum(J[neighbor,i//N,i%N]*h[(neighbor+N-1)%N][i%N] for neighbor in range(4) if abs((neighbor-N/2)-i%N) <= 1 and abs((neighbor-(3+N)/2)//N - i//N) <= 1)
      priorities[i][0] = J_neighbor_sum + J[3,i//N,i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      J_neighbor_sum = -sum(J[neighbor,i//N,i%N]*h[(neighbor+N-1)%N][i%N] for neighbor in range(4) if abs((neighbor-N/2)-i%N) <= 1 and abs((neighbor-(3+N)/2)//N - i//N) <= 1)
      priorities[i][0] = J_neighbor_sum + 2*J[0,i//N,i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1262949074074074}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + J[3,i//N,i%N] + h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors = [k for k in range(4) if abs((k-N/2)-i%N) <= 1 and abs((k-(3+N)/2)//N - i//N) <= 1]
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in neighbors]) + 2*J[0,i//N,i%N] - h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00036435185185185203}
#island_id: 0
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    J_down = -np.sum([J[j][i//N,i//N]*h[(site_nbr+1)%N][i%N] for j in range(4) if i//N != (i+N)//N and i%N != (i+1)%N])
    priorities[i][0] = h_site * J_up + 2*h_site*np.sum(nns)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 5.1388888888889317e-05}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns.append(J[j][i//N,i//N]*h[nn_site][i%N])
      else:
        nns.append(0)

    J_up = np.sum(nns)
    J_down = -np.sum([J[j][i//N,i//N]*h[(site_nbr+1)%N][i%N] for j in range(4) if i//N != (i+N)//N and i%N != (i+1)%N])
    priorities[i][0] = h_site * J_up + 2 * np.sum([J[j][i//N,i//N]*h[site_nbr][i%N] for j in range(4) if j==0 or j==3]) - J_down
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0027692901234567906}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [J[(i+((k-1)%2)-1)%4][i//N,i//N]*h[(site_nbr+(k-1)%2-1)%N][i%N] for k in range(1,5)]
    J_up = np.sum(nns)
    J_down = -np.sum([J[k][i//N,i//N]*h[(site_nbr+k-1)%4][i%N] for k in range(4)])
    priorities[i][0] = h_site * J_up
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00036435185185185203}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns_up = []
    nns_down = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N != (i+N)//N and i%N != (i+1)%N:
        nns_up.append(J[j][i//N,i//N]*h[nn_site][i%N])
        nns_down.append(-J[j][i//N,i//N]*h[nn_site][i%N])
      elif j == 0:
        nns_up.append(2*J[0][i//N,i//N]*h[nn_site][i%N])
        nns_down.append(-2*J[0][i//N,i//N]*h[nn_site][i%N])

    J_up = np.sum(nns_up)
    J_down = -np.sum(nns_down)

    priorities[i][0] = h_site * J_up
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.15857330246913606}
#island_id: 2
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    site_magnetism = h[i//N][i%N]
    priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
    priorities[i][1] = -(h_site - J[0,i%N,i//N] + total_spin) if site_magnetism > 0 else -(-h_site + J[0,i%N,i//N] - total_spin)
  return(priorities)




#score: {'data2D.txt': -0.0003310185185185185}
#island_id: 2
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[j][site_nbr] if abs(i//N-j)<1 else 0 for j in range(N)])
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0003217592592592592}
#island_id: 2
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -h_site + J[0,i%N,i//N] - total_spin
      priorities[i][1] = 2 * (J[0,i%N,i//N] - h_site)
    else:
      priorities[i][0] = h_site - J[0,i%N,i//N] + total_spin
      priorities[i][1] = 2 * (h_site - J[0,i%N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.15857330246913606}
#island_id: 2
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = sum([h[i//N][j] for j in range(N) if abs(i//N-j)<1])
    priority_total = h_site - J[0,i%N,i//N] + total_spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = priority_total
      priorities[i][1] = -priority_total
    else:
      priorities[i][0] = -priority_total
      priorities[i][1] = -priority_total
  return(priorities)




#score: {'data2D.txt': -0.09733750000000006}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if k==0 or k==1:
        site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      elif k==2:
        site_nbr2 = (i % N + (i//N-1)%2) % N
      else:
        site_nbr2 = ((i+1)%N + (i//N-1)%2) % N
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = h[i//N][i%N] + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    if total_spin > 0:
      priorities[i][1] = -np.sum([abs(J[k,i%N,i//N])*h[site_nbr2][i%N] for k in range(4)])
    else:
      priorities[i][1] = np.sum([abs(J[k,i%N,i//N])*h[site_nbr2][i%N] for k in range(4)])
  return(priorities)




#score: {'data2D.txt': -0.16823132716049383}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, 
                 (i % N + (i//N-1)%2) % N, 
                 ((i+1)%N + (i//N-1)%2) % N, 
                 (i % N + ((i//N-1)%2 - 1)) % N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]*h[site_nbrs[k]][i%N]
      else:
        total_spin -= J[k,i%N,i//N]*h[site_nbrs[k]][i%N]

    priorities[i][0] = h[i//N][i%N] + np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.19535108024691358}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        if k==0 or k==1:
          site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
        elif k==2:
          site_nbr2 = (i % N + (i//N-1)%2) % N
        else:
          site_nbr2 = ((i+1)%N + (i//N-1)%2) % N
        total_spin += J[k,i%N,i//N]*h[site_nbr2][i%N]
      else:
        if k==0 or k==1:
          site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
        elif k==2:
          site_nbr2 = (i % N + (i//N-1)%2) % N
        else:
          site_nbr2 = ((i+1)%N + (i//N-1)%2) % N
        total_spin -= J[k,i%N,i//N]*h[site_nbr2][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.001649537037037037}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if k==0 or k==1:
        site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
      elif k==2:
        site_nbr2 = (i % N + (i//N-1)%2) % N
      else:
        site_nbr2 = ((i+1)%N + (i//N-1)%2) % N
      total_spin += J[k,i%N,i//N]*(h[site_nbr][k] - h[site_nbr2][k])

    priorities[i][0] = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(4)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with neighbors
    interaction_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        interaction_sum += 1
      else:
        interaction_sum -= 1
    
    # Adjust total_spin based on interactions
    total_spin += interaction_sum
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.010366203703703704}
#island_id: 1
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      total_spin -= 1
    else:
      total_spin -= h[site_nbr][i%N]
      total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0038501543209876537}
#island_id: 3
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0.5 * h[site_nbr][i%N]
    for k in range(4):
      if k < 2:
        site_nbr2 = (i % N + ((i//N-1+k)%2 - 1)) % N
      else:
        site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N] * h[site_nbr2][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002995524691358025}
#island_id: 3
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_weights = [J[k,i%N,i//N]*h[(i+k-1)%N][i%N] for k in range(4)]
    priorities[i,0] = sum(neighbor_weights)
    priorities[i,1] = -priorities[i,0]
  return(priorities)




#score: {'data2D.txt': 0.00019861111111111075}
#island_id: 3
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if k < 2:
        site_nbr2 = (i % N + ((i//N-1+k)%2 - 1)) % N
      else:
        site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N

      priorities[i][0] += J[k,i%N,i//N]*h[site_nbr2][i%N]
    for j in range(2):
      if priorities[i][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
  return(priorities)




#score: {'data2D.txt': -0.00445570987654321}
#island_id: 3
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    nn_sum = 0
    for k in range(4):
      if k < 2:
        site_nbr2 = (i % N + ((i//N-1+k)%2 - 1)) % N
      else:
        site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
      nn_sum += J[k,i%N,i//N]*h[site_nbr2][i%N]
    priorities[i][0] = total_spin + nn_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.012409722222222223}
#island_id: 1
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.0017171296296296296}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    total_energy = h_site
    if sum(nn_spins) > 0:
      total_energy += max([n for n in nn_spins])
    else:
      total_energy -= min([n for n in nn_spins])

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0018211419753086417}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),[(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)])]
    else:
      nn_spins = [-n for n in [J[j,i//N,nn_site] for j,nn_site in zip(range(4),[(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)])]]
    
    total_energy = h_site
    if sum(nn_spins) > 0:
      total_energy += max([n for n in nn_spins])
    else:
      total_energy -= min([n for n in nn_spins])

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.005435956790123458}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    total_energy = h_site
    if sum(nn_spins) > 0:
      total_energy += max([n for n in nn_spins])
    else:
      total_energy -= min([n for n in nn_spins])

    if J[1,i//N,site_nbr] > 0:
      total_energy += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
    else:
      total_energy -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    total_energy = h_site
    if sum(nn_spins) > 0:
      total_energy += max([n for n in nn_spins])
    else:
      total_energy -= min([n for n in nn_spins])

    priorities[i][0] = total_energy + abs(h_site)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002365586419753086}
#island_id: 3
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h[site_nbr][i%N] + spin_sum
    if spin_sum > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004087191358024691}
#island_id: 3
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h[site_nbr][i%N] - spin_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004087191358024691}
#island_id: 3
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h[site_nbr][i%N] - sum_h
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.12180910493827175}
#island_id: 3
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + spin_sum
      if J[0,i//N,i//N]*h[0][i%N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
    else:
      spin_sum = sum([J[k,i//N,(k+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] - spin_sum
      if J[0,i//N,i//N]*h[0][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.003982253086419753}
#island_id: 3
#version_generated: 2
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    interaction_sum = np.sum([J[k,i%N,(i//N)+k//N]*h[(k+((i//N+k)//N-1)%2-1)%N][i%N] for k in range(4)])
    total_spin = h_site + interaction_sum
    if total_spin > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.003982253086419753}
#island_id: 3
#version_generated: 2
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+((i//N+k)//N-1)%2-1)%N][i%N] for k in range(4)])
    if total_spin > 0:
      priorities[i][0] += -1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.004192438271604939}
#island_id: 3
#version_generated: 2
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h_site + np.sum([J[k,i%N,i//N]*h[(k+((i//N+k)//N-1)%2-1)%N][i%N] for k in range(4)])
    if total_spin > 0:
      priorities[i][1] -= np.sum([np.abs(J[k,i%N,i//N]) for k in range(4)])
    else:
      priorities[i][1] += np.sum([np.abs(J[k,i%N,i//N]) for k in range(4)])
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16295138888888913}
#island_id: 1
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [i//N*N, (i//N+1)*N]]
    
    for site_nbr in site_nbrs:
      if J[3,i%N,site_nbr] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0022597222222222224}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1556057098765434}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][k]
        priorities[i][1] -= h[site_nbr_row][k]
      else:
        priorities[i][0] -= h[site_nbr_row][k]
        priorities[i][1] += h[site_nbr_row][k]
      
      if J[k,i//N,k%N] > 0:
        priorities[i][0] += h[site_nbr_col][k]
        priorities[i][1] -= h[site_nbr_col][k]
      else:
        priorities[i][0] -= h[site_nbr_col][k]
        priorities[i][1] += h[site_nbr_col][k]
    
  return(priorities)




#score: {'data2D.txt': 0.044846141975308645}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(3):
      if J[k,i//N,i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.0045421296296296295}
#island_id: 2
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.14342299382716062}
#island_id: 2
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    magnetism = 0
    for j in range(3):
      if J[j,i%N,i//N] > 0:
        total_spin += h[site_nbr][j]
        magnetism -= 1
      else:
        total_spin += -h[site_nbr][j]
        magnetism += 1

    priorities[i][0] = total_spin + magnetism * (2*h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005597376543209876}
#island_id: 2
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*-h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0020307098765432094}
#island_id: 2
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i % N + ((i//N)%2 - 1)) % N
    right_nbr = (i % N + ((i//N+1)%2 - 1)) % N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + J[0,i%N,i//N]*h[left_nbr][i%N] + J[1,i%N,i//N]*h[right_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - J[0,i%N,i//N]*h[left_nbr][i%N] - J[1,i%N,i//N]*h[right_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.03292731481481482}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i//N,i%N] > 0:
      total_spin -= h[i//N][i%N]
    else:
      total_spin += h[i//N][i%N]

    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = i // N
    site_nbr_col = i % N
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add next-nearest neighbor interactions
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.05552268518518525}
#island_id: 1
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate magnetism
    magnetism = 2*h[i//N][i%N] - 1
    
    # Update priorities based on interactions and magnetism
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += magnetism + h[site_nbr][i%N]
      priorities[i][1] -= magnetism - h[site_nbr][i%N]
    else:
      priorities[i][0] -= magnetism - h[site_nbr][i%N]
      priorities[i][1] += magnetism + h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Calculate spin based on interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin *= (h[i//N][i%N]>0)*2-1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0007461419753086421}
#island_id: 1
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Add the magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011109567901234592}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0027202160493827164}
#island_id: 2
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(3):
        total_spin += J[k,i//N,i%N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(3):
        total_spin -= J[k,i//N,i%N]*-h[(k+N-1)%N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0010276234567901227}
#island_id: 2
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04080138888888889}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    
    # Improved version: consider both neighbor sites
    for j in range(4): 
      if J[j//2,i//N,site_nbr] > 0:
        total_energy += h[i//N][i%N]
      else:
        total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.024441820987654326}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) * (1 - np.tanh(total_energy))
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.0005550925925925927}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.exp(-h_site) * np.prod([1 + np.tanh(nn_energy) for nn_energy in nns])
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.026528858024691356}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.tanh(total_energy)
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.009380092592592591}
#island_id: 2
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_magnetism = 0
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_magnetism += abs(h[(k+N-1)%N][i%N])
      else:
        total_magnetism -= abs(h[(k+N-1)%N][i%N])
    
    # Calculate the priority for each spin
    priorities[i][0] = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*total_magnetism for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0004569444444444438}
#island_id: 2
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0045421296296296295}
#island_id: 2
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (h_site + sum([J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)]))
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012001543209876541}
#island_id: 2
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
    if i % N < N // 2:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.15759058641975326}
#island_id: 2
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    magnetism = 0
    for j in range(4):
      if J[j%4,i%N,i//N] > 0:
        total_spin += h[site_nbr][j%N]
        magnetism -= 1
      else:
        total_spin += -h[site_nbr][j%N]
        magnetism += 1

    priorities[i][0] = total_spin + magnetism * (2*h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.15759058641975326}
#island_id: 2
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    magnetism = 0
    for j in range(4): # considering all neighbors not just the first three
      if J[j,i%N,i//N] > 0:
        total_spin += h[site_nbr][j]
        magnetism -= 1
      else:
        total_spin += -h[site_nbr][j]
        magnetism += 1

    priorities[i][0] = total_spin + magnetism * (2*h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.19730848765432132}
#island_id: 2
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    magnetism = 0
    for j in range(3):
      if J[j,i%N,i//N] > 0:
        total_spin += h[site_nbr][j]
        magnetism -= 1
      else:
        total_spin += -h[site_nbr][j]
        magnetism += 1

    priorities[i][0] = total_spin + magnetism * (2*h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]

  # Apply a symmetry trick to reduce the computation
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][i]
      magnetism = 1 if h[i][j] > 0 else -1

      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= magnetism

  return(priorities)




#score: {'data2D.txt': 0.0011109567901234592}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009976851851851857}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,site_nbr1] != 0 or J[1,i%N,site_nbr1] != 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]
    else:
      if J[2,i%N,site_nbr1] < 0:
        if h[i//N][i%N] > 0:
          priorities[i][0] = total_spin
          priorities[i][1] = -priorities[i][0]
        else:
          priorities[i][0] = -total_spin
          priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04321620370370374}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 3
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - (priorities[i].dot([1,-1]))/2
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + (priorities[i].dot([1,-1]))/2
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001996450617283951}
#island_id: 2
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_magnetism = 0
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_magnetism += h[(k+N-1)%N][i%N]
      else:
        total_magnetism -= h[(k+N-1)%N][i%N]
    
    # Calculate the priority for each spin
    priorities[i][0] = total_magnetism
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.005597376543209876}
#island_id: 2
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_magnetism = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Calculate the priority for each spin
    priorities[i][0] = h[site_nbr][i%N] + total_magnetism
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0015646604938271609}
#island_id: 1
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Vectorized interaction computation
    interactions = J[np.arange(4),i%N,i//N].sum()
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interactions, -total_spin - interactions]
    else:
      priorities[i] = [-total_spin - interactions, total_spin + interactions]
  
  return(priorities)




#score: {'data2D.txt': 0.1177174382716051}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11253009259259272}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][i%N]
        priorities[i][1] -= h[site_nbr_row][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row][i%N]
        priorities[i][1] += h[site_nbr_row][i%N]
    
    for j in range(N):
      site_nbr_col = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr_col][j]
        priorities[i][1] -= h[site_nbr_col][j]
      else:
        priorities[i][0] -= h[site_nbr_col][j]
        priorities[i][1] += h[site_nbr_col][j]
  
  return(priorities)




#score: {'data2D.txt': 0.00036373456790123466}
#island_id: 0
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.08212885802469137}
#island_id: 0
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1, 0]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[k,i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy + abs(h[site_nbr][i%N])
    priorities[i][1] = -total_energy - abs(h[site_nbr][i%N])
  return(priorities)




#score: {'data2D.txt': -0.0015535493827160518}
#island_id: 0
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009020061728395073}
#island_id: 0
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0008967592592592589}
#island_id: 2
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i,j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i,j][1] -= 1
      else:
        total_spin[i,j][1] += 1
      
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = total_spin[i%N,(i//N)%N][0] + sum([J[k,i%N,(i//N)%N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
    if i % N < N // 2:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012001543209876541}
#island_id: 2
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + neighbor_sum
    if i % N < N // 2:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012001543209876541}
#island_id: 2
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sum = sum([J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + nn_sum
    if i % N < N // 2:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.008087191358024692}
#island_id: 1
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11675046296296308}
#island_id: 1
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    neighbor_sum = 0
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      neighbor_sum += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    priorities[i][0] += neighbor_sum
    priorities[i][1] -= neighbor_sum
  
  return(priorities)




#score: {'data2D.txt': -0.0017671296296296296}
#island_id: 0
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = np.sum(h[site_nbr]) + np.sum(J[:, i//N, :])
    
    # Adjust priorities based on magnetism
    if h[i//N].sum() > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0007489197530864195}
#island_id: 0
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      
      total_spin += np.sum(J[j, i//N, :])
    # Add the magnetism term
    priorities[i][0] = total_spin + h[site_nbr].sum()
    priorities[i][1] = -total_spin - h[site_nbr].sum()
  return(priorities)




#score: {'data2D.txt': -0.0013125000000000003}
#island_id: 0
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      
      total_spin += np.sum(J[j, i//N, :])
    
    # Add the magnetism term
    priorities[i][0] = total_spin + h[site_nbr][i%N]
    priorities[i][1] = -total_spin - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.011847685185185185}
#island_id: 0
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      
      total_spin += np.sum(J[j, i//N, :])
    
    # Add the magnetism term
    priorities[i][0] = total_spin + np.sum(h[i//N]) - np.sum(np.where(J[0, :, :], 1, -1))
    priorities[i][1] = -total_spin - np.sum(h[i//N]) - np.sum(np.where(J[0, :, :], 1, -1))
  
  return(priorities)




#score: {'data2D.txt': -0.0032915123456790127}
#island_id: 0
#version_generated: 2
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
    if np.sum(h[i//N]) > 0:
      priorities[i][0] -= 5 * total_spin
      priorities[i][1] += 3.5 * total_spin
    else:
      priorities[i][0] += 5 * total_spin
      priorities[i][1] -= 3.5 * total_spin
    
    for k in range(4):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
      priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] -= 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
      priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
      priorities[i][1] += 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]
  return(priorities)




#score: {'data2D.txt': 0.002466512345679012}
#island_id: 0
#version_generated: 2
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      site_nbr_sum += h[site_nbr][i%N]
    if np.sum(h[i//N]) > 0:
      total_spin = site_nbr_sum
    else:
      total_spin = -site_nbr_sum
    for k in range(4):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] -= 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
       priorities[i][0] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] += 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0010050925925925921}
#island_id: 0
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    for j, site in enumerate(site_nbrs):
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': -0.013449537037037036}
#island_id: 0
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if j < 2:  # left and top neighbors
        nns.append(J[j,i//N,i%N])
      else:      # right neighbor
        nns.append(h[nn_site][i%N] * J[3,i//N,i%N])
    
    priorities[i][0] = sum([n*h_site for n in nns]) + J[1,i//N,i//N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015800925925925932}
#island_id: 0
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_sites = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nn_sites.append((nn_site, h[nn_site][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),[1 if d >= 0 else -1 for _,d in nn_sites])])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*n for k,n in zip(range(3),[1 if d >= 0 else -1 for _,d in nn_sites])])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0006174382716049383}
#island_id: 2
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    # add the contribution from the diagonally adjacent sites
    for j in range(N):
      if i % (N*N) < N:
        priorities[i][0] += J[2, i % N, j]
      else:
        priorities[i][0] -= J[2, i % N, j]

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0016930555555555555}
#island_id: 2
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    if J[1,i%N,i//N] > 0:
      priorities[i][0] -= h_site
    else:
      priorities[i][0] += h_site

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0016405864197530868}
#island_id: 2
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h_site
    else:
      priorities[i][0] -= h_site

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0061859567901234565}
#island_id: 2
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    # Calculate the sum of interactions with nearest neighbors
    J_sum = sum([J[k, i%N, i//N] for k in range(3)])
    
    priorities[i][0] = J_sum * abs(h_site)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.012409722222222223}
#island_id: 1
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.22955046296296294}
#island_id: 0
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(np.abs(J[:, i // N, i % N]) - total_spin)
    else:
      priorities[i][1] -= np.sum(np.abs(J[:, i // N, i % N]) + total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.sum(np.abs(h[site_nbrs[0]][i%N] * J[0,i//N,i%N]) - (total_spin))
    else:
      priorities[i][0] -= np.sum(np.abs(h[site_nbrs[0]][i%N] * J[0,i//N,i%N]) + (total_spin))

  return(priorities)




#score: {'data2D.txt': -0.007739043209876543}
#island_id: 0
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(J[:,i//N,i%N][site_nbrs.index(i % N)] * (h[site_nbr][i%N] if h[i//N][i%N] == J[:,i//N,i%N][site_nbrs.index(i % N)] else -h[site_nbr][i%N]) for site_nbr in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.052865277777777775}
#island_id: 0
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * (total_spin + np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * (total_spin - np.sum(J[:,i//N,i%N]))
  return(priorities)




#score: {'data2D.txt': 0.0014084876543209877}
#island_id: 2
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr_k = (k+N-1)%N
      priorities[i][0] += J[k,i%N,i//N]*abs(h[site_nbr_k][i%N])
    
    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h_site
    else:
      priorities[i][0] -= h_site
    
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012288580246913575}
#island_id: 2
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    for k in range(4):
      site_k = (k+N-1)%N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += J[k,i%N,i//N]*abs(h[site_k][i%N])
      else:
        priorities[i][0] -= J[k,i%N,i//N]*abs(h[site_k][i%N])
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h_site
    else:
      priorities[i][0] -= h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0024251543209876537}
#island_id: 2
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_spin += abs(h[(k+N-1)%N][i%N])
      else:
        total_spin -= abs(h[(k+N-1)%N][i%N])
    priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.011900154320987663}
#island_id: 3
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

    site_nbr3 = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr4 = (i // N + ((i%N-2)%2 - 1)) % N

    total_spin += h[site_nbr3][i%N] + sum([J[k,i%N,site_nbr3]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= -priorities[i][0]
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.011900154320987663}
#island_id: 3
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    total_spin += h[site_nbr3][i%N] + sum([J[k,i%N,site_nbr3]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= -priorities[i][0]
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011109567901234592}
#island_id: 3
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03153194444444446}
#island_id: 3
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004629166666666667}
#island_id: 3
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = 2*h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 0
      priorities[i][1] = 0
      
  return(priorities)




#score: {'data2D.txt': 0.04321620370370374}
#island_id: 3
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04321620370370374}
#island_id: 3
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004257561728395061}
#island_id: 0
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    priority_total = np.array([total_energy + nn_energy, -2])
    priorities[i] = priority_total
  return(priorities)




#score: {'data2D.txt': -0.02138780864197532}
#island_id: 0
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if total_energy + 2*nn_energy > 0:
      priorities[i][0] = (total_energy + nn_energy) * N
      priorities[i][1] = -2*N
    elif total_energy - 2*nn_energy > 0:
      priorities[i][0] = -(total_energy - nn_energy) * N
      priorities[i][1] = 2*N
    else:
      priorities[i][0] = (h[i//N][i%N] + h[site_nbr][i%N]) * N
      priorities[i][1] = 0
  return(priorities)




#score: {'data2D.txt': 0.053702314814814814}
#island_id: 0
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    priority_total = total_energy + nn_energy
    if priority_total > 0:
      priorities[i][0] += priority_total * N
      priorities[i][1] -= 2*N
    elif priority_total < 0:
      priorities[i][0] -= abs(priority_total) * N
      priorities[i][1] += 2*N
  return(priorities)




#score: {'data2D.txt': -0.22226095679012367}
#island_id: 0
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    priority_flip = 2*nn_energy - total_energy
    priority_stay = 2*N*(total_energy + nn_energy)
    priorities[i][0] += np.clip(priority_flip, a_min=-100, a_max=100) 
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0011109567901234592}
#island_id: 3
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011109567901234592}
#island_id: 3
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if total_spin > 0:
      priorities[i][0] = 2*total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -2*total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Prioritize spins based on magnetism and interactions
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  # Adjust priority based on interactions with neighboring sites
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    if J[0,i%N,site_nbr1] > 0:
      priorities[i][0] += J[0,i%N,site_nbr1]
      priorities[i][1] -= J[0,i%N,site_nbr1]
    elif J[0,i%N,site_nbr1] < 0:
      priorities[i][0] -= J[0,i%N,site_nbr1]
      priorities[i][1] += J[0,i%N,site_nbr1]

  return(priorities)




#score: {'data2D.txt': -0.005734413580246914}
#island_id: 2
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_magnetism = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Calculate the priority for each spin
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_magnetism + abs(h[site_nbr][i%N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_magnetism - abs(h[site_nbr][i%N])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.002250462962962963}
#island_id: 2
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_magnetism = 0
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_magnetism += abs(h[(k+N-1)%N][i%N])
      else:
        total_magnetism -= abs(h[(k+N-1)%N][i%N])
    
    # Calculate the priority for each spin
    priorities[i][0] = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*total_magnetism for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][1] -= 1
    elif J[0,i%N,i//N] < 0:
      priorities[i][1] += 1
    
    if i % N != 0 and J[2,(i-1)%N,i//N] > 0:
      priorities[i][1] -= 1
    elif i % N != 0 and J[2,(i-1)%N,i//N] < 0:
      priorities[i][1] += 1
    
    if i < N**2 - N and J[1,i%N,(i+N)//N] > 0:
      priorities[i][1] -= 1
    elif i < N**2 - N and J[1,i%N,(i+N)//N] < 0:
      priorities[i][1] += 1
    
    if i % N != 0 and i >= N and J[1,(i-1)%N,i//N] > 0:
      priorities[i][1] -= 1
    elif i % N != 0 and i >= N and J[1,(i-1)%N,i//N] < 0:
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.07711496913580251}
#island_id: 3
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = sum([J[k,i%N,(i+N-1)%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[(i//N)%N][i%N]
    
    if J[0,i%N,(i+N-1)%N] < 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009976851851851857}
#island_id: 3
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,site_nbr1] != 0 or J[1,i%N,site_nbr1] != 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]
    else:
      if J[2,i%N,site_nbr1] < 0:
        if h[i//N][i%N] > 0:
          priorities[i][0] = total_spin
          priorities[i][1] = -priorities[i][0]
        else:
          priorities[i][0] = -total_spin
          priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009976851851851857}
#island_id: 3
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + sum([J[k,i%N,site_nbr1]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,site_nbr1] != 0 or J[1,i%N,site_nbr1] != 0:
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]
    else:
      if J[2,i%N,site_nbr1] < 0:
        if h[i//N][i%N] > 0:
          priorities[i][0] = total_spin
          priorities[i][1] = -priorities[i][0]
        else:
          priorities[i][0] = -total_spin
          priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i%N+N-1)%N) if i//N==0 else ((i%N+N-1)%N)
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr4 = ((i%N+N-1)//N) if i//N==0 else ((i%N+N-1)//N)
    
    for j in range(N):
      site_nbr5 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr5][j]
      else:
        total_spin -= h[site_nbr5][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.09262083333333342}
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_col = (j + ((i-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_row][j]
        total_spin -= h[site_nbr_col][i//N]
      else:
        total_spin -= h[site_nbr_row][j]
        total_spin += h[site_nbr_col][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.010465586419753087}
#island_id: 3
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]) + np.sum(h)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = (-sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]) + np.sum(h)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04321620370370374}
#island_id: 3
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024686728395061724}
#island_id: 3
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03153194444444446}
#island_id: 3
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002781327160493827}
#island_id: 0
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.023259722222222223}
#island_id: 0
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy if np.sum(h[i//N]) < 0 else 1
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.005666512345679013}
#island_id: 0
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    for j in range(N):
      if i % N == 0: 
        site_nbr = (j + ((N-1)%2 - 1)) % N
        total_energy += J[1,i//N,j]
      elif i % N == N-1:
        site_nbr = (j + ((0)%2 - 1)) % N
        total_energy += J[3,i//N,j]
      else: 
        if i % N < N//2:
          site_nbr = (j + ((i%N+1)%2 - 1)) % N
        else:
          site_nbr = (j + ((i%N-1)%2 - 1)) % N
        total_energy += J[2,i//N,j]
    priorities[i][0] = -total_energy
    priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.06954706790123456}
#island_id: 0
#version_generated: 2
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = [(site_nbr + k) % N for k in [-1, 0, 1]]
    J_up = np.sum([J[k,i//N,i%N]*h[nn_sites[j]][i%N] for j,k in zip(range(3),[-1,1,-1])])
    J_down = -np.sum([J[k,i//N,i%N]*-h[nn_sites[j]][i%N] for j,k in zip(range(3),[1,-1,1])])

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0031189814814814813}
#island_id: 0
#version_generated: 2
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - i % N) == 1:
        nn_sites_same_row = 1
      else:
        nn_sites_same_row = 0

      nns.append(h[nn_site][i%N]*nn_sites_same_row + h[site_nbr][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    
    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.0013248456790123458}
#island_id: 1
#version_generated: 2
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_sum = sum([h[j][i%N] for j in range(N)])
    else:
      h_sum = -sum([h[j][i%N] for j in range(N)])
    
    if J[1,i%N,i//N] > 0:
      total_spin = h_sum + sum([J[2,j,i//N]*h[j][i%N] for j in range(N)])
    else:
      total_spin = -h_sum - sum([J[2,j,i//N]*h[j][i%N] for j in range(N)])
    
    if J[3,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009020061728395073}
#island_id: 0
#version_generated: 2
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009020061728395073}
#island_id: 0
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009020061728395073}
#island_id: 0
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009020061728395073}
#island_id: 0
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i//N,site_nbr]*h[(k+N-1)%N][i//N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08031712962962961}
#island_id: 0
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy) / (np.exp(-total_energy) + 1)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy) / (np.exp(total_energy) + 1)
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07061990740740741}
#island_id: 0
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy) / (np.exp(-total_energy) + np.exp(total_energy))
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy) / (np.exp(-total_energy) + np.exp(total_energy))
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = -1
        priorities[i][1] = -1
      else:
        priorities[i][0] = 1
        priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.09026805555555555}
#island_id: 0
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy)
    else:
      total_spin = sum(h[j][i%N] for j in range(N))
      if total_spin > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1 + np.sum([J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)])
      else:
        priorities[i][0] = 1
        priorities[i][1] = 1 - np.sum([J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)])
  return priorities




#score: {'data2D.txt': 0.046339660493827164}
#island_id: 0
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
    
    # Add a term that takes into account the interaction with all 8 nearest neighbors
    for j in range(N):
      for k in range(2):
        if J[k,i//N,j] > 0:
          neighbor_energy = h[j][i%N]
        else:
          neighbor_energy = -h[j][i%N]

        total_energy += neighbor_energy

    priorities[i][1] -= (h_site + total_energy) / abs(h[i//N][i%N])
  
  return(priorities)




#score: {'data2D.txt': 0.0687257716049383}
#island_id: 0
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if J[2,i//N,site_nbr] > 0:
      total_energy += sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])
    else:
      total_energy -= sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0023640432098765425}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        total_energy += h[nn_site][i%N]
      else:
        total_energy -= h[nn_site][i%N]

    total_energy /= abs(h[i//N][i%N])
    
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.06976620370370373}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  # Improved version
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0005550925925925927}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priority_minus = -np.exp(-h_site) * np.prod([1 + np.tanh(nn_energy) for nn_energy in nns])
    if J[3,i//N,site_nbr] > 0:
      priorities[i][0] = priority_minus
      priorities[i][1] = -priority_minus
    else:
      priorities[i][0] = -priority_minus
      priorities[i][1] = priority_minus
  
  return(priorities)




#score: {'data2D.txt': 0.0005550925925925927}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.exp(-h_site) * np.prod([1 + np.tanh(nn_energy) for nn_energy in nns])
    if J[3,i//N,site_nbr] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0005550925925925927}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(4): 
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j//2,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.exp(-h_site) * np.prod([1 + np.tanh(nn_energy) for nn_energy in nns])
    priorities[i][1] = -priorities[i][0] if J[3,i//N,site_nbr] > 0 else priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.08607608024691366}
#island_id: 1
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      for k in [0,3]:
        if J[k,i%N,i//N] > 0:
          priorities[i][0] += J[k,i%N,i//N]
          priorities[i][1] -= J[k,i%N,i//N]
        else:
          priorities[i][0] -= J[k,i%N,i//N]
          priorities[i][1] += J[k,i%N,i//N]
    else:
      for k in [0,3]:
        if J[k,i%N,i//N] > 0:
          priorities[i][0] -= J[k,i%N,i//N]
          priorities[i][1] += J[k,i%N,i//N]
        else:
          priorities[i][0] += J[k,i%N,i//N]
          priorities[i][1] -= J[k,i%N,i//N]

    if h[i//N][i%N] > 0:
      for k in [1,2]:
        if J[k,i%N,i//N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    else:
      for k in [1,2]:
        if J[k,i%N,i//N] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1,-1]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.052881018518518515}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16295138888888913}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.001845216049382715}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    total_spin1 = h[site_nbr1][i%N]
    total_spin2 = h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin1 += 1
        total_spin2 -= 1
      else:
        total_spin1 -= 1
        total_spin2 += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin1 + total_spin2, -total_spin1 - total_spin2]
    else:
      priorities[i] = [-total_spin1 - total_spin2, total_spin1 + total_spin2]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 7.7623456790123e-05}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add interactions from neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    # Adjust priorities based on magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.003483796296296297}
#island_id: 2
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      for k in range(4):
        total_spin += J[k,i//N,i%N]*h[(k+N-1)%N][i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = -h[site_nbr][i%N]
      for k in range(4):
        total_spin -= J[k,i//N,i%N]*-h[(k+N-1)%N][i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015992283950617286}
#island_id: 2
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i%N]*h[(k+N-1)%N][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00036003086419753125}
#island_id: 2
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += h[site_nbr][i%N]
      for k in range(3):
        total_spin += J[k,i//N,i%N]*h[(k+N-1)%N][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      for k in range(3):
        total_spin -= J[k,i//N,i%N]*-h[(k+N-1)%N][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1]:
      total_spin += J[k,i//N,i%N]*(h[(k+N-1)%N][i%N])
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions from all four neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Apply the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16587175925925948}
#island_id: 1
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i % N + ((2)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.012409722222222223}
#island_id: 1
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.0006174382716049383}
#island_id: 2
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    # add the contribution from the diagonally adjacent sites
    for j in range(N):
      if i % (N*N) < N:
        priorities[i][0] += J[2, i % N, j]
      else:
        priorities[i][0] -= J[2, i % N, j]

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0020763888888888893}
#island_id: 2
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbrs = [(i+1)%N, (i+N-1)%N, i-N]
    for j in range(N):
      if J[2,i%N,j] > 0:
        h_site += h[i//N][j]
      else:
        h_site -= h[i//N][j]

    priorities[i][0] = -np.sum([J[k,i%N,k-1]*abs(h[(k+2)%3][i%N]) for k in range(3)])

  return(priorities)




#score: {'data2D.txt': -0.00025077160493827124}
#island_id: 2
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      priorities[i][0] += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])

    priorities[i][0] -= (J[1,i%N,i//N]*h_site + sum([J[k,i%N,i//N]*h[(k+2)%3][i%N] for k in range(3)]))

    # add the contribution from the diagonally adjacent sites
    for j in range(N):
      if i % (N*N) < N:
        priorities[i][0] += J[2, i % N, j]
      else:
        priorities[i][0] -= J[2, i % N, j]

    # Calculate priority based on magnetism and interaction
    priority = abs(h_site)
    for k in range(3):
      if J[k,i%N,i//N]*h[(k+N-1)%N][i%N] > 0:
        priority += 1
      else:
        priority -= 1

    priorities[i][1] = -priority
  return(priorities)




#score: {'data2D.txt': 0.003238425925925926}
#island_id: 2
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    for k in range(3):
      total_spin += J[k,i%N,i//N]*abs(h[(k+N-1)%N][i%N])
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08007947530864197}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy) / (np.exp(-total_energy) + np.exp(total_energy))
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy) / (np.exp(-total_energy) + np.exp(total_energy))
    else:
      priorities[i][0] = -1 if np.random.rand() < 0.5 else 1
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0013640432098765436}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy)
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.09860663580246913}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_minus = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      energy_plus = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
      if energy_minus < energy_plus:
        priorities[i][0] = -1
        priorities[i][1] = np.exp(-energy_minus)
      else:
        priorities[i][0] = 1
        priorities[i][1] = np.exp(energy_plus)
    elif h[site_nbr][i%N] < 0:
      energy_plus = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
      if energy_minus > energy_plus:
        priorities[i][0] = -1
        priorities[i][1] = np.exp(-energy_minus)
      else:
        priorities[i][0] = 1
        priorities[i][1] = np.exp(energy_plus)
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07061990740740741}
#island_id: 0
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy)
    else:
      # Use a gradient-based optimization to find the optimal spin assignment
      def loss_func(x):
        return -total_energy * x + h[site_nbr][i%N]
      res = minimize(loss_func, [0], method="SLSQP")
      priorities[i][0] = int(np.round(res.x))
      priorities[i][1] = 1 if priorities[i][0] == -1 else -1
  return(priorities)




#score: {'data2D.txt': 0.002607253086419753}
#island_id: 3
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0024686728395061724}
#island_id: 3
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0035337962962962966}
#island_id: 3
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    priorities[i][0] += h_site * J[0, i//N, i//N]
    priorities[i][1] -= h_site * J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if total_h > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': 0.16239552469135826}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][k]
        priorities[i][1] -= h[site_nbr][k]
      else:
        priorities[i][0] -= h[site_nbr][k]
        priorities[i][1] += h[site_nbr][k]

  return(priorities)




#score: {'data2D.txt': 0.05414799382716051}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[2,(i+1)%N,i//N] > 0:
      priorities[i][0] += h[(i+1)%N,i//N]
      priorities[i][1] -= h[(i+1)%N,i//N]
    else:
      priorities[i][0] -= h[(i+1)%N,i//N]
      priorities[i][1] += h[(i+1)%N,i//N]
    
    if J[3,(i+N-1)%N,i//N] > 0:
      priorities[i][0] += h[(i+N-1)%N,i//N]
      priorities[i][1] -= h[(i+N-1)%N,i//N]
    else:
      priorities[i][0] -= h[(i+N-1)%N,i//N]
      priorities[i][1] += h[(i+N-1)%N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on interactions with neighbors
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on magnetism
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3, i%N, i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16465231481481507}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i//N]
      priorities[i][1] -= h[site_nbr1][i//N]
    else:
      priorities[i][0] -= h[site_nbr1][i//N]
      priorities[i][1] += h[site_nbr1][i//N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.0035337962962962966}
#island_id: 3
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    total_h = h[i//N][i%N]
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*total_h > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*total_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*total_h
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    priorities[i][0] += h_site * J[0, i//N, i//N]
    priorities[i][1] -= h_site * J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.003183179012345679}
#island_id: 3
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.002537500000000002}
#island_id: 3
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0, i//N, i//N]
      priorities[i][1] -= J[0, i//N, i//N]
    else:
      priorities[i][0] -= J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.0035337962962962966}
#island_id: 3
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    priorities[i][0] += h_site * J[0, i//N, i//N]
    priorities[i][1] -= h_site * J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.008857561728395063}
#island_id: 0
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        total_spin += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
      else:
        total_spin -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  return(priorities)




#score: {'data2D.txt': -0.00880324074074074}
#island_id: 2
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) + h[site_nbr][i%N]
    if total_h > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if total_h > 0:
      priorities[i][0] += total_h
      priorities[i][1] -= total_h
    else:
      priorities[i][0] -= total_h
      priorities[i][1] -= total_h

    # Check the symmetric neighbors
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[0,i%N,i//N] > 0:
        h_site = h[site_nbr][i%N]
      else:
        h_site = -h[site_nbr][i%N]

      total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if total_h > 0:
        priorities[i][0] += total_h
        priorities[i][1] -= total_h
      else:
        priorities[i][0] -= total_h
        priorities[i][1] -= total_h

    return(priorities)




#score: {'data2D.txt': -0.00880324074074074}
#island_id: 2
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if total_h > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 2
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.008286882716049384}
#island_id: 2
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    else:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': 0.0008970679012345674}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  priorities = np.array([p.argsort() for p in priorities])

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k, i//N, i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:, i//N, i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:, i//N, i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:, i//N, i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.008286882716049384}
#island_id: 2
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    else:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': 0.0005109567901234566}
#island_id: 2
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2 + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.008286882716049384}
#island_id: 2
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    else:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': -0.22177453703703706}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(3)]
    for j,site_nbr in enumerate(site_nbrs):
      if J[3,i//N,site_nbr] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[3,i//N,site_nbr] > 0:
      priorities[i][0] += h[site_nbr][2]
      priorities[i][1] -= h[site_nbr][2]
    else:
      priorities[i][0] -= h[site_nbr][2]
      priorities[i][1] += h[site_nbr][2]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0020328703703703685}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [np.sum([J[0,i//N,k] for k in range(N) if h[k][i%N] == h[i//N][i%N]]), 
               -np.sum([J[0,i//N,k] for k in range(N) if h[k][i%N] != h[i//N][i%N]])]
    else:
      priorities[i] = [-np.sum([J[0,i//N,k] for k in range(N) if h[k][i%N] == h[i//N][i%N]]), 
               np.sum([J[0,i//N,k] for k in range(N) if h[k][i%N] != h[i//N][i%N]])]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16297021604938294}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i-1)%N-1)%N) % N
    site_nbr_right = (i % N + ((i+1)%N-1)%N) % N
    site_nbr_up = (i//N*N + (i%N-1)%N) % (N*N)
    site_nbr_down = (i//N*N + (i%N+1)%N) % (N*N)
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[i//N,N-1-(i%N)]
      priorities[i][1] -= h[i//N,N-1-(i%N)]
    else:
      priorities[i][0] -= h[i//N,N-1-(i%N)]
      priorities[i][1] += h[i//N,N-1-(i%N)]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[i//N+1-(i//N),i%N]
      priorities[i][1] -= h[i//N+1-(i//N),i%N]
    else:
      priorities[i][0] -= h[i//N+1-(i//N),i%N]
      priorities[i][1] += h[i//N+1-(i//N),i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.25274861111111097}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    total_spin1 = h[site_nbr1][i%N]
    total_spin2 = h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin1 += 1
        total_spin2 += 1
      else:
        total_spin1 -= 1
        total_spin2 -= 1
    
    priorities[i][0] = total_spin1 + total_spin2
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin1 - total_spin2
    else:
      priorities[i][1] = total_spin1 + total_spin2
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = []
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_nbrs.append(h[site_nbr][i%N])
      else:
        site_nbrs.append(-h[site_nbr][i%N])
    
    priorities[i][0] += np.sum(site_nbrs)
    priorities[i][1] -= np.sum(site_nbrs)
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the spin energy from all nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the site's magnetism to the priority list
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 1
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_sum = np.sum(J[:,i//N,i//N])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + priority_sum, -total_spin - priority_sum]
    else:
      priorities[i] = [-total_spin - priority_sum, total_spin + priority_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.16119614197530888}
#island_id: 1
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i-1)%N - 1)) % N
    site_nbr_right = (i % N + ((i+1)%N - 1)) % N
    
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
    site_nbr_up = (i % N + ((int(i/N)-1)%N - 1)) % N
    if J[3,i//N,int(i/N)] > 0:
      priorities[i][0] += h[site_nbr_up][i%N]
      priorities[i][1] -= h[site_nbr_up][i%N]
    else:
      priorities[i][0] -= h[site_nbr_up][i%N]
      priorities[i][1] += h[site_nbr_up][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.051333179012345694}
#island_id: 0
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = np.sum(h[i//N])
    if h[i//N][i%N] > 0:
      spin_priority = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      spin_priority = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = total_spin + spin_priority
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0009270061728395061}
#island_id: 0
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = np.sum(h[i//N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    else:
      priorities[i][0] -= h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    if total_spin > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.002537500000000002}
#island_id: 3
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0, i//N, i//N]
      priorities[i][1] -= J[0, i//N, i//N]
    else:
      priorities[i][0] -= J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.002537500000000002}
#island_id: 3
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[1,i//N,i//N]*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Add the site's own magnetism to the priority
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0, i//N, i//N]
      priorities[i][1] -= J[0, i//N, i//N]
    else:
      priorities[i][0] -= J[0, i//N, i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.04388966049382716}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        continue
      for k in range(4):
        if k==3:
          continue
        neighbor = (site_nbr + ((k-1)%2 - 1)) % N
        if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
          continue
        priority_total[0] += J[k,i//N,nn_site]
        priority_total[1] -= J[k,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
  return(priorities)




#score: {'data2D.txt': -0.009136882716049384}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,nn_site]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009369290123456789}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,neighbor]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.13664830246913595}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    site_nbrs = []
    for j in range(4):
      site_nbr = ((i//N)%N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i%N] > 0:
        total_spin += J[j,i//N,i%N]
        site_nbrs.append(site_nbr)
      else:
        total_spin -= J[j,i//N,i%N]
    for site in site_nbrs:
      priorities[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        priorities[i][1] -= 2
      else:
        priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': -0.017716820987654324}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    site_nbr=((i//N)%N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = 4*total_spin + 1
      priorities[i][1] = -3*total_spin - 1
    else:
      priorities[i][0] = -4*total_spin - 1
      priorities[i][1] = 3*total_spin + 1
  return(priorities)




#score: {'data2D.txt': -0.3159054012345674}
#island_id: 0
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((i%N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 4*J[0,i//N,i%N]
      priorities[i][1] -= 3*J[0,i//N,i%N]
    for j in range(1,4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[j-1,i//N,i%N]
        priorities[i][1] -= J[j-1,i//N,i%N]
      else:
        priorities[i][0] -= J[j-1,i//N,i%N]
        priorities[i][1] += J[j-1,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 4
      priorities[i][1] -= 3
    else:
      priorities[i][0] -= 4
      priorities[i][1] += 3
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0010192901234567912}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if i < N**2/2:
      total_spin += sum([J[3, i%N, j] for j in range(N) if (j+1)%2 == 0])
    else:
      total_spin -= sum([J[3, i%N, j] for j in range(N) if (j+1)%2 == 0])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002895216049382717}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        site_nbr_sum -= h[site_nbr][i%N]
      else:
        total_spin -= 1
        site_nbr_sum += h[site_nbr][i%N]
    
    priorities[i][0] = total_spin + site_nbr_sum
    priorities[i][1] = -total_spin + site_nbr_sum
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][1]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.11366373456790137}
#island_id: 1
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.002420833333333334}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Calculate the priority of each spin based on its site and its neighbors
  for i in range(N**2):
    total_spin = h[i % N][i // N]
    if J[0,i//N,i//N] > 0:
      total_spin += 1
    elif J[0,i//N,i//N] < 0:
      total_spin -= 1
    
    priorities[i][0] += total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0008970679012345674}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  priorities = np.array([p.argsort() for p in priorities])

  return(priorities)




#score: {'data2D.txt': -0.0013766975308641975}
#island_id: 2
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h * N - sum([J[k,i%N,k//N]*h[(k+N-1)%N][i%N] for k in range(3)]) * (i % N)
      priorities[i][1] = -total_h * N + sum([J[k,i%N,k//N]*h[(k+N-1)%N][i%N] for k in range(3)]) * (i % N)
    else:
      priorities[i][0] = -total_h * N + sum([J[k,i%N,k//N]*h[(k+N-1)%N][i%N] for k in range(3)]) * (i % N)
      priorities[i][1] = total_h * N - sum([J[k,i%N,k//N]*h[(k+N-1)%N][i%N] for k in range(3)]) * (i % N)

  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 2
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.027422685185185192}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    total_spin = h[i//N][i%N]
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002577006172839506}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if nearest_neighbors_sum > 0:
      priorities[i][0] = h_site + nearest_neighbors_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nearest_neighbors_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002577006172839506}
#island_id: 3
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    total_spin = sum(nearest_neighbors)
    
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16317175925925947}
#island_id: 1
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,N//2] > 0:
      priorities[i][0] += h[site_nbr][N//2]
      priorities[i][1] -= h[site_nbr][N//2]
    else:
      priorities[i][0] -= h[site_nbr][N//2]
      priorities[i][1] += h[site_nbr][N//2]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,N//2,i%N] > 0:
      priorities[i][0] += h[N//2,site_nbr]
      priorities[i][1] -= h[N//2,site_nbr]
    else:
      priorities[i][0] -= h[N//2,site_nbr]
      priorities[i][1] += h[N//2,site_nbr]
    
  return(priorities)




#score: {'data2D.txt': -0.0012955246913580246}
#island_id: 1
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.16155540123456813}
#island_id: 1
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr2 = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    site_nbr3 = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]
    
    site_nbr4 = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr4][i%N]
      priorities[i][1] -= h[site_nbr4][i%N]
    else:
      priorities[i][0] -= h[site_nbr4][i%N]
      priorities[i][1] += h[site_nbr4][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.1040603395061729}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = h[i//N][i%N]
    
    if J[0,i//N,site_nbr] > 0:
      nn_energy = h[site_nbr][i%N]
    else:
      nn_energy = -h[site_nbr][i%N]

    if J[1,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = total_energy + nn_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11135015432098778}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4): # Added the diagonal neighbor
      if abs(i//N-j) <= 1 and abs((i%N)-j)%N<=1: # Check if it's a nearest neighbor
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          nn_energy = h[nn_site][i%N]
        else:
          nn_energy = -h[nn_site][i%N]

        nn_energy_sum += nn_energy
        nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.18029336419753106}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N]
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy -= h[i//N][i%N]
    else:
      total_energy += h[i//N][i%N]

    priorities[i][0] = nn_energy_sum * nn_count + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06733873456790126}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 2
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    
  return(priorities)




#score: {'data2D.txt': -0.005597376543209876}
#island_id: 2
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = total_h
    priorities[i][1] = -total_h
  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0808467592592593}
#island_id: 3
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = priorities[i].argsort()[::-1]
    else:
      priorities[i] = priorities[i].argsort()

  return(priorities)




#score: {'data2D.txt': 0.33847577160493725}
#island_id: 3
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
  
  # Sort priorities for each site
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = np.sort(priorities[i])
    else:
      priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
  
  return(priorities)




#score: {'data2D.txt': 0.0008970679012345674}
#island_id: 3
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = [J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  priorities = [np.argsort(p) for p in priorities]
  
  return(priorities)




#score: {'data2D.txt': -0.0006359567901234582}
#island_id: 1
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the interaction term
    J_sum = 0
    for k in range(4):
      if i // N == site_nbr or (k < 2 and i % N == (site_nbr + 1) % N) or (k >= 2 and i % N == (site_nbr - 1) % N):
        J_sum += np.sign(J[k, i%N, i//N])
    
    # update the priority based on total spin and interaction term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J_sum, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + J_sum]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    priority_sum = 0
    if total_spin > 0:
      for j in range(N):
        site_nbr = (i % N + ((j-1)%2 - 1)) % N
        if J[3,i%N,j] > 0 and h[site_nbr][j] > 0:
          priority_sum -= 1
        elif J[3,i%N,j] < 0 and h[site_nbr][j] < 0:
          priority_sum += 1
    else:
      for j in range(N):
        site_nbr = (i % N + ((j-1)%2 - 1)) % N
        if J[3,i%N,j] > 0 and h[site_nbr][j] < 0:
          priority_sum -= 1
        elif J[3,i%N,j] < 0 and h[site_nbr][j] > 0:
          priority_sum += 1
          
    priorities[i][0] = total_spin + priority_sum
    priorities[i][1] = -total_spin + priority_sum
    
  return(priorities)




#score: {'data2D.txt': 0.0026797839506172835}
#island_id: 0
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1) + j%2) % N
      if J[j//2,i//N,(i%N+j)%2] > 0:
        total_spin += h[site_nbr][(i%N+j)%2]
      else:
        total_spin -= h[site_nbr][(i%N+j)%2]
    if np.sum(J[:,i//N,i%N])*h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  return(priorities)




#score: {'data2D.txt': -0.0010050925925925921}
#island_id: 0
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  for i in range(N**2):
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
        priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': 0.06614212962962965}
#island_id: 0
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4): # Include diagonal neighbors as well
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06614212962962965}
#island_id: 0
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4):
      if j==0:
        nn_site = (site_nbr + ((j+1)%2 - 1)) % N
      elif j==1 or j==3:
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      else:
        nn_site = site_nbr
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.018087191358024692}
#island_id: 0
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4): # Added the diagonal term
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      for j in range(4): # Added the diagonal term
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
    else:
      for j in range(4): # Added the diagonal term
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Check if the site has a positive or negative magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.08508750000000005}
#island_id: 1
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0008513888888888884}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2
    for k in range(3):
      site_nbr = (k+N-1)%N
      if J[k, i%N, i//N] > 0:
        total_h += J[k, i%N, i//N]*h[site_nbr][i%N]
      else:
        total_h -= J[k, i%N, i//N]*h[site_nbr][i%N]

    if h_site1 > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': -0.0012013888888888892}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2
    for k in range(3):
      site_nbr3 = (k+N-1)%N
      if J[k,i%N,i//N] > 0:
        total_h += sum([h[site_nbr3][j] for j in range(N)])
      else:
        total_h -= sum([h[site_nbr3][j] for j in range(N)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.0005109567901234566}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2 + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.0053625}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_h += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N]])
      else:
        total_h -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N]])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': -0.032699845679012345}
#island_id: 3
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    total_spin = 0
    
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      
      if h[site_nbr][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      if J[1, i//N, i%N]*h[i//N][j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.009931018518518518}
#island_id: 3
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Prioritize spins that align with the local field
    if h_site > 0:
      priorities[i][0], priorities[i][1] = np.sort(priorities[i])
    else:
      priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Sort by the difference between positive and negative spins
    priorities[i] = np.sort(priorities[i], axis=0)[::-1].flatten()
  
  return(priorities)




#score: {'data2D.txt': 0.33847577160493725}
#island_id: 3
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = np.sort(priorities[i])
    else:
      priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))

  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priority_total[0], -priority_total[0]]
    else:
      priorities[i] = [-priority_total[0], priority_total[0]]
  
  return(priorities)




#score: {'data2D.txt': -0.1001560185185186}
#island_id: 1
#version_generated: 2
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0015893518518518516}
#island_id: 3
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    for k in range(3):
      total_spin[i][0] += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
      if J[k,i//N,i//N]*h[(k+N-1)%N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.0026319444444444446}
#island_id: 0
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016541666666666666}
#island_id: 0
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    nns = []
    for j in [(0,-1),(1,0),(-1,0),(0,1)]:
      nn_site = (site_nbr + j[0]) % N
      if abs(nn_site - i % N) == 1 and abs(nn_site // N - i // N) == 0: # horizontal neighbor
        nns.append(J[1,i//N,nn_site])
      elif abs(nn_site - i % N) == 0 and abs(nn_site // N - i // N) == 1: # vertical neighbor
        nns.append(J[2,i//N,nn_site])
      else: # diagonal neighbors
        if j[0] == 0:
          nns.append(J[3,i//N,nn_site])
        else:
          nns.append(J[0,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0020418209876543214}
#island_id: 0
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    if i > 0 and i < N**2 - 1:
      priorities[i][1] = np.mean([priorities[j][0] for j in range(max(0, i-N), min(i+N+1, N**2))])
    else:
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0023631172839506174}
#island_id: 0
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = np.exp(-2*priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.0023631172839506174}
#island_id: 0
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = np.exp(-2*priorities[i][0])
  return(priorities)




#score: {'data2D.txt': -0.24062700617283928}
#island_id: 0
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,site_nbr] * h[site_nbr][j] for j in range(4)) + h[i//N][i%N]
    priorities[i][0] = h[i//N][i%N] + total_energy
    priorities[i][1] = np.exp(-2*priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      neighbor_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i%N] > 0:
        total_spin += h[neighbor_nbr][i%N]
      else:
        total_spin -= h[neighbor_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  return(priorities)




#score: {'data2D.txt': -0.009849845679012348}
#island_id: 1
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0017304012345679015}
#island_id: 1
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0012476851851851848}
#island_id: 2
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i//N,i//N]+J[1,i//N,i//N]+J[2,i//N,i//N]>0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
  return(priorities)




#score: {'data2D.txt': -0.005597376543209876}
#island_id: 2
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N]
    j_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = total_h + j_sum
    priorities[i][1] = -total_h - j_sum
  return(priorities)




#score: {'data2D.txt': -0.0014544753086419757}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = h[site_nbr][i%N]
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        sum_h += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      else:
        sum_h -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
    if sum_h > 0:
      priorities[i][0] = -sum_h
      priorities[i][1] = sum_h
    else:
      priorities[i][0] = sum_h
      priorities[i][1] = -sum_h

  return(priorities)




#score: {'data2D.txt': -0.0007572530864197538}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)]) + h[site_nbr][i%N]
    if total_h > 0:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    else:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': 0.008286882716049384}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_h = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
    else:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h

  return(priorities)




#score: {'data2D.txt': 0.33847577160493725}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

    # Sort priorities for each site
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = np.sort(priorities[i])
    else:
      priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))

  return(priorities)




#score: {'data2D.txt': 0.33847577160493725}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]

  # Sort priorities for each site
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = np.sort(priorities[i])
    else:
      priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))

  # Return the priority for assigning spins to -1 and 1
  return priorities




#score: {'data2D.txt': -0.07568533950617289}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Apply the priority rules
    if h[i//N][i%N] > 0:
      if priorities[i][0] >= priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
    else:
      if priorities[i][0] < priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
    
  return(priorities)




#score: {'data2D.txt': 0.0012476851851851848}
#island_id: 2
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if J[0,i//N,i//N]+J[1,i//N,i//N]+J[2,i//N,i//N]>0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
  return(priorities)




#score: {'data2D.txt': -0.020934413580246912}
#island_id: 2
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i//N][i%N] for k in range(3)])
    if np.all(J[[0,1,2], i//N, i//N]>0):
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
  return(priorities)




#score: {'data2D.txt': 0.0032479938271604944}
#island_id: 2
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if np.sum([J[k,i//N,i//N]*np.sign(h[(k+N-1)%N][i%N]) for k in range(3)]) > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if total_h > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
  return(priorities)




#score: {'data2D.txt': -0.09065478395061734}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4): # include all nearest neighbors
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    total_energy = h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priority_sum = nn_energy_sum * nn_count + total_energy - J[1,i//N,site_nbr]
    else:
      priority_sum = nn_energy_sum * nn_count + total_energy + J[1,i//N,site_nbr]
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.052185648148148175}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4):
      if j == 0:
        nn_site = (site_nbr + 1) % N
      elif j == 1:
        nn_site = (site_nbr - 1) % N
      elif j == 2:
        nn_site = (site_nbr + ((i//N-1)%2 - 1)) % N
      else:
        nn_site = (i // N + ((i%N-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.08965046296296303}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4): # Added the fourth nearest neighbor
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[2,i//N,site_nbr] > 0: # Added the middle nearest neighbor for odd N
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      for j in range(4): # Added the fourth nearest neighbor
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
    else:
      for j in range(4): # Added the fourth nearest neighbor
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    return(priorities)




#score: {'data2D.txt': -0.005272067901234568}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = h[site_nbr][i%N]
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j, i//N, nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j, i//N, nn_site] > 0).astype(int)
    
    priority_sum = total_energy + nn_energy_sum * nn_count
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
    
    if h[site_nbr][i%N] > 0:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j, i//N, nn_site] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
    else:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j, i//N, nn_site] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': -0.07568533950617289}
#island_id: 3
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0., -1.] for _ in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    if h[i//N][i%N] > 0:
      if priorities[i][0] >= priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
    else:
      if priorities[i][0] < priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
  
  return(priorities)




#score: {'data2D.txt': -0.07568533950617289}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Apply the priority rules
    if h[i//N][i%N] > 0:
      if priorities[i][0] >= priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
    else:
      if priorities[i][0] < priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
  
  return(priorities)




#score: {'data2D.txt': -0.07568533950617289}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
    # Apply the priority rules
    if h[i//N][i%N] > 0:
      if priorities[i][0] >= priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
    else:
      if priorities[i][0] < priorities[i][1]:
        priorities[i][0], priorities[i][1] = np.sort(priorities[i])
      else:
        priorities[i][0], priorities[i][1] = np.flip(np.sort(priorities[i]))
  
  return(priorities)




#score: {'data2D.txt': 0.0014165123456790123}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nearest_neighbors = [J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]
    
    if sum(J[1:,i//N,i//N])*h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(nearest_neighbors) - sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(nearest_neighbors) + sum(J[1:,i//N,i//N])*h[i//N][i%N]
      priorities[i][1] = -priorities[i][0]
    
  return [list(x) for x in priorities]




#score: {'data2D.txt': 0.16813719135802496}
#island_id: 1
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin1 = h[site_nbr1][i%N]
    total_spin2 = h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin1 += 1
        total_spin2 -= 1
      else:
        total_spin1 -= 1
        total_spin2 += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin1 - total_spin2, total_spin2 + total_spin1]
    else:
      priorities[i] = [-total_spin1 - total_spin2, -total_spin2 + total_spin1]
    
  return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.054784413580246945}
#island_id: 1
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N if i % N != 0 else site_nbr1
    site_nbr4 = (i // N + ((i % N+1)%2 - 1)) % N if i // N != 0 else site_nbr2
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr2][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr2][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr4][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr4][i%N]
      priorities[i][1] += h[site_nbr3][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.005429166666666666}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2 + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h_site > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.00033719135802469065}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2
    for k in range(3):
      site_nbr = (k+N-1)%N
      total_h += J[k,i%N,i//N]*h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.003459104938271605}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    h_site1 = h[site_nbr1][i%N]
    h_site2 = h[site_nbr2][i//N]

    total_h = h_site1 + h_site2
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h

  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.001405401234567902}
#island_id: 3
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += 2*J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.004938734567901235}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N]])
      if sum(nearest_neighbors) > 0:
        priorities[i][0] += h_site + total_spin
        priorities[i][1] = -priorities[i][0]
        break
  return(priorities)




#score: {'data2D.txt': 0.002033179012345679}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.030958179012345686}
#island_id: 0
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    for j in range(N):
      for k in range(2):
        if J[k,i//N,j] > 0:
          neighbor_energy = h[j][i%N]
        else:
          neighbor_energy = -h[j][i%N]

        total_energy += neighbor_energy

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.016025462962962964}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
    
    # Add a term that takes into account the interaction with all 8 nearest neighbors
    for j in range(N):
      for k in range(2):
        if J[k,i//N,j] > 0:
          neighbor_energy = h[j][i%N]
        else:
          neighbor_energy = -h[j][i%N]

        total_energy += neighbor_energy

    priorities[i][1] -= (h_site + total_energy) / abs(h[i//N][i%N])
    
    # Add a term that takes into account the magnetism at each site
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]

  return(priorities)




#score: {'data2D.txt': -0.007472993827160494}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    nn_energy_sum = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nn_energy_sum += J[j,i//N,nn_site] * h[nn_site][i%N]

    total_energy = total_spin + nn_energy_sum

    priorities[i][0] = (total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.2023297839506173}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((i%N-1)//N - 1)) % N
    magnetism = h[site_nbr][i%N]
    interaction_sum = J[:, i//N, i%N].sum()
    total_spin = 0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)//N - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j, i//N, i%N]
      else:
        total_spin -= J[j, i//N, i%N]
    interaction_factor = -2.5 if magnetism > 0 else 2.5
    spin_factor = -3.5 if magnetism > 0 else -1.5
    priorities[i][0] = spin_factor * (total_spin + interaction_sum)
    priorities[i][1] = interaction_factor * (total_spin + interaction_sum)
  return(priorities)




#score: {'data2D.txt': -0.05801342592592593}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((i%N-1)%2 - 1)) % N
    total_spin=h[site_nbr][i%N]
    for j in range(4):
      if h[(site_nbr+(j-1)%2-N)%N][(i+((j-1)%2-1))%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    magnetism = h[i//N][i%N]
    interaction = J[:, i//N, i%N].sum()
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.002361882716049383}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    interaction = J[:, i//N, i%N].sum()
    if h[i//N][i%N] > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.013902932098765433}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N)
    total_spin=0
    for j in range(4):
      if abs(site_nbr - ((i%N)+(j-1)%2)) == 1:
        total_spin += h[(site_nbr + (i%N)+(j-1)%2)%N][i%N] * J[j,i//N,i%N]
    magnetism = h[i//N][i%N]
    interaction = np.sum(J[:, i//N, i%N])
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.0016183641975308642}
#island_id: 2
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(3):
      if h[(j+N-1)%N][i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
        
    total_h_site = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] = total_h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005480401234567902}
#island_id: 2
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h_site + neighbor_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors_sum = sum(J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3))
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if nearest_neighbors_sum > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.003582253086419754}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    nearest_neighbors = np.array([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    if sum(nearest_neighbors) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.08245910493827165}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism and nearest neighbor interactions
    priorities[i][0] = total_spin + h[i//N][i%N]
    priorities[i][1] = -total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.02019058641975309}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total spin based on interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # If h[i//N][i%N] > 0, set priorities to [total_spin, -total_spin]
    # Otherwise, set priorities to [-total_spin, total_spin]
    if np.sum(h[i//N]) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.001407253086419753}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i//N,i%N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    nn_sites = [(i+1)%N, (i+N-1)%N, (i+1)%N, (i+N-1)%N][(i%N*4 + i//N)%4]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16166496913580272}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0003523148148148152}
#island_id: 1
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i//N]
    else:
      total_spin -= h[site_nbr][i//N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism and interaction at each site
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.002854166666666667}
#island_id: 3
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin/4
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin/4
  return(priorities)




#score: {'data2D.txt': 0.0015069444444444442}
#island_id: 3
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h[int((i // N) % 2)][i % N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[int((i // N) % 2)][i % N] + total_spin
  return(priorities)




#score: {'data2D.txt': 0.002033179012345679}
#island_id: 3
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.0010575617283950626}
#island_id: 3
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04016589506172853}
#island_id: 1
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total interaction from neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Iterate over each site in the grid and update the priority based on interactions
  for i in range(N**2):
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16001774691358048}
#island_id: 1
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum(h[j,i%N] for j in range(N) if J[3,i%N,j] > 0)
      priorities[i][1] = -total_spin + sum(h[j,i%N] for j in range(N) if J[3,i%N,j] < 0)
    else:
      priorities[i][0] = -total_spin + sum(h[j,i%N] for j in range(N) if J[3,i%N,j] > 0)
      priorities[i][1] = total_spin - sum(h[j,i%N] for j in range(N) if J[3,i%N,j] < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.0017875000000000005}
#island_id: 3
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,N-1-i//N]*h[site_nbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.00349675925925926}
#island_id: 3
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.002033179012345679}
#island_id: 3
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.00620354938271605}
#island_id: 1
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[0,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    total_spin = np.sum([h[site_nbr][i%N] if J[k,i%N,i//N] > 0 else -h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbrs)])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_sum += 1
      else:
        neighbor_sum -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_sum, -total_spin - neighbor_sum]
    else:
      priorities[i] = [-total_spin - neighbor_sum, total_spin + neighbor_sum]
  return(priorities)




#score: {'data2D.txt': 0.07690231481481481}
#island_id: 0
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][1] = -total_energy
    priorities[i][0] = -priorities[i][1]
  return(priorities)




#score: {'data2D.txt': 0.0783621913580247}
#island_id: 0
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    if h[i%N][i%N] > 0:
      total_energy += 1
    else:
      total_energy -= 1
    for k in [-1,0,1]:
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005639969135802471}
#island_id: 2
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[site_nbr][j]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005797685185185186}
#island_id: 2
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i < N or (i >= 2*N and i % N == N - 1):
        # sites on the left boundary have lower priority
        priorities[i][0] -= 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i >= N and (i < 2*N or i % N == 0):
        # sites on the right boundary have higher priority
        priorities[i][0] += 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i < N or (i >= 2*N and i % N == N - 1):
        # sites on the left boundary have higher priority
        priorities[i][0] += 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i >= N and (i < 2*N or i % N == 0):
        # sites on the right boundary have lower priority
        priorities[i][0] -= 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005729783950617284}
#island_id: 2
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % (N*N) < N:
        # left edges have higher priority
        priorities[i][0] += 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      elif i % (N*N) > N*N - N:
        # right edges have lower priority
        priorities[i][0] -= 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += 0.5 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % (N*N) < N:
        # left edges have lower priority
        priorities[i][0] -= 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      elif i % (N*N) > N*N - N:
        # right edges have higher priority
        priorities[i][0] += 0.25 * sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0012060185185185184}
#island_id: 3
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,N-1-i//N]*h[site_nbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = np.sum(h*h) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum(h*h) + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0018189814814814815}
#island_id: 3
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,N-1-i//N]*h[site_nbr][i%N]
    total_spin -= sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0017875000000000005}
#island_id: 3
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,N-1-i//N]*h[site_nbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.001405401234567902}
#island_id: 3
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += 2*J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.001237191358024692}
#island_id: 3
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 2*J[k,i//N,i//N]
      else:
        total_spin -= 2*J[k,i//N,i//N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.0012921296296296298}
#island_id: 1
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if i < N:
      total_spin += J[3,i%N,0]
    if i >= N and i < 2*N:
      total_spin -= J[1,i%N,(i//N)-1]
    if i >= 2*N:
      total_spin += J[2,i%N,(i//N)%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004463117283950618}
#island_id: 1
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      total_spin = h[site_nbr][i%N]
    elif J[0,i%N,i//N] < 0:
      total_spin = -h[site_nbr][i%N]
    else:
      total_spin = 0
    
    for k in range(1,4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      elif J[k,i%N,i//N] < 0:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.002342746913580248}
#island_id: 1
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = np.sum([J[3,i//N,k] * h[k%N][k//N] for k in [(i//N-1)%N, (i//N+1)%N, i//N] if 0 <= k//N < N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0028890432098765437}
#island_id: 2
#version_generated: 2
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][j] for j in range(N)]) + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[site_nbr][j]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      J_sum = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.006397067901234568}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    priorities[i][0] = total_spin + 1
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0014177469135802472}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 2*J[k,i//N,i//N]
      else:
        total_spin -= 2*J[k,i//N,i//N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.001237191358024692}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 2*J[k,i//N,i//N]
      else:
        total_spin -= 2*J[k,i//N,i//N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.052865277777777775}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * (total_spin + np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * (total_spin - np.sum(J[:,i//N,i%N]))
  return(priorities)




#score: {'data2D.txt': 0.052865277777777775}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * (total_spin + np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * (total_spin - np.sum(J[:,i//N,i%N]))
  return(priorities)




#score: {'data2D.txt': 0.052865277777777775}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * (total_spin + np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * (total_spin - np.sum(J[:,i//N,i%N]))
  return(priorities)




#score: {'data2D.txt': 0.052865277777777775}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site][i%N] * J[:,i//N,i%N][site_nbrs.index(i % N)] for site in site_nbrs)
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 * (total_spin + np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2 * (total_spin - np.sum(J[:,i//N,i%N]))
  return(priorities)




#score: {'data2D.txt': 0.14101805555555574}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] if J[j,i//N,(i%N + ((j-1)%2 - 1)) % N]>0 else -J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0018902777777777787}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] if J[j,i//N,(i%N + ((j-1)%2 - 1)) % N]>0 else -J[j,i//N,(i%N + ((j-1)%2 - 1)) % N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.002854166666666667}
#island_id: 3
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin/4
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin/4
  return(priorities)




#score: {'data2D.txt': 0.0013010802469135805}
#island_id: 3
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if h[site_nbr][i%N] > 0:
        spin = 1
      else:
        spin = -1
      total_spin += J[k,i//N,i//N]*spin*h[i//N][i%N]
    if total_spin > 0:
      priorities[i][0] = h[site_nbr][i%N] + total_spin/4
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] + total_spin/4
  return(priorities)




#score: {'data2D.txt': 0.002854166666666667}
#island_id: 3
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin/4
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin/4
  return(priorities)




#score: {'data2D.txt': 0.002854166666666667}
#island_id: 3
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin/4
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin/4
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      else:
        priorities[i][0] = -sum([abs(h[site_nbr][j]) for j in range(N)]) + h_site + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      else:
        priorities[i][0] = sum([abs(h[site_nbr][j]) for j in range(N)]) - h_site - J_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015646604938271609}
#island_id: 1
#version_generated: 2
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    total_spin_row = h[site_nbr_row][i%N]
    total_spin_col = sum(J[k,i%N,site_nbr_col] for k in range(4))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_row + total_spin_col, -(total_spin_row + total_spin_col)]
    else:
      priorities[i] = [- (total_spin_row + total_spin_col), total_spin_row + total_spin_col]
  
  return(priorities)




#score: {'data2D.txt': 0.043531944444444456}
#island_id: 2
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = sum([h[j,i%N] for j in range(N)]) + sum([J[k,i//N,k] for k in range(4)])
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = -sum([h[j,i%N] for j in range(N)]) - sum([J[k,i//N,k] for k in range(4)])
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total energy of assigning a spin to each possible state
    pos_energy = sum([abs(h[j,i%N]) + J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k, j in zip(range(3), range(N))])
    neg_energy = -sum([abs(h[j,i%N]) + J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k, j in zip(range(3), range(N))])
    
    # Assign priorities based on the energy
    if pos_energy < neg_energy:
      priorities[i][0] = -pos_energy
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -neg_energy
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00021682098765432085}
#island_id: 3
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    for j in range(N):
      if i % N < j:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += J[3,i//N,j//N]*h[site_nbr][j%N]
      elif i % N > j:
        site_nbr = (i + ((j+1)%2 - 1)) % N
        total_spin -= J[3,i//N,j//N]*h[site_nbr][j%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0019387345679012346}
#island_id: 3
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = 2*h[site_nbr][i%N] - 1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -3.59567901234566e-05}
#island_id: 3
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
      site_k = (k+N-1)%N
      total_spin += J[k-1,i//N,i//N]*h[site_k][i%N]
    if sum([J[k-1,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.002033179012345679}
#island_id: 3
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin

  return(priorities)




#score: {'data2D.txt': 0.04249891975308645}
#island_id: 0
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

    if i % N == 0: 
      priorities[i][0] += J[3,i//N,i//N]*h[site_nbr][i%N]
      priorities[i][1] -= priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.04247083333333336}
#island_id: 0
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04247083333333336}
#island_id: 0
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04249706790123459}
#island_id: 0
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = sum([J[k,i//N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      total_spin = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        total_spin += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = total_spin + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      total_spin = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        total_spin -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = total_spin + h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    if i % N == 0 or i % N == N - 1:
      # boundary sites have higher priority
      J_sum_bound = sum([J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] += J_sum_bound
    elif (i % N) == (N - 1):
      # boundary sites have lower priority
      J_sum_bound = sum([J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] -= J_sum_bound

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11127824074074087}
#island_id: 1
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': 0.0010575617283950626}
#island_id: 3
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0014998456790123451}
#island_id: 3
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    total_spin /= np.sum([J[k,i//N,i//N] for k in range(4)])
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.186165277777778}
#island_id: 3
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[site][i%N]
      else:
        total_spin -= J[k,i//N,i//N]*h[site][i%N]
    priorities[i][0] = h_site + total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.049481018518518556}
#island_id: 0
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -nn_sum
      priorities[i][1] = priorities[i][0] + 2*h_site
    else:
      priorities[i][0] = nn_sum
      priorities[i][1] = priorities[i][0] - 2*h_site
  
  return(priorities)




#score: {'data2D.txt': 0.009607253086419753}
#island_id: 0
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)])
    
    priorities[i][0] = h_site + nn_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.009607253086419753}
#island_id: 0
#version_generated: 2
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)])
    
    total_priority = h_site + nn_sum
    priorities[i][0] = total_priority
    priorities[i][1] = -total_priority
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time22:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0014097222222222226}
#island_id: 1
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in [0,1]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for k in [2,3]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[i//N][i%N]
      else:
        total_spin -= h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.15830663580246937}
#island_id: 3
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k, i//N, i//N]*h[site][i%N]
      else:
        total_spin -= J[k, i//N, i//N]*h[site][i%N]
    priority = np.sign(h[site_nbr][i%N]) + total_spin
    priorities[i][0] = priority
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priority
    else:
      priorities[i][1] = priority
  return priorities




#score: {'data2D.txt': 0.004159722222222223}
#island_id: 3
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    total_spin = J[0, i//N, i//N] * h[i//N][i%N]
    for k in range(1,4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k, i//N, i//N] * h[site][i%N]
      else:
        total_spin -= J[k, i//N, i//N] * h[site][i%N]

    priorities[i][0] = -1 if total_spin < 0 else 1
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.18912175925925948}
#island_id: 3
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = 0
    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[site][i%N]
      else:
        total_spin -= J[k,i//N,i//N]*h[site][i%N]
    priorities[i][0] = h_site + total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.186165277777778}
#island_id: 3
#version_generated: 2
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0, i//N, i//N]*h[i//N][i%N]
    for k in range(1,4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += J[k, i//N, i//N]*h[site][i%N]
      else:
        total_spin -= J[k, i//N, i//N]*h[site][i%N]
    priorities[i][0] = h_site + total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005827314814814814}
#island_id: 0
#version_generated: 2
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority for each of the four neighbors
    for k in range(4):
      site = ((i//N + (k-1)%2 - 1)) % N*N
      if h[site//N][site%N] > 0:
        priorities[i][0] += J[k,i//N,i%N]
        priorities[i][1] -= 2*J[k,i//N,i%N]
      else:
        priorities[i][0] -= J[k,i//N,i%N]
        priorities[i][1] += 2*J[k,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.06907515432098768}
#island_id: 0
#version_generated: 2
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(2):
      site = (i % N + ((k)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += np.sum(J[:,i//N,site])
        priorities[i][1] -= 2*np.sum(J[:,i//N,site])
      else:
        priorities[i][0] -= np.sum(J[:,i//N,site])
        priorities[i][1] += 2*np.sum(J[:,i//N,site])
    
    # Add magnetism contribution
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.0009365740740740751}
#island_id: 0
#version_generated: 2
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin + J[0, i//N, i%N] + J[1, (i//N+1)%N, i%N] + J[2, i//N, (i%N+1)%N]
      priorities[i][1] -= 3*total_spin
    else:
      priorities[i][0] -= total_spin - J[0, i//N, i%N] - J[1, (i//N+1)%N, i%N] - J[2, i//N, (i%N+1)%N]
      priorities[i][1] += 3*total_spin
    
    for k in range(4):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] += np.sum(J[:,i//N,site])
       priorities[i][1] -= 2*np.sum(J[:,i//N,site])
     else:
       priorities[i][0] -= np.sum(J[:,i//N,site])
       priorities[i][1] += 2*np.sum(J[:,i//N,site])
  
  return(priorities)




#score: {'data2D.txt': 0.0018489197530864195}
#island_id: 0
#version_generated: 2
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
      priorities[i][0] += np.sum(J[:,i//N,site])
      priorities[i][1] -= 2*np.sum(J[:,i//N,site])
     else:
      priorities[i][0] -= np.sum(J[:,i//N,site])
      priorities[i][1] += 2*np.sum(J[:,i//N,site])
  
  return(priorities)




#score: {'data2D.txt': 0.001405401234567902}
#island_id: 3
#version_generated: 2
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += 2*J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -138565613539.98395}
#island_id: 3
#version_generated: 2
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0, i//N, i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += 2*J[k, i//N, i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.001405401234567902}
#island_id: 3
#version_generated: 2
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      total_spin += 2*J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 3
#version_generated: 2
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    for k in range(4):
      total_spin = 0
      site_nbr_2 = (i + ((k-1)%2 - 1)) % N
      if k < 3:
        total_spin += J[k,i//N,i//N]*h[site_nbr_2][i%N]
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0009591049382716059}
#island_id: 3
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i//N] != 0:
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k,i//N,i//N]*h[site_nbr][i%N]
    priorities[i][0] = -total_spin if sum([J[k,i//N,i//N]*h[site_nbr][i%N] for k in range(4) if J[k,i//N,i//N] != 0]) > 0 else total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.003943672839506173}
#island_id: 3
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0011016975308641974}
#island_id: 3
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0030754629629629626}
#island_id: 3
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.07749367283950617}
#island_id: 0
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy=h[site_nbr][i%N]+sum(J[k,i//N,i%N]*h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy>0:
      priorities[i][0]=-1
      priorities[i][1]=1
    elif total_energy<0:
      priorities[i][0]=1
      priorities[i][1]=-1
    else:
      min_val=float('inf')
      for s in [-1, 1]:
        energy=h[site_nbr][i%N]+sum(J[k,i//N,i%N]*s*h[(i+k-1)%N][i%N] for k in range(3))
        if abs(energy)<min_val:
          min_val=abs(energy)
          priorities[i][0]=s
          priorities[i][1]=-s
  return(priorities)




#score: {'data2D.txt': 0.07749367283950617}
#island_id: 0
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      min_val = float('inf')
      for s in [-1, 1]:
        energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * s * h[(i+k-1)%N][i%N] for k in range(3))
        if abs(energy) < min_val:
          min_val = abs(energy)
          priorities[i][0] = s
          priorities[i][1] = -s
  return(priorities)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 0
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    if total_spin[i][0] > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_spin[i][0] < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      if total_spin[i][0] > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
      elif total_spin[i][0] < 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
  return(priorities)




#score: {'data2D.txt': 0.00160570987654321}
#island_id: 0
#version_generated: 2
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_up = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    energy_down = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * -h[(i+k-1)%N][i%N] for k in range(3))
    if energy_up < energy_down:
      priorities[i][0] = 1
      priorities[i][1] = -1
    elif energy_down < energy_up:
      priorities[i][0] = -1
      priorities[i][1] = 1
    else:
      if np.random.rand() < 0.5:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = -1
        priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': -0.007758487654320988}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    priorities[i][0] = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.007831944444444443}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    
    for k in range(2):
      site_nbr = (i + ((k)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%2][i%N]
    
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.006501697530864196}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin += J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(1,4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,N-1]*h[(k+N-1)%N][i%N]
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.00349675925925926}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0, i//N, i//N] * h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k, i//N, i//N] * h[(k+N-1)%N][i%N]
    if sum([J[k, i//N, i//N] * h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.00349675925925926}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    interaction_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if interaction_sum > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0007930555555555566}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.003943672839506173}
#island_id: 3
#version_generated: 2
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[k,i//N,i//N]*h[(k+N-1)%N][i%N]
    if sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -sum([abs(h[site_nbr][j]) for j in range(N)]) + h_site + J_sum
        if i % N < N//2:
          priorities[i][1] = -priorities[i][0]
        else:
          priorities[i][1] = 1 - priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = sum([abs(h[site_nbr][j]) for j in range(N)]) - h_site - J_sum
        if i % N < N//2:
          priorities[i][1] = 1 - priorities[i][0]
        else:
          priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      else:
        neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum + neighbors_sum
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N == 0 or i % N == N - 1:
        priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      else:
        neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum + neighbors_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h[site_nbr][i%N] + J_sum
      priorities[i][1] = -priorities[i][0]
    else:
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h[site_nbr][i%N] - J_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      priorities[i][1] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      priorities[i][1] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
  return(priorities)




#score: {'data2D.txt': -0.0014998456790123451}
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    total_spin /= np.sum([J[k,i//N,i//N] for k in range(4)])
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0014998456790123451}
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    total_spin /= np.sum([J[k,i//N,i//N] for k in range(4)])
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': -0.0014998456790123451}
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    total_spin = J[0,i//N,i//N]*h[i//N][i%N]
    for k in range(3):
      sitenbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i//N]*h[sitenbr][i%N]
    total_spin /= np.sum([J[k,i//N,i//N] for k in range(4)])
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site + total_spin
  return(priorities)




#score: {'data2D.txt': 0.07940262345679022}
#island_id: 0
#version_generated: 2
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    total_energy += h[i//N][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.09998842592592604}
#island_id: 0
#version_generated: 2
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.09998842592592604}
#island_id: 0
#version_generated: 2
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,2))
  
  # Calculate total magnetism at each site
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin[i][0] += h[site_nbr1][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
      
  # Calculate priority for each site based on the interaction energy
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -sum([abs(h[j,i%N]) for j in range(N)]) + h_site + J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have higher priority
        priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      J_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = sum([abs(h[j,i%N]) for j in range(N)]) - h_site - J_sum
      if i % N == 0 or i % N == N - 1:
        # boundary sites have lower priority
        priorities[i][0] -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0017850308641975316}
#island_id: 2
#version_generated: 2
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if i//N == (k+N-1)%N and i%N == ((k+1)%3)*((i//N-1)%2 + 1):
        site_nbr = (site_nbr + ((k+1)%3 - 1)) % N
      elif i//N == (k+N-1)%N:
        if k%2 == 0:
          site_nbr = (site_nbr + ((k-1)%2 - 1)) % N
        else:
          site_nbr = (site_nbr + (k-1)%2) % N
      elif i%N == ((k+1)%3)*((i//N-1)%2 + 1):
        site_nbr = (site_nbr + (k-1)%2) % N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1434257716049384}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024279320987654323}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0:
      priorities[i][0] = h_site + 2*sum([abs(J[k,i%N,i//N])*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - 2*sum([abs(J[k,i%N,i//N])*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.025990586419753086}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          priorities[i][0] += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          priorities[i][0] -= J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.02621219135802469}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14520046296296304}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.025990586419753086}
#island_id: 2
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.05710354938271605}
#island_id: 0
#version_generated: 2
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    site_energy = h[site_nbr][i%N]
    total_energy = site_energy + nn_energy
    if total_energy > 0:
      priorities[i][0] += (total_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (abs(total_energy)) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.012192438271604938}
#island_id: 0
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    total_energy = h[site_nbr][i%N] + nn_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += (total_energy + np.sum(h)) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (total_energy - np.sum(h)) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    magnetism = h[site_nbr][i%N]
    total_spin = np.sum(h)
    
    # Check if the site is near the edge
    edge_energy = 0
    if i % N == 0 or i % N == N-1:
      edge_energy += sum(J[k,0,i%N] * (h[(i+k)%N][i%N] if k % 2 == 0 else -h[(i+k)%N][i%N]) for k in range(4))
    if i // N == 0 or i // N == N-1:
      edge_energy += sum(J[k,i//N,0] * (h[(i+k-1)%N][0] if k % 2 == 0 else -h[(i+k-1)%N][0]) for k in range(4))
    
    # Calculate the priority
    if magnetism > 0:
      priorities[i][0] += (magnetism + nn_energy + edge_energy) / 3
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= (magnetism - nn_energy - edge_energy) / 3
      priorities[i][1] += 2
    
  return(priorities)




#score: {'data2D.txt': 0.02621219135802469}
#island_id: 2
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  for i in range(N2):
    site_nbr=(i % N + ((i//N-1)%2 - 1)) % N
    h_site=h[site_nbr][i%N]
    total_spin=0
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin+=J[k,i//N,i%N]*h[(i//N+k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0]=h_site+total_spin
      priorities[i][1]=-priorities[i][0]
    else:
      priorities[i][0]=-h_site-total_spin
      priorities[i][1]=-priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.02621219135802469}
#island_id: 2
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    for k in range(4):
      if k == 0 and i % N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 1 and i % N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 2 and i // N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 3 and i // N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.11932515432098775}
#island_id: 2
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] if h[i//N][i%N] > 0 else -h[i//N][i%N]
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00016126543209876468}
#island_id: 2
#version_generated: 2
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 0
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    for j in range(2):
      if j==0:
        priorities[i][j] = h_site + total_spin
      else:
        priorities[i][j] = -priorities[i][1-j]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0019418209876543217}
#island_id: 1
#version_generated: 2
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism and interaction
    total_spin = h[site_nbr][i%N]
    interaction = J[(i // N) % 4, i % N, i // N]
    
    if interaction > 0:
      priorities[i] = [total_spin + interaction, -total_spin - interaction]
    else:
      priorities[i] = [-total_spin - interaction, total_spin + interaction]
  
  return(priorities)




#score: {'data2D.txt': -0.005268672839506173}
#island_id: 1
#version_generated: 2
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': -0.006759104938271605}
#island_id: 0
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority for each of the four neighbors
    for k in range(4):
      site = ((i//N + (k-1)%2 - 1)) % N*N
      if h[site//N][site%N] > 0:
        priorities[i][0] += J[k,i//N,i%N]
        priorities[i][1] -= 2*J[k,i//N,i%N]
      else:
        priorities[i][0] -= J[k,i//N,i%N]
        priorities[i][1] += 2*J[k,i//N,i%N]

    # Calculate the priority based on the site's total spin and magnetism
    site_spin = np.sum(J[:,i//N,i%N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += site_spin
      priorities[i][1] -= site_spin
    else:
      priorities[i][0] -= site_spin
      priorities[i][1] += site_spin

  return(priorities)




#score: {'data2D.txt': -0.005827314814814814}
#island_id: 0
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority for each of the four neighbors
    for k in range(4):
      site = ((i//N + (k-1)%2 - 1)) % N*N
      if h[site//N][site%N] > 0:
        priorities[i][0] += J[k,i//N,i%N]
        priorities[i][1] -= 2*J[k,i//N,i%N]
      else:
        priorities[i][0] -= J[k,i//N,i%N]
        priorities[i][1] += 2*J[k,i//N,i%N]
    
    # Apply a simple heuristic to reduce the computation
    if priorities[i][0] > priorities[i][1]:
      priorities[i] = [priorities[i][0], -1]
    elif priorities[i][0] < priorities[i][1]:
      priorities[i] = [-1, priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': -0.003691203703703703}
#island_id: 0
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority for each of the four neighbors
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N*N
      if h[site_nbr//N][site_nbr%N] > 0:
        priorities[i][0] += J[k,i//N,i%N]
        priorities[i][1] -= 2*J[k,i//N,i%N]
      else:
        priorities[i][0] -= J[k,i//N,i%N]
        priorities[i][1] += 2*J[k,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.016795216049382715}
#island_id: 0
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority for each of the four neighbors
    for k in range(4):
      site = ((i//N + (k-1)%2 - 1)) % N*N
      if h[site//N][site%N] > 0:
        priorities[i][0] += J[k,i//N,i%N]
        priorities[i][1] -= 2*J[k,i//N,i%N]
      else:
        priorities[i][0] -= J[k,i//N,i%N]
        priorities[i][1] += 2*J[k,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time22:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.14520046296296304}
#island_id: 2
#version_generated: 2
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002526080246913581}
#island_id: 2
#version_generated: 2
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = 2*h[i//N][i%N] + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1461189814814816}
#island_id: 2
#version_generated: 2
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14520046296296304}
#island_id: 2
#version_generated: 2
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.13405941358024712}
#island_id: 1
#version_generated: 2
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    for k in range(3):
      if J[k+1,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
      
  return(priorities)




#score: {'data2D.txt': -0.1632081790123459}
#island_id: 1
#version_generated: 2
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16598719135802492}
#island_id: 1
#version_generated: 2
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N] + h[site_nbr3][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.13907021604938283}
#island_id: 2
#version_generated: 2
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16239552469135826}
#island_id: 1
#version_generated: 2
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.009774845679012344}
#island_id: 1
#version_generated: 2
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.04161219135802469}
#island_id: 1
#version_generated: 2
#generate time22:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = total_spin + magnetism
    priorities[i][1] = -total_spin - magnetism
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.007523302469135803}
#island_id: 0
#version_generated: 2
#generate time22:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N:i//N+1,i%N:i%N+1])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N:i//N+1,i%N:i%N+1])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.004204475308641976}
#island_id: 0
#version_generated: 2
#generate time22:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N:i//N+1,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N:i//N+1,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += 2*total_spin_left + total_spin_right
      priorities[i][1] -= 2*(2*total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= 2*total_spin_left + total_spin_right
      priorities[i][1] += 2*(2*total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.007523302469135803}
#island_id: 0
#version_generated: 2
#generate time22:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = np.sum(J[0,i//N:i//N+1,i%N])*h[site_nbr][i%N]
    total_spin_right = np.sum(J[1,i//N:i//N+1,i%N])*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_left + total_spin_right
      priorities[i][1] -= 2*(total_spin_left + total_spin_right)
    else:
      priorities[i][0] -= total_spin_left + total_spin_right
      priorities[i][1] += 2*(total_spin_left + total_spin_right)

  return(priorities)




#score: {'data2D.txt': 0.013923302469135802}
#island_id: 2
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          priorities[i][0] += J[k,i//N,i%N]
      priorities[i][0] *= -2
    else:
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          priorities[i][0] -= J[k,i//N,i%N]
      priorities[i][0] *= -2
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.007277932098765432}
#island_id: 3
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] - J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] + J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0023223765432098765}
#island_id: 3
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    spin_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if spin_sum > 0:
      priorities[i][0] = h_site + spin_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - spin_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013223765432098752}
#island_id: 3
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if (k == 1 and i % N != 0) or (k == 2 and i // N != N-1): 
        if J[k,i%N,i//N] > 0:
          h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
        else:  
          h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0006736111111111107}
#island_id: 3
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for d in [(0,1), (0,-1), (-1,0), (1,0)]:
      k = i + N*d[0] + d[1]
      if 0 <= k < N**2 and J[(k//N)%4,i//N,k%N] > 0:
        h_site += J[(k//N)%4,i//N,k%N]*h[k//N][k%N]

    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N) % N

    total_spin0 = h[site_nbr1][i%N]
    total_spin1 = h[site_nbr2][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin0 += 1
        total_spin1 -= 1
      else:
        total_spin0 -= 1
        total_spin1 += 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin0, -total_spin0]
    else:
      priorities[i] = [-total_spin0, total_spin0]

  return(priorities)




#score: {'data2D.txt': 0.2504004629629628}
#island_id: 1
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N]>0 else total_spin

  return(priorities)




#score: {'data2D.txt': 0.08691466049382725}
#island_id: 1
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction from left and right neighbors
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if i % N > 0:
      site_nbr = (i - 1) % N + ((i-1)//N-1)%2
      if J[3,i//N,(i-1)%N] > 0:
        total_spin += h[site_nbr][(i-1)%N]
        priorities[i][0] -= h[site_nbr][(i-1)%N]
        priorities[i][1] += h[site_nbr][(i-1)%N]
      else:
        total_spin -= h[site_nbr][(i-1)%N]
        priorities[i][0] += h[site_nbr][(i-1)%N]
        priorities[i][1] -= h[site_nbr][(i-1)%N]
    
    # Add interaction from top and bottom neighbors
    if i // N > 0:
      site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
      if J[1,i//N,(i//N-1)//N] > 0:
        total_spin += h[site_nbr][(i//N-1)//N*N+i%N]
        priorities[i][0] -= h[site_nbr][(i//N-1)//N*N+i%N]
        priorities[i][1] += h[site_nbr][(i//N-1)//N*N+i%N]
      else:
        total_spin -= h[site_nbr][(i//N-1)//N*N+i%N]
        priorities[i][0] += h[site_nbr][(i//N-1)//N*N+i%N]
        priorities[i][1] -= h[site_nbr][(i//N-1)//N*N+i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 4.552469135802495e-05}
#island_id: 2
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.000590895061728395}
#island_id: 2
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % N == 0 or i % N == N-1:  # boundary site
      priorities[i][0] = h_site
      priorities[i][1] = -h_site
    elif (i//N) % 2 == 0:  # even row
      priorities[i][0] = h_site + J[1,i%N,i//N]*h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:  # odd row
      priorities[i][0] = h_site + J[2,i%N,i//N]*h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.14259675925925944}
#island_id: 0
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_energy + site_energy
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_energy + site_energy
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.14259675925925944}
#island_id: 0
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    site_energy = sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    site_bias = h[site_nbr][i%N]
    
    if site_bias > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
    total_priority = (total_energy + site_energy) * site_bias
    priorities[i][0] = total_priority
  
  return(priorities)




#score: {'data2D.txt': 0.1461189814814816}
#island_id: 2
#version_generated: 2
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.13069645061728408}
#island_id: 2
#version_generated: 2
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.17391929012345664}
#island_id: 2
#version_generated: 2
#generate time22:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

    # Add magnetism term for nearest neighbors
    if i % N > 0: 
      priorities[i][0] += h[i//N][i%N] + h[(i//N + (i%N-1)%2 - 1) % N][i%N]
      priorities[i][1] -= priorities[i][0]
    if i % N < N-1: 
      priorities[i][0] += h[i//N][i%N] + h[(i//N + (i%N+1)%2 - 1) % N][i%N]
      priorities[i][1] -= priorities[i][0]
    if i // N > 0: 
      priorities[i][0] += h[i//N][i%N] + h[(i//N-1)%N][i%N]
      priorities[i][1] -= priorities[i][0]
    if i // N < N-1: 
      priorities[i][0] += h[i//N][i%N] + h[(i//N+1)%N][i%N]
      priorities[i][1] -= priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0014979938271604935}
#island_id: 1
#version_generated: 2
#generate time22:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      for j in range(N):
        site_nbr = (i % N + ((j-1)%2 - 1)) % N
        if J[3,i%N,j] > 0:
          if h[site_nbr][j] > 0:
            priorities[i][0] += 1
            priorities[i][1] -= 1
          else:
            priorities[i][0] -= 1
            priorities[i][1] += 1
        else:
          if h[site_nbr][j] > 0:
            priorities[i][0] -= 1
            priorities[i][1] += 1
          else:
            priorities[i][0] += 1
            priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time22:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15990385802469148}
#island_id: 2
#version_generated: 2
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

    # Compute the priority based on the site interactions and magnetism
    if h_site > 0:
      priorities[i][0] += sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] += priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14887546296296306}
#island_id: 2
#version_generated: 2
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)]) + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0032091049382716045}
#island_id: 2
#version_generated: 2
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if k == 0 and i % N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 1 and i % N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 2 and i // N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 3 and i // N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if J[3,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_nbr_spin = [h[site_nbr][i%N] if J[k,i//N,i%N] > 0 else -h[site_nbr][i%N] for k, site_nbr in zip(range(4), site_nbrs)]

    total_spin = sum(site_nbr_spin)

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.08245910493827165}
#island_id: 1
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    total_spin += magnetism
    
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.007277932098765432}
#island_id: 3
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] - J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] + J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0022683641975308646}
#island_id: 3
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] - J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] + J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])

  return(priorities)




#score: {'data2D.txt': -0.009052314814814813}
#island_id: 2
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if k == 0 and i % N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 1 and i % N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 2 and i // N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 3 and i // N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -(priorities[i][0]+2)
    else:
      priorities[i][0] = -(total_spin+2)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.001407253086419753}
#island_id: 2
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    total_spin = sum(h[site_nbr][i%N] * J[k, i//N, i%N] for k, site_nbr in enumerate(site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0032091049382716045}
#island_id: 2
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if k == 0 and i % N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 1 and i % N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 2 and i // N > 0:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      elif k == 3 and i // N < N-1:
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.11002361111111111}
#island_id: 2
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if k == 0 and i % N > 0:
        total_spin += J[k,i//N,i%N]*(h[(i//N + k % 2 - 1) % N][i%N] - h[site_nbr][i%N])
      elif k == 1 and i % N < N-1:
        total_spin += J[k,i//N,i%N]*(h[(i//N + k % 2 - 1) % N][i%N] - h[site_nbr][i%N])
      elif k == 2 and i // N > 0:
        total_spin += J[k,i//N,i%N]*(h[(i//N + k % 2 - 1) % N][i%N] - h[site_nbr][i%N])
      elif k == 3 and i // N < N-1:
        total_spin += J[k,i//N,i%N]*(h[(i//N + k % 2 - 1) % N][i%N] - h[site_nbr][i%N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.0019180555555555559}
#island_id: 0
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.14108503086419774}
#island_id: 0
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.20846033950617282}
#island_id: 0
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4))
    total_spin *= h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    
    # Improved priority calculation
    if J[1,i//N,site_nbr]>0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.00017237654320987643}
#island_id: 0
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = J[1,i//N,site_nbr] * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      total_energy += J[3,i//N,site_nbr]
    else:
      total_energy -= J[3,i//N,site_nbr]

    priorities[i][0] = -np.tanh(total_energy + nn_energy)
    priorities[i][1] = 1 + np.tanh(total_energy + nn_energy)
  return(priorities)




#score: {'data2D.txt': -0.006181944444444445}
#island_id: 0
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      total_energy += J[3,i//N,site_nbr]
    else:
      total_energy -= J[3,i//N,site_nbr]

    priorities[i][0] = total_energy + nn_energy
    priorities[i][1] = -priorities[i][0] if h[i//N][i%N] > 0 else -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.006745216049382716}
#island_id: 0
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,site_nbr] * h[(k+1)%4][i%N] for k in [1,2])
    if J[3,i//N,site_nbr] > 0:
      total_energy += J[3,i//N,site_nbr]
    else:
      total_energy -= J[3,i//N,site_nbr]

    priorities[i][0] = total_energy + nn_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.004064969135802468}
#island_id: 0
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = (J[0,i//N,site_nbr] + J[1,i//N,site_nbr]) * h[i//N][site_nbr]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += J[3,i//N,site_nbr]
    else:
      nn_energy -= J[3,i//N,site_nbr]

    priorities[i][0] = h[site_nbr][i%N] + nn_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0003202160493827157}
#island_id: 3
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] - J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] + J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])

    site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      priorities[i][0] += J[0,site_nbr_up,i//N]*h[site_nbr_up][i%N] - J[0,site_nbr_down,i//N]*h[site_nbr_down][i%N]
      priorities[i][1] -= 2*J[0,site_nbr_up,i//N] + 2*J[0,site_nbr_down,i//N]
    else:
      priorities[i][0] += -J[0,site_nbr_up,i//N]*h[site_nbr_up][i%N] + J[0,site_nbr_down,i//N]*h[site_nbr_down][i%N]
      priorities[i][1] -= 2*J[0,site_nbr_up,i//N] - 2*J[0,site_nbr_down,i//N]

  return(priorities)




#score: {'data2D.txt': 0.004347376543209877}
#island_id: 3
#version_generated: 2
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if J[0,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i%N])
  return(priorities)




#score: {'data2D.txt': -0.0705983024691358}
#island_id: 3
#version_generated: 2
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    interaction_energy = np.sum([J[k, i//N, i%N]*h[(k+((i-1)%2 - 1)) % N][j] for k in range(4) if (k == 0 and j < N//2) or (k == 1 and j >= N//2) or (k == 2 and j < N//2 and i % 2 == 0) or (k == 3 and j >= N//2 and i % 2 != 0)])

    priorities[i][0] = total_spin + interaction_energy
    priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i%N])
  return(priorities)




#score: {'data2D.txt': -0.003074228395061728}
#island_id: 3
#version_generated: 2
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if J[0,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    total_energy = 2*h[site_nbr][i%N]*total_spin + np.sum(J[:,i//N,i%N])
    priorities[i][0] = -total_spin
    priorities[i][1] = -priorities[i][0] - total_energy
  return(priorities)




#score: {'data2D.txt': -0.0014847222222222223}
#island_id: 3
#version_generated: 2
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if J[0,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]

    priority_total = [total_spin, -total_spin - 2*np.sum(J[:,i//N,i%N])]
    priorities[i] = np.array(sorted((priority_total[1], priority_total[0])))
  return(priorities)




#score: {'data2D.txt': -0.0012038580246913585}
#island_id: 3
#version_generated: 2
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][0]
    if h[site_nbr][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.0007260802469135795}
#island_id: 2
#version_generated: 2
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        h_site += J[k,i%N,i//N]*h[site_nbr][i%N]
      else:
        h_site -= J[k,i%N,i//N]*h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.2514186728395062}
#island_id: 0
#version_generated: 2
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    site_nbr=((i//N)%N + ((2-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    site_nbr=((i//N)%N + ((1-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[2,i//N,i%N]
      priorities[i][1] -= J[2,i//N,i%N]
    site_nbr=((i//N)%N + ((0-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]
      priorities[i][1] -= J[3,i//N,i%N]
  return(priorities)




#score: {'data2D.txt': 0.0025091049382716052}
#island_id: 0
#version_generated: 2
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    interaction = J[:, i//N, i%N].sum()
    if interaction > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': 0.07503225308641975}
#island_id: 0
#version_generated: 2
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin=0
    interaction = 0
    for j in range(4):
      site_nbr=((i//N)%N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin += J[j,i//N,i%N]
        interaction += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
        interaction -= J[j,i//N,i%N]
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.0022683641975308646}
#island_id: 3
#version_generated: 2
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] - J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[0,site_nbr_left,i//N]*h[site_nbr_left][i%N] + J[0,site_nbr_right,i//N]*h[site_nbr_right][i%N]
      priorities[i][1] = -priorities[i][0] - 2*np.sum(J[:,i//N,i//N])

  return(priorities)




#score: {'data2D.txt': 0.00446712962962963}
#island_id: 3
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(-h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(-h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.023259722222222223}
#island_id: 0
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = -total_energy if np.sum(h[i//N]) < 0 else 1
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.04097700617283951}
#island_id: 0
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    if np.sum(h[i//N]) < 0:
      priorities[i][0] = -total_energy
    else:
      priorities[i][0] = total_energy
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.003391820987654321}
#island_id: 0
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priority_sum = np.sum(J[1, i//N, :]) - np.sum(J[0, i//N, :])
    if np.sum(h[i//N]) < 0:
      priorities[i][0] = -total_energy + priority_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = total_energy - priority_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.054238734567901244}
#island_id: 0
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [-1,0,1]:
      if k == 0:
        continue
      x = i+k*N
      y = (i%N)+k
      if 0 <= x < N**2 and 0 <= y < N:
        total_energy += J[abs(k),i//N,x%N] * h[x%N][y]
    priorities[i][0] = np.sum(h[i//N]) > 0
    priorities[i][1] = 1 - priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.005088734567901234}
#island_id: 3
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site_left = h[site_nbr_left][i%N]
      h_site_right = h[site_nbr_right][i%N]
      left_spin = 1 if np.random.rand() < np.exp(h_site_left) else -1
      right_spin = 1 if np.random.rand() < np.exp(-h_site_right) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site_left = -h[site_nbr_left][i%N]
      h_site_right = -h[site_nbr_right][i%N]
      left_spin = 1 if np.random.rand() < np.exp(-h_site_left) else -1
      right_spin = 1 if np.random.rand() < np.exp(h_site_right) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0033464506172839505}
#island_id: 3
#version_generated: 2
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(-h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(-h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]

    # Add the interactions with next row sites if it exists
    if i % (N*N) < N:
      site_nbr_left_row = ((i % N + ((i//N)%2 - 1)) % N)
      site_nbr_right_row = ((i % N + ((i//N+1)%2 - 1)) % N)

      h_site = J[1, site_nbr_left_row, i//N]
      priorities[i][0] += h_site
      priorities[i][1] -= h_site

  return(priorities)




#score: {'data2D.txt': 0.003774537037037037}
#island_id: 3
#version_generated: 2
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(-h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(-h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002415123456790127}
#island_id: 3
#version_generated: 2
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    J_left = J[0, site_nbr_left, i//N]
    J_right = J[0, site_nbr_right, i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J_left, -J_right]) + h_site_left
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum([-J_left, J_right]) - h_site_left
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16453194444444466}
#island_id: 1
#version_generated: 2
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_lr = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_ud = (i // N + ((i % N-1)%2 - 1)) // N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr_lr][i%N]
      total_spin -= h[site_nbr_ud][i//N]
    else:
      total_spin -= h[site_nbr_lr][i%N]
      total_spin += h[site_nbr_ud][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16223996913580271}
#island_id: 1
#version_generated: 2
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11232021604938285}
#island_id: 1
#version_generated: 2
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        h_site += 1
      else:
        h_site -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [h_site, -h_site]
    else:
      priorities[i] = [-h_site, h_site]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0032165123456790123}
#island_id: 0
#version_generated: 2
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[k][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,(i+k-2*N)//N]*x for k, x in [(k, ((h[site_nbr][j]+total_spin/4)+1)) if (k+i-N)//N == j else (k, (h[site_nbr][j]-total_spin/4)-1) for k, j in [(k, (k+i-N)//N) for k in range(4)]]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,(i+k-2*N)//N]*x for k, x in [(k, ((h[site_nbr][j]-total_spin/4)-1)) if (k+i-N)//N == j else (k, (h[site_nbr][j]+total_spin/4)+1) for k, j in [(k, (k+i-N)//N) for k in range(4)]]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.001837808641975309}
#island_id: 0
#version_generated: 2
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[k][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*(h[site_nbr][j]+total_spin/4) for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*(h[site_nbr][j]-total_spin/4) for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    if J[0, i%N, i//N] > 0:
      priorities[i][0] = np.exp(h_site_left) + np.exp(-h_site_right)
      priorities[i][1] = -np.exp(h_site_left) - np.exp(-h_site_right)
    else:
      priorities[i][0] = -np.exp(-h_site_left) - np.exp(h_site_right)
      priorities[i][1] = np.exp(-h_site_left) + np.exp(h_site_right)

  return(priorities)




#score: {'data2D.txt': 0.0015958333333333339}
#island_id: 3
#version_generated: 2
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site = h[site_nbr_left][i%N]
    priorities[i][0] = J[0, site_nbr_left, i//N]*np.exp(h_site) + J[0, site_nbr_right, i//N]*np.exp(-h_site)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015958333333333339}
#island_id: 3
#version_generated: 2
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      priorities[i][0] += J[0, site_nbr_left, i//N]*np.exp(h_site) + J[0, site_nbr_right, i//N]*np.exp(-h_site)
      priorities[i][1] -= priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      priorities[i][0] += J[0, site_nbr_left, i//N]*np.exp(-h_site) + J[0, site_nbr_right, i//N]*np.exp(h_site)
      priorities[i][1] -= priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.005960956790123458}
#island_id: 3
#version_generated: 2
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      left_spin = np.sign(np.cosh(h[site_nbr_left][i%N]))
      right_spin = np.sign(np.cosh(-h[site_nbr_right][i%N]))

      priorities[i][0] = (J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      left_spin = np.sign(np.cosh(-h[site_nbr_left][i%N]))
      right_spin = np.sign(np.cosh(h[site_nbr_right][i%N]))

      priorities[i][0] = (J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0008989197530864195}
#island_id: 3
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if (k == 1 and i % N != 0) or (k == 2 and i // N != N-1): 
        if J[k,i%N,i//N] > 0:
          h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
        else:  
          h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[2,j,i//N]*h[N-1][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[2,j,i//N]*h[N-1][j] for j in range(N)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009236111111111114}
#island_id: 3
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(4):
      site = (k+N-1)%2
      if site != 0 and i % N != 0: 
        if J[k,i%N,i//N] > 0:
          h_site += J[k,i%N,i//N]*h[site_nbr][i%N]
        else:  
          h_site -= J[k,i%N,i//N]*h[site_nbr][i%N]

      site = (k+N-1)%2
      if site != 1 and i // N != N-1: 
        if J[k,i%N,i//N] > 0:
          h_site += J[k,i%N,i//N]*h[site_nbr][i%N]
        else:  
          h_site -= J[k,i%N,i//N]*h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013223765432098752}
#island_id: 3
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if (k == 1 and i % N != 0) or (k == 2 and i // N != N-1): 
        if J[k,i%N,i//N] > 0:
          h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
        else:  
          h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0037344135802469137}
#island_id: 3
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin = 1
    else:
      spin = -1

    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] * h[site][i%N] > 0:
        spin *= -1
      else:
        spin *= 1

    priorities[i][0] = np.sum(J[:, i//N, i%N]) * spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.14887546296296306}
#island_id: 2
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)]) + h_site
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.015524228395061726}
#island_id: 2
#version_generated: 2
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = h_site
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1451766975308643}
#island_id: 2
#version_generated: 2
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = 2*h[i//N][i%N]
      for k in range(4):
        if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
          total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
      if h[i//N][i%N] > 0:
        priorities[i][0] = total_spin
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = -total_spin
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.05605262345679013}
#island_id: 2
#version_generated: 2
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    total_spin = h[i//N][i%N] * 2
    for k in range(4):
      if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1):
        total_spin += J[k,i//N,i%N]*h[(i//N + k % 2 - 1) % N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002415123456790127}
#island_id: 3
#version_generated: 2
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    J_left = J[0, site_nbr_left, i//N]
    J_right = J[0, site_nbr_right, i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J_left - J_right]) + h_site_left
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum([-J_left + J_right]) - h_site_left
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002415123456790127}
#island_id: 3
#version_generated: 2
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    J_left = J[0, site_nbr_left, i//N]
    J_right = J[0, site_nbr_right, i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J_left - J_right]) + h_site_left
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum([-J_left, J_right]) - h_site_left
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002415123456790127}
#island_id: 3
#version_generated: 2
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    J_left = J[0, site_nbr_left, i//N]
    J_right = J[0, site_nbr_right, i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J_left, -J_right]) + h_site_left
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum([-J_left, J_right]) - h_site_left
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002415123456790127}
#island_id: 3
#version_generated: 2
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    h_site_left = h[site_nbr_left][i%N]
    h_site_right = h[site_nbr_right][i%N]

    J_left = J[0, site_nbr_left, i//N]
    J_right = J[0, site_nbr_right, i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J_left, -J_right]) + h_site_left
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = np.sum([-J_left, J_right]) - h_site_left
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015958333333333339}
#island_id: 3
#version_generated: 2
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      priorities[i][0] += J[0, site_nbr_left, i//N]*np.exp(h_site)
      priorities[i][1] -= J[0, site_nbr_right, i//N]*np.exp(-h_site)
    else:
      h_site = -h[site_nbr_left][i%N]
      priorities[i][0] += J[0, site_nbr_right, i//N]*np.exp(h_site)
      priorities[i][1] -= J[0, site_nbr_left, i//N]*np.exp(-h_site)

  return(priorities)




#score: {'data2D.txt': 0.00041249999999999994}
#island_id: 3
#version_generated: 2
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      left_spin = np.sign(np.tanh(h_site))
      right_spin = np.sign(np.tanh(-h_site))

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      left_spin = np.sign(np.tanh(-h_site))
      right_spin = np.sign(np.tanh(h_site))

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0055625}
#island_id: 3
#version_generated: 2
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      left_h = h[site_nbr_left][i%N]
      right_h = h[site_nbr_right][i%N]

      priorities[i][0] = (np.exp(left_h) + np.exp(right_h)) * (J[0, site_nbr_left, i//N] + J[0, site_nbr_right, i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      left_h = -h[site_nbr_left][i%N]
      right_h = -h[site_nbr_right][i%N]

      priorities[i][0] = (np.exp(left_h) + np.exp(right_h)) * (-J[0, site_nbr_left, i//N] - J[0, site_nbr_right, i//N])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0023239197530864194}
#island_id: 3
#version_generated: 2
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N

    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(-h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr_left][i%N]
      left_spin = 1 if np.random.rand() < np.exp(-h_site) else -1
      right_spin = 1 if np.random.rand() < np.exp(h_site) else -1

      priorities[i][0] = J[0, site_nbr_left, i//N]*left_spin + J[0, site_nbr_right, i//N]*right_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16295138888888913}
#island_id: 1
#version_generated: 2
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0026050925925925933}
#island_id: 1
#version_generated: 2
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if i//N < N-1:
      site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
      total_spin += J[1,i//N,i%N]
      
    if i%N < N-1:
      site_nbr4 = (i // N*N + i%N + ((i//N+1)%2 - 1)) % N
      total_spin += J[2,i//N,i%N]
      
    if i//N > 0 and i%N > 0:
      site_nbr5 = (i // N*N + i%N + ((i//N-1)%2 - 1)) % N
      total_spin += J[3,i//N,i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction energy with all nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Apply the magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0020797839506172837}
#island_id: 1
#version_generated: 2
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.09922854938271615}
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Interaction with neighbors along rows and columns
    row_sum = sum(J[3,i//N:i//N+1,i%N])
    col_sum = sum(J[:,i%N,i//N])
    
    if J[3,i//N,i%N] > 0:
      total_spin += row_sum - col_sum
    else:
      total_spin -= row_sum + col_sum
    
    # Magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0034662037037037027}
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    total_spin = h[site_nbr1][i%N] + J[0,i%N,site_nbr2]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    if J[0,i%N,site_nbr2] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.1412066358024693}
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr_row, site_nbr_col = (i % N + ((i//N-1)%2 - 1)) % N, i // N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for k in range(N):
   site_nbr_row, site_nbr_col = (k % N + ((k//N-1)%2 - 1)) % N, k
   if h[k%N][k] > 0:
    for i in range(N**2):
     site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
     if J[3,i%N,k] > 0:
      priorities[i][0] += h[site_nbr][k]
      priorities[i][1] -= h[site_nbr][k]
     else:
      priorities[i][0] -= h[site_nbr][k]
      priorities[i][1] += h[site_nbr][k]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total magnetism and interaction at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0006183641975308633}
#island_id: 2
#version_generated: 2
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
     site_nbr = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       priorities[i][0] += h[site_nbr][j]
       priorities[i][1] -= h[site_nbr][j]
     else:
       priorities[i][0] -= h[site_nbr][j]
       priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.0007492283950617282}
#island_id: 0
#version_generated: 2
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - i%N) <= 1:
        nns.append(J[j,i//N,nn_site//N] * h[nn_site][i%N])
      else:
        nns.append(0)

    total_spin = sum(nns)
    if total_spin > 0:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site
    elif total_spin < 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site
    else:
      if np.random.rand() > 0.5:
        priorities[i][0] = h_site
        priorities[i][1] = -h_site
      else:
        priorities[i][0] = -h_site
        priorities[i][1] = h_site
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.0021671296296296295}
#island_id: 3
#version_generated: 2
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005480401234567902}
#island_id: 3
#version_generated: 2
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11188935185185199}
#island_id: 1
#version_generated: 2
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row = (i % N + ((k-1)%2 - 1)) % N
      site_nbr_col = (i // N) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][i%N]
        priorities[i][1] -= h[site_nbr_row][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row][i%N]
        priorities[i][1] += h[site_nbr_row][i%N]
    
    for j in range(N):
      site_nbr_row = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr_row][j]
        priorities[i][1] -= h[site_nbr_row][j]
      else:
        priorities[i][0] -= h[site_nbr_row][j]
        priorities[i][1] += h[site_nbr_row][j]
    
  return(priorities)




#score: {'data2D.txt': 0.013135956790123457}
#island_id: 1
#version_generated: 2
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if J[3,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0003273148148148134}
#island_id: 1
#version_generated: 2
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the magnetism at each site
  total_spin = np.sum(h, axis=1)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N], -total_spin[i//N]]
    else:
      priorities[i] = [-total_spin[i//N], total_spin[i//N]]
    
    # Calculate the interaction with neighbors
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate the interaction with bottom neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0052078703703703705}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*int(h[site_nbr][i%N] == h[(k+N-1)%N][i%N]) for k in range(3)])
    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.003816512345679012}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if total_spin > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0030371913580246913}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.sum((np.arange(2) == int(h_site+total_spin)))*-2 + int(h_site+total_spin)
  return(priorities)




#score: {'data2D.txt': -0.002714660493827161}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if sum([abs(J[k,i%N,i//N]) for k in range(3)]) > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0030371913580246913}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.sum((np.arange(2) == int(h_site+total_spin)))*-2 + int(h_site+total_spin)
  return(priorities)




#score: {'data2D.txt': 0.0009692901234567896}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0030371913580246913}
#island_id: 3
#version_generated: 2
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + total_spin
    priorities[i][1] = np.sum((np.arange(2) == int(h_site+total_spin)))*-2 + int(h_site+total_spin)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = np.sum([int(h[j][i%N] == h[i//N][i%N]) for j in range(N)]) + total_spin
    else:
      h_site = -np.sum([int(h[j][i%N] != h[i//N][i%N]) for j in range(N)]) - total_spin

    priorities[i][0] = h_site
    priorities[i][1] = np.sum((np.arange(2) == int(h_site)))*-2 + int(h_site)
  return(priorities)




#score: {'data2D.txt': -0.02376311728395062}
#island_id: 0
#version_generated: 2
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total energy and magnetism
    total_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    
    # Determine the priority based on the total energy and magnetism
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      # Determine the priority based on the magnetism
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = -1
        priorities[i][1] = 1
  
  return(priorities)




#score: {'data2D.txt': 0.06506311728395062}
#island_id: 0
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total energy
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    
    # Determine the priority based on the total energy and magnetism
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      # Determine the priority based on the magnetism
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = -1
        priorities[i][1] = 1

  return(priorities)




#score: {'data2D.txt': 0.06506311728395062}
#island_id: 0
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total energy
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    
    # Determine the priority based on the total energy and magnetism
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      # Determine the priority based on the magnetism
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = -1
        priorities[i][1] = 1
      
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.0003371913580246908}
#island_id: 2
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.24353101851851838}
#island_id: 3
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin += h[i//N][i%N]
    priority_minus_one = total_spin
    priority_one = -total_spin

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_magnetism = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N]) for k in range(3)])

    priority_minus_one = total_spin + total_magnetism
    priority_one = total_spin - total_magnetism

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.005452623456790123}
#island_id: 3
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = np.exp(-priority_minus_one)
    priorities[i][1] = np.exp(-priority_one)

  return(priorities)




#score: {'data2D.txt': 0.0032776234567901234}
#island_id: 3
#version_generated: 2
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    if J[0, i%N, i//N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = np.sum((np.arange(2) == int(h_site)))*-2 + int(h_site)
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = np.sum((np.arange(2) != int(-h_site)))*-2 + int(-h_site)
  return(priorities)




#score: {'data2D.txt': -0.0001393518518518516}
#island_id: 3
#version_generated: 2
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(3)])
    h_site = np.sum([(h[site_nbr][j]*2 - 1) * int(h[j][i%N] == h[i//N][i%N]) for j in range(N)]) + total_spin
    priorities[i][0] = h_site
    priorities[i][1] = np.sum((np.arange(2) == int(h_site)))*-2 + int(h_site)
  return(priorities)




#score: {'data2D.txt': 0.0015646604938271609}
#island_id: 1
#version_generated: 2
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    # Sum up the interactions from nearest neighbors
    nn_interactions = np.sum(J[:, i%N, i//N])

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + nn_interactions, -total_spin - nn_interactions]
    else:
      priorities[i] = [-total_spin - nn_interactions, total_spin + nn_interactions]

  return priorities




#score: {'data2D.txt': 0.012764660493827197}
#island_id: 1
#version_generated: 2
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priorities[i][0] = total_spin + h[i//N][i%N]
      priorities[i][1] = -total_spin - h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + h[i//N][i%N]
      priorities[i][1] = total_spin - h[i//N][i%N]
    
    site_nbr = (i % N + ((i // N + 1) % 2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0001609567901234567}
#island_id: 1
#version_generated: 2
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if sum(J[k,i%N,i//N] for k in [0,3]) > 0:
      total_spin += 2
    elif sum(J[k,i%N,i//N] for k in [0,3]) < 0:
      total_spin -= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0604087962962963}
#island_id: 1
#version_generated: 2
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[i//N][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.0006686728395061728}
#island_id: 2
#version_generated: 2
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.008921141975308642}
#island_id: 2
#version_generated: 2
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': 0.0006686728395061728}
#island_id: 2
#version_generated: 2
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011513888888888886}
#island_id: 2
#version_generated: 2
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -total_spin

  # Compute the sum of interactions with neighboring sites for each spin
  neighbor_interactions = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      neighbor_interactions[i][0] += sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
      neighbor_interactions[i][1] -= sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
    else:
      neighbor_interactions[i][0] -= sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
      neighbor_interactions[i][1] += sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])

  # Prioritize the spin based on the interactions with neighboring sites
  for i in range(N**2):
    priorities[i][0] -= neighbor_interactions[i][0]
    priorities[i][1] -= neighbor_interactions[i][1]

  return(priorities)




#score: {'data2D.txt': 0.008921141975308642}
#island_id: 2
#version_generated: 2
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data2D.txt': 0.043523919753086435}
#island_id: 2
#version_generated: 2
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + 2*(sum(J[:,i%N,site_nbr]) - sum(h[:,i%N]))
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -(total_spin + 2*(sum(J[:,i%N,site_nbr]) - sum(h[:,i%N])))
  return(priorities)




#score: {'data2D.txt': 0.09622114197530872}
#island_id: 1
#version_generated: 2
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       total_spin += h[site_nbr][i%N]
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
     else:
       total_spin -= h[site_nbr][i%N]
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16624027777777803}
#island_id: 1
#version_generated: 2
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin *= np.sign(h[i//N][i%N])
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if J[2,i//N,site_nbr] > 0:
      total_energy += sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])
    else:
      total_energy -= sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])

    priorities[i][0] = np.exp(total_energy)
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0038356481481481484}
#island_id: 1
#version_generated: 2
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012387345679012345}
#island_id: 1
#version_generated: 2
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_col = (i % N + ((3-(i//N+1))%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_col][k]
        priorities[i][1] -= h[site_nbr_col][k]
      else:
        priorities[i][0] -= h[site_nbr_col][k]
        priorities[i][1] += h[site_nbr_col][k]
    
    return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    J_sum = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    priority_minus_one = J_sum + h_site
    priority_one = J_sum - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0032776234567901234}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[site_nbr][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.002851080246913581}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    else:
      h_site = -sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.0019689814814814817}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    else:
      h_site = -sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = np.exp(-priority_minus_one)
    priorities[i][1] = 1 / np.exp(-priority_one)
  return(priorities)




#score: {'data2D.txt': 0.002851080246913581}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    else:
      h_site = -sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    total_spin += h[site_nbr][i%N]
    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.002851080246913581}
#island_id: 3
#version_generated: 2
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    else:
      h_site = -sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(2):
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if h[i//N][i%N] > 0:
        priorities[i][j] = -total_spin
      else:
        priorities[i][j] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.12741836419753103}
#island_id: 1
#version_generated: 2
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+1)%N)*N+(i%N)
    site_nbr3 = (i % N + (N-1)%2) % N
    site_nbr4 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.22567453703703683}
#island_id: 2
#version_generated: 2
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    total_spin = h[i//N][i%N] + h_site
    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0063797839506172845}
#island_id: 2
#version_generated: 2
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00191712962962963}
#island_id: 2
#version_generated: 2
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
     neighbor_nbr = (i+N*k)%N
     if J[k+1,i//N,neighbor_nbr] > 0:
       h_neighbor = h[neighbor_nbr][i%N]
     else:
       h_neighbor = -h[neighbor_nbr][i%N]

     priorities[i][0] += h_site + h_neighbor
     priorities[i][1] -= abs(h_site) * (abs(h_site) - 2*h_neighbor)
  return(priorities)




#score: {'data2D.txt': 0.0008430555555555559}
#island_id: 2
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      total_spin += h[site_nbr][j]
    if np.sum(h[:,site_nbr]) > 0:
      priorities[i][0] = total_spin + sum([J[k,site_nbr,k//N]*h[(k+N-1)%N][site_nbr] for k in range(3)]) - J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,site_nbr,k//N]*h[(k+N-1)%N][site_nbr] for k in range(3)]) + J[1,site_nbr,site_nbr]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013584876543209876}
#island_id: 1
#version_generated: 2
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin * len(np.where(J[3,:,i//N] > 0)[0])
      priorities[i][1] = total_spin + sum(1 for j in range(N) if J[3,i%N,j] > 0)
    else:
      priorities[i][0] = total_spin + sum(1 for j in range(N) if J[3,i%N,j] < 0)
      priorities[i][1] = -total_spin * len(np.where(J[3,:,i//N] < 0)[0])
    
    return(priorities)




#score: {'data2D.txt': -0.11459212962962963}
#island_id: 0
#version_generated: 2
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][1] = total_spin
    priorities[i][0] = np.argmax([total_spin - J[1,i//N,site_nbr], -total_spin + J[1,i//N,site_nbr]]) == 0
  return(priorities)




#score: {'data2D.txt': 0.03011095679012346}
#island_id: 0
#version_generated: 2
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.03011095679012346}
#island_id: 0
#version_generated: 2
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin = h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    nn_site_top = (site_nbr + ((0)%2 - 1)) % N
    nn_site_bot = (site_nbr + ((2)%2 - 1)) % N
    nn_site_left = (site_nbr + ((1)%2 - 1)) % N

    total_spin += h[nn_site_top][i%N] + h[nn_site_bot][i%N] + h[nn_site_left][i//N]
    if J[0,i//N,site_nbr] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,(i%N),int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][(i%N)] == h[i//N][i%N]) for k in range(4)])
    priority_minus_one = total_spin + 2*h[site_nbr][i%N]
    priority_one = total_spin - 2*h[site_nbr][i%N]
    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0006115740740740741}
#island_id: 3
#version_generated: 2
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if np.sum(J[:, i % N, int(i // N / N) + int((i % N) % N == 0)]) > 0:
      h_site = np.mean(h[site_nbr])
    else:
      h_site = -np.mean(h[site_nbr])

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0032776234567901234}
#island_id: 3
#version_generated: 2
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin += sum([J[k,i%N,(k+1)%2].astype(int)*int(h[k][i%N] == h[i//N][i%N]) for k in range(4)])

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0022020061728395056}
#island_id: 3
#version_generated: 2
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if J[0, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priority_minus_one = total_spin + h_site
    priority_one = total_spin - h_site

    if J[1, i%N, int(i//N/N)+int((i%N)%N==0)] > 0:
      priority_minus_one += sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(2,4)])
    else:
      priority_one += sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(2,4)])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.01691558641975309}
#island_id: 0
#version_generated: 2
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_energy = sum(J[j,i//N,(i-1)%N if (i-1)%N != N-1 else 0] * h[(i-1)%N][i%N] if J[j,i//N,(i-1)%N if (i-1)%N != N-1 else 0]>0 else -J[j,i//N,(i-1)%N if (i-1)%N != N-1 else 0] for j in range(4))
    total_energy += sum(J[j,i//N,(i+1)%N if (i+1)%N != 0 else N-1] * h[(i+1)%N][i%N] if J[j,i//N,(i+1)%N if (i+1)%N != 0 else N-1]>0 else -J[j,i//N,(i+1)%N if (i+1)%N != 0 else N-1] for j in range(4))
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16209521604938287}
#island_id: 0
#version_generated: 2
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    
    site_energy = 0
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      site_energy += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    
    priorities[i][0] = total_energy + site_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one

  return(priorities)




#score: {'data2D.txt': -0.025690895061728395}
#island_id: 3
#version_generated: 2
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    # add interactions with nearest neighbors
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        priority_minus_one += h[(j+N-1)%N][i%N]
        priority_one -= h[(j+N-1)%N][i%N]
      else:
        priority_minus_one -= h[(j+N-1)%N][i%N]
        priority_one += h[(j+N-1)%N][i%N]

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': 0.0022955246913580253}
#island_id: 3
#version_generated: 2
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
      priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    else:
      priority_minus_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
      priority_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one

  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one

  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one

  return(priorities)




#score: {'data2D.txt': -0.00926898148148148}
#island_id: 3
#version_generated: 2
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,int(i//N/N)+int((i%N)%N==0)].astype(int)*int(h[(k+N-1)%N][i%N] == h[i//N][i%N]) for k in range(4)])
    
    priority_minus_one = total_spin + sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])
    priority_one = total_spin - sum([h[k][i%N] for k in range(N) if (k+N-1)%N == site_nbr])

    priorities[i][0] = priority_minus_one
    priorities[i][1] = priority_one
    
  return(priorities)




#score: {'data2D.txt': 0.07030447530864203}
#island_id: 1
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(J[3,i//N,j] for j in range(N))
      priorities[i][1] = -total_spin - sum(J[3,i//N,j] for j in range(N))
    else:
      priorities[i][0] = -total_spin - sum(J[3,i//N,j] for j in range(N))
      priorities[i][1] = total_spin + sum(J[3,i//N,j] for j in range(N))
    
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Compute total spin based on site interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k, i%N, i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Compute magnetism based on site interactions
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3, i%N, j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Assign spin based on magnetism and site interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00796033950617284}
#island_id: 2
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += abs(total_spin)
      priorities[i][1] -= abs(total_spin)
    else:
      priorities[i][0] -= abs(total_spin)
      priorities[i][1] += abs(total_spin)

  return(priorities)




#score: {'data2D.txt': 0.0008121913580246914}
#island_id: 2
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin - J[3,site_nbr,site_nbr]
      priorities[i][1] = -total_spin + J[2,site_nbr,site_nbr]
    else:
      priorities[i][0] = -total_spin - J[2,site_nbr,site_nbr]
      priorities[i][1] = total_spin + J[3,site_nbr,site_nbr]

  return(priorities)




#score: {'data2D.txt': 0.0024112654320987653}
#island_id: 2
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)])
    total_spin_right = sum([J[3-k,i%N,site_nbr]*h[k][i%N] for k in range(4)])
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin_left - total_spin_right
      priorities[i][1] = -total_spin_left + total_spin_right
    else:
      priorities[i][0] = -total_spin_left + total_spin_right
      priorities[i][1] = total_spin_left - total_spin_right

  return(priorities)




#score: {'data2D.txt': -0.00988070987654321}
#island_id: 2
#version_generated: 2
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = sum([J[k,i%N,site_nbr]*h[(k+N-1)%N][i%N] for k in range(4)]) + J[1,site_nbr,site_nbr]
    total_spin_down = sum([J[k,i%N,site_nbr]*(-h[(k+N-1)%N][i%N]) for k in range(4)]) - J[1,site_nbr,site_nbr]
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin_up
      priorities[i][1] = -total_spin_down
    else:
      priorities[i][0] = -total_spin_up
      priorities[i][1] = -total_spin_down
  
  return(priorities)




#score: {'data2D.txt': -0.0061054012345679014}
#island_id: 1
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09788503086419759}
#island_id: 1
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
    if J[2,i%N,(i//N+N)%N] > 0:
      priorities[i][0] += h[(i//N+N)%N, (i%N+N)%N]
      priorities[i][1] -= h[(i//N+N)%N, (i%N+N)%N]
    else:
      priorities[i][0] -= h[(i//N+N)%N, (i%N+N)%N]
      priorities[i][1] += h[(i//N+N)%N, (i%N+N)%N]
    
    if J[3,i%N,(i//N+N)%N] > 0:
      priorities[i][0] += h[(i//N+N)%N, i%N]
      priorities[i][1] -= h[(i//N+N)%N, i%N]
    else:
      priorities[i][0] -= h[(i//N+N)%N, i%N]
      priorities[i][1] += h[(i//N+N)%N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Sum up the interactions from all neighbors
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add a bias term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and nearest neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16547052469135826}
#island_id: 1
#version_generated: 2
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + (i//N-1)%2) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1386408950617286}
#island_id: 1
#version_generated: 2
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(J[:,i//N,i//N]) - 2 * J[3,i//N,i//N]
      priorities[i][1] = -total_spin - sum(J[:,i//N,i//N]) + 2 * J[3,i//N,i//N]
    else:
      priorities[i][0] = -total_spin - sum(J[:,i//N,i//N]) + 2 * J[3,i//N,i//N]
      priorities[i][1] = total_spin + sum(J[:,i//N,i//N]) - 2 * J[3,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.0880699074074075}
#island_id: 1
#version_generated: 2
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = i // N
    
    total_spin = h[site_nbr1][i%N] + np.sum(J[:,i//N,i//N])
    
    for k in range(4):
      if J[k,i//N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.152765277777778}
#island_id: 1
#version_generated: 2
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate priority based on site interactions
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Add a term based on the magnetism
    if magnetism > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.13257484567901254}
#island_id: 1
#version_generated: 2
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(J[:,i%N,i//N])
      priorities[i][1] -= np.sum(J[:,i%N,i//N])
    else:
      priorities[i][0] -= np.sum(J[:,i%N,i//N])
      priorities[i][1] += np.sum(J[:,i%N,i//N])

  for i in range(N):
    site_nbr = (0 % N + ((i-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      priorities[i*N:(i+1)*N,0] += np.sum(J[:,i,i])
      priorities[i*N:(i+1)*N,1] -= np.sum(J[:,i,i])
    else:
      priorities[i*N:(i+1)*N,0] -= np.sum(J[:,i,i])
      priorities[i*N:(i+1)*N,1] += np.sum(J[:,i,i])

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i%N+N-1)%N + (i//N-1)%N)
    
    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.020135648148148146}
#island_id: 0
#version_generated: 2
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = 0
    for j, site in enumerate(site_nbrs):
      if h[site][i%N] > 0:
        total_spin += np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        total_spin -= np.sum(J[:,site,i%N])*h[site][i%N]
    total_spin += np.sum(J[:,i//N,i%N])*h[i//N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.019940586419753083}
#island_id: 0
#version_generated: 2
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N])*h[i//N][i%N]
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    for j, site in enumerate(site_nbrs):
      if h[site][i%N] > 0:
        total_spin += np.sum(J[:,site,i%N])*h[site][i%N]
      else:
        total_spin -= np.sum(J[:,site,i%N])*h[site][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5 + np.sum(np.dot(J[:,:,i//N], h.T)[:,i%N]) * 2
      priorities[i][1] -= 2.5 * total_spin - 2 * np.sum(np.dot(J[:,:,i//N], h.T)[:,i%N])
    else:
      priorities[i][0] -= total_spin * 3.5 + np.sum(np.dot(J[:,:,i//N], h.T)[:,i%N]) * 2
      priorities[i][1] += 2.5 * total_spin - 2 * np.sum(np.dot(J[:,:,i//N], h.T)[:,i%N])
  return(priorities)




#score: {'data2D.txt': 0.201288425925926}
#island_id: 0
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
      
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2 
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
      if np.sum(nns) == 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1

    # Add more terms to the priority function based on J
    for j in range(3):
     nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     if J[j,i//N,site_nbr] > 0:
      priorities[i][0] += J[j,i//N,site_nbr]
      priorities[i][1] -= J[j,i//N,site_nbr]
     else:
      priorities[i][0] -= J[j,i//N,site_nbr]
      priorities[i][1] += J[j,i//N,site_nbr]

  return(priorities)




#score: {'data2D.txt': 0.013298919753086415}
#island_id: 0
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
      
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2 - (np.sum(nns) == 0)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([n for n in nns]) + abs(sum([n for n in nns]))/2
      if np.sum(nns) == 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
    
    # Add the interaction with the two neighboring sites along the same row
    site_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_right = (site_nbr + ((3-1)%2 - 1)) % N
    priorities[i][0] += J[0, i//N, site_left]
    priorities[i][1] -= J[0, i//N, site_left]
    priorities[i][0] += J[0, i//N, site_nbr]
    priorities[i][1] -= J[0, i//N, site_right]
    
  return(priorities)




#score: {'data2D.txt': -0.019004783950617284}
#island_id: 0
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,site_nbr])
      
    total_energy = h_site + sum([n for n in nns]) - abs(sum([n for n in nns]))/2
    priorities[i][0] = total_energy
    priorities[i][1] = -total_energy

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % (N * N) < N // 2:
      row = i // N
      col = i % N
      if row > 0 and row < N - 1 and col > 0 and col < N - 1:
        priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        if row == 0 or row == N - 1 or col == 0 or col == N - 1:
          priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
          priorities[i][1] = -priorities[i][0]
        else:
          if row > 0 and col == 0 or N - 1:
            priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
            priorities[i][1] = -priorities[i][0]
          else:
            if row > 0 and col == N - 1:
              priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
              priorities[i][1] = -priorities[i][0]
    else:
      row = i // N
      col = i % N
      if row > 0 and row < N - 1 and col > 0 and col < N - 1:
        priorities[i][0] = h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] = -priorities[i][0]
      else:
        if row == 0 or row == N - 1 or col == 0 or col == N - 1:
          priorities[i][0] = h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
          priorities[i][1] = -priorities[i][0]
        else:
          if row > 0 and col == 0 or N - 1:
            priorities[i][0] = h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
            priorities[i][1] = -priorities[i][0]
          else:
            if row > 0 and col == N - 1:
              priorities[i][0] = h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
              priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0029714506172839506}
#island_id: 3
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row_nb = (i // N) % N
    col_nb = i % N

    if h[row_nb][col_nb] > 0:
      priorities[i][0] = h_site + J[1,i//N,i%N]*h[(row_nb+1)%N][col_nb] + J[2,i//N,i%N]*h[(row_nb+N-1)%N][col_nb]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - J[1,i//N,i%N]*h[(row_nb+1)%N][col_nb] - J[2,i//N,i%N]*h[(row_nb+N-1)%N][col_nb]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005480401234567902}
#island_id: 3
#version_generated: 2
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.011165895061728395}
#island_id: 0
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,(i+k-1)%N,i%N] * h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N] for k in range(4))
    total_energy = h[site_nbr][i%N] + nn_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += (total_energy + np.sum(h)) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (total_energy - np.sum(h)) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.01043287037037037}
#island_id: 0
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    total_energy = h[site_nbr][i%N] + nn_energy
    if np.sum(h) > 0:
      priorities[i][0] += (total_energy + np.sum(h)) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (total_energy - np.sum(h)) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.004742129629629631}
#island_id: 0
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N]) for k in range(4))
    total_energy = h[site_nbr][i%N] + nn_energy
    if total_energy > 0:
      priorities[i][0] += (total_energy + np.sum(h)) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (total_energy - np.sum(h)) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.05253780864197531}
#island_id: 0
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] if k % 2 == 0 else -h[(i+k-1)%N][i%N] for k in range(4))
    total_energy = h[site_nbr][i%N] + nn_energy
    if total_energy > 0:
      priorities[i][0] += (total_energy - np.mean(h.flatten())) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (abs(total_energy) - np.mean(h.flatten())) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]

    priorities[i] = [total_spin, -total_spin]

  return(priorities)




#score: {'data2D.txt': -0.001290277777777778}
#island_id: 2
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03877546296296296}
#island_id: 1
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N] * h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + ((i%N+1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum interactions with nearest neighbors
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - N, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - N]
    
  return(priorities)




#score: {'data2D.txt': 0.000947376543209878}
#island_id: 1
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    for k in range(3):
      if i >= N*k:
        site_nbr3 = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k,i%N,i//N]
        break
    
    for j in range(N):
      site_nbr4 = (i % N + ((j-1)%2 - 1)) % N
      if i >= N*j:
        total_spin += J[3,i%N,j]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.0034930555555555557}
#island_id: 0
#version_generated: 2
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_h_sum = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_h = h[nn_site][i%N]
      else:
        nn_h = -h[nn_site][i%N]

      nn_h_sum += J[j,i//N,nn_site]*nn_h

    priorities[i][1] = np.sign(h_site + nn_h_sum)
    priorities[i][0] = priorities[i][1]*(np.abs(h_site) + np.abs(nn_h_sum))

  return(priorities)




#score: {'data2D.txt': 0.040719290123456785}
#island_id: 0
#version_generated: 2
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_h = [J[j,i//N,site_nbr]*h[site_nbr][i%N] for j in range(3)]
    priorities[i][0] = h_site + sum([max(n, 0) for n in nn_h])
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.014151697530864198}
#island_id: 0
#version_generated: 2
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = J_up * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.01234891975308642}
#island_id: 0
#version_generated: 2
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if j == 3:
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      else:
        nns.append(h[nn_site][i%N])
    
    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(4),nns)]) + J[3,i//N,i//N]
      J_down = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(4),nns)]) - J[3,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(4),nns)]) + J[3,i//N,i//N]
      J_down = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(4),nns)]) - J[3,i//N,i//N]
    
    if h[i//N][i%N] > 0:
      spin_energy = J_up
    else:
      spin_energy = J_down
    
    priorities[i][0] = spin_energy * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.003131018518518518}
#island_id: 0
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h[i//N][i%N] > 0:
      spin_energy = J_up
    else:
      spin_energy = J_down

    priorities[i][0] = spin_energy * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.006060956790123457}
#island_id: 1
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    site_nbr3 = (i % N + ((i-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11506805555555569}
#island_id: 1
#version_generated: 2
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(h[j % N, i // N] for j in range(N))
      priorities[i][1] = -total_spin - sum(h[j % N, i // N] for j in range(N))
    else:
      priorities[i][0] = -total_spin - sum(h[j % N, i // N] for j in range(N))
      priorities[i][1] = total_spin + sum(h[j % N, i // N] for j in range(N))
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = h_site * (J_up + J_down)
    priorities[i][1] = -(priorities[i][0])
  return(priorities)




#score: {'data2D.txt': 0.0015705246913580244}
#island_id: 0
#version_generated: 2
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = h_site * (J_up - J_down)
    priorities[i][1] = -(priorities[i][0])
    
    # Calculate priority based on the sign of total spin
    if np.sum(priorities[:i]) < 0:
      priorities[i][0] += 1
      priorities[i][1] -= 2
    elif np.sum(priorities[:i]) > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 2

  return(priorities)




#score: {'data2D.txt': -0.0006047839506172846}
#island_id: 0
#version_generated: 2
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),[h[(site_nbr+1)%N][j] if (j-1)%2 == 0 else h[site_nbr][j-1] for j in range(i%N+1)])])
    J_down = -J_up

    priorities[i][0] = h_site * (J_up - J_down)
    priorities[i][1] = -(priorities[i][0])

  return(priorities)




#score: {'data2D.txt': -0.0014828703703703705}
#island_id: 2
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+1)%N+N*(i%N)) if i<N*N-N else (i//N)%N
    h_site = sum([J[k,i//N,i%N]*h[site_nbr1][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]]) + sum([J[k,site_nbr2//N,site_nbr2%N]*h[site_nbr2//N][site_nbr2%N] for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00023410493827160446}
#island_id: 2
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0012989197530864193}
#island_id: 2
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(4):
      h_site = J[j,i//N,i%N]*h[site_nbr][j]
      if h[i//N][i%N] > 0:
        priorities[i][0] += h_site
        priorities[i][1] -= h_site
      else:
        priorities[i][0] -= h_site
        priorities[i][1] += h_site

  return(priorities)




#score: {'data2D.txt': -0.29813503086419696}
#island_id: 0
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= 2 * np.sign(h[site_nbr][i%N])
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += 2 * np.sign(h[site_nbr][i%N])
  return(priorities)




#score: {'data2D.txt': 0.0007115740740740732}
#island_id: 0
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.18919830246913602}
#island_id: 0
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      delta = h[site_nbr][i%N] - h[i//N][i%N]
      priorities[i][0] -= (delta + nn_energy) / 4
      priorities[i][1] += 1 if delta < 0 else -1
  return(priorities)




#score: {'data2D.txt': 0.0007115740740740732}
#island_id: 0
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if np.sign(h[site_nbr][i%N]) == np.sign(h[i//N][i%N]):
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.0019152777777777777}
#island_id: 3
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i < N*N/2:
      priorities[i][0] += h_site
      priorities[i][1] -= h_site
    elif i >= N**2-N*N//2:
      priorities[i][0] -= h_site
      priorities[i][1] += h_site
    else:
      row = i // N
      col = i % N
      if row > 0 and row < N - 1 and col > 0 and col < N - 1:
        priorities[i][0] += h_site + np.sum(J[:,i//N,i%N]*h[(row-1)%N+((col-1)%2),:])
        priorities[i][1] -= priorities[i][0]
      else:
        if row == 0 or row == N - 1 or col == 0 or col == N - 1:
          priorities[i][0] += h_site + np.sum(J[:,i//N,i%N]*h[(row-1)%N+((col-1)%2),:])
          priorities[i][1] -= priorities[i][0]
        else:
          if row > 0 and col == 0 or N - 1:
            priorities[i][0] += h_site + np.sum(J[:,i//N,i%N]*h[(row-1)%N+((col-1)%2),:])
            priorities[i][1] -= priorities[i][0]
          else:
            if row > 0 and col == N - 1:
              priorities[i][0] += h_site + np.sum(J[:,i//N,i%N]*h[(row-1)%N+((col-1)%2),:])
              priorities[i][1] -= priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0018726851851851851}
#island_id: 3
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row = i // N
    col = i % N

    # Calculate the sum of interactions with nearest neighbors
    nn_sum = J[1, i%N, i//N] * (h[(row-1)%N][col] + h[(row+1)%N][col]) + J[2, i%N, i//N] * (h[row][(col-1)%N] + h[row][(col+1)%N])

    if row > 0 and col > 0 and row < N - 1 and col < N - 1:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if (row == 0 or row == N - 1) or (col == 0 or col == N - 1):
        priorities[i][0] = h_site + nn_sum
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0008146604938271612}
#island_id: 3
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h_site
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site][i%N]
      else:
        total_spin -= h[site][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.08583194444444445}
#island_id: 0
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 5 * total_spin
        priorities[i*N+j][1] -= 3.5 * total_spin
      else:
        priorities[i*N+j][0] -= 4.5 * total_spin
        priorities[i*N+j][1] += 2.5 * total_spin
  return(priorities)




#score: {'data2D.txt': 0.03925787037037037}
#island_id: 0
#version_generated: 2
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])*h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 4.5 * total_spin
        priorities[i*N+j][1] -= 3.5 * total_spin
      else:
        priorities[i*N+j][0] -= 4.5 * total_spin
        priorities[i*N+j][1] += 2.5 * total_spin
  for i in range(N):
    for j in range(N//2):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+2*j][0] += np.sum(J[:,site_nbr,2*j])
        priorities[i*N+2*j][1] -= np.sum(J[:,site_nbr,2*j])
      else:
        priorities[i*N+2*j][0] -= np.sum(J[:,site_nbr,2*j])
        priorities[i*N+2*j][1] += np.sum(J[:,site_nbr,2*j])
  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00044830246913580245}
#island_id: 3
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0032995370370370375}
#island_id: 3
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

    if i % N < N // 2:
      if i % N == 0 or J[1,i%N,i//N] > 0:
        priorities[i][0] += np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] -= 2*np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      else:
        priorities[i][0] -= np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] += 2*np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % N >= N // 2:
      if i % N == N - 1 or J[1,i%N,i//N] > 0:
        priorities[i][0] += np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] -= 2*np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      else:
        priorities[i][0] -= np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
        priorities[i][1] += 2*np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015498456790123461}
#island_id: 2
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i//N,i%N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N_half), min(i//N, N_half)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i//N,i%N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N_half), min(i//N, N_half)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.003710339506172839}
#island_id: 2
#version_generated: 2
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if h[site_nbr][max(0,min(i//N,N-1))] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0002362654320987655}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[j,i//N,i%N]*h[site_nbr][j] for j in range(4)])
    if np.sum(h[i//N]) > 0:
      priorities[i][0] += h_site
      priorities[i][1] -= h_site
    else:
      priorities[i][0] -= h_site
      priorities[i][1] += h_site
  return(priorities)




#score: {'data2D.txt': 0.0008729938271604936}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for j in range(4):
      priorities[i][0] += J[j,i//N,i%N]*total_spin*h[site_nbr][j]
      if h[site_nbr][j] > 0:
        priorities[i][1] -= J[j,i//N,i%N]*total_spin
      else:
        priorities[i][1] += J[j,i//N,i%N]*total_spin

  return(priorities)




#score: {'data2D.txt': -0.25675879629629605}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for j in range(4):
      h_site = J[j,i//N,i%N]*h[site_nbr][j]
      total_energy += h_site
      if h[i//N][i%N] > 0:
        priorities[i][0] += h_site
        priorities[i][1] -= h_site
      else:
        priorities[i][0] -= h_site
        priorities[i][1] += h_site
    priorities[i][0] /= total_energy
  return(priorities)




#score: {'data2D.txt': -0.0010288580246913578}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_value = h[site_nbr][i%N]
    interactions = [J[k,i%N,i//N]*h[j][max(i//N,N-1)] for k in range(4) for j in [min(i//N,0), max(i//N,N-1)] if abs(j-i//N) <= 1 or (k == 2 and i % N > 0)]
    priorities[i][0] = sum(interactions)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.24326435185185175}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -abs(h_site)
      priorities[i][1] = abs(h_site)
    else:
      priorities[i][0] = abs(h_site)
      priorities[i][1] = -abs(h_site)

  return(priorities)




#score: {'data2D.txt': 0.0010881172839506173}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j = max(i//N,N-1) if k == 0 else min(i//N,0)
      total_spin += J[k,i%N,i//N]*h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012989197530864193}
#island_id: 2
#version_generated: 2
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      total_spin += J[j,i//N,i%N]*h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  return(priorities)




#score: {'data2D.txt': 0.33422669753086326}
#island_id: 2
#version_generated: 2
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -abs(h_site)
      priorities[i][1] = abs(h_site)
    else:
      priorities[i][0] = abs(h_site)
      priorities[i][1] = -abs(h_site)

  return(priorities)




#score: {'data2D.txt': 0.031508179012345684}
#island_id: 0
#version_generated: 2
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = ((i // N) % N + ((j - 1) % 2 - 1)) % N
      if J[j, i // N, i % N] * h[site_nbr][i % N] > 0:
        total_spin += 2 * J[j, i // N, i % N]
      else:
        total_spin -= 2 * J[j, i // N, i % N]
    if h[i // N][i % N] > 0:
      priorities[i][0] += 3.5 * total_spin
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= 3.5 * total_spin
      priorities[i][1] += 2.5 * total_spin
  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for j in range(4):
      site_nbr = ((i // N) % N + ((j - 1) % 2 - 1)) % N
      if J[j, i // N, i % N] * h[site_nbr][i % N] > 0:
        total_spin += J[j, i // N, i % N]
      else:
        total_spin -= J[j, i // N, i % N]
    site_nbrs.append(total_spin)
    for j in range(4):
      site_nbr = ((i // N) % N + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][i % N] > 0:
        priorities[i][0] += abs(J[j, i // N, i % N])
        priorities[i][1] -= J[j, i // N, i % N]
      else:
        priorities[i][0] -= abs(J[j, i // N, i % N])
        priorities[i][1] += J[j, i // N, i % N]
    for k in range(2):
      if priorities[i][k] > 0.5:
        site_nbrs.append(-1)
      elif priorities[i][k] < -0.5:
        site_nbrs.append(1)
      else:
        site_nbrs.append(np.random.choice([-1, 1]))
    for k in range(len(site_nbrs)):
      if site_nbrs[k] > 0:
        priorities[i][0] += 3 * site_nbrs[k]
        priorities[i][1] -= 2 * site_nbrs[k]
      else:
        priorities[i][0] -= 3 * site_nbrs[k]
        priorities[i][1] += 2 * site_nbrs[k]
  return priorities




#score: {'data2D.txt': -0.0024915123456790123}
#island_id: 0
#version_generated: 2
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = ((i // N) % N + ((j - 1) % 2 - 1)) % N
      if J[j, i // N, i % N] * h[site_nbr][i % N] > 0:
        total_spin += J[j, i // N, i % N]
      else:
        total_spin -= J[j, i // N, i % N]
    total_spin *= 1 if np.sum(h[i // N]) > 0 else -1
    priorities[i][0] += 3.5 * total_spin
    priorities[i][1] = -priorities[i][0] + 2.5 * total_spin
  return priorities




#score: {'data2D.txt': -0.0016541666666666666}
#island_id: 0
#version_generated: 2
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    nns = []
    for j in [(0,-1),(1,0),(-1,0),(0,1)]:
      nn_site = (site_nbr + j[0]) % N
      if abs(nn_site - i % N) == 1 and abs(nn_site // N - i // N) == 0: # horizontal neighbor
        nns.append(J[1,i//N,nn_site])
      elif abs(nn_site - i % N) == 0 and abs(nn_site // N - i // N) == 1: # vertical neighbor
        nns.append(J[2,i//N,nn_site])
      else: # diagonal neighbors
        if j[0] == 0:
          nns.append(J[3,i//N,nn_site])
        else:
          nns.append(J[0,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    nns = []
    for j in [(0,-1),(1,0),(-1,0),(0,1)]:
      nn_site = (site_nbr + j[0]) % N
      if abs(nn_site - i % N) == 1 and abs(nn_site // N - i // N) == 0: # horizontal neighbor
        nns.append(J[1,i//N,nn_site])
      elif abs(nn_site - i % N) == 0 and abs(nn_site // N - i // N) == 1: # vertical neighbor
        nns.append(J[2,i//N,nn_site])
      else: # diagonal neighbors
        if j[0] == 0:
          nns.append(J[3,i//N,nn_site])
        else:
          nns.append(J[0,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    if priorities[i][0] > 1e-6: 
      priorities[i][1] -= 2*priorities[i][0]
    else:
      priorities[i][1] += 2*priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016541666666666666}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    nns = []
    for j in [(0,-1),(1,0),(-1,0),(0,1)]:
      nn_site = (site_nbr + j[0]) % N
      if abs(nn_site - i % N) == 1 and abs(nn_site // N - i // N) == 0: # horizontal neighbor
        nns.append(J[1,i//N,nn_site])
      elif abs(nn_site - i % N) == 0 and abs(nn_site // N - i // N) == 1: # vertical neighbor
        nns.append(J[2,i//N,nn_site])
      else: # diagonal neighbors
        if j[0] == 0:
          nns.append(J[3,i//N,nn_site])
        else:
          nns.append(J[0,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016541666666666666}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    nns = []
    for j in [(0,-1),(1,0),(-1,0),(0,1)]:
      nn_site = (site_nbr + j[0]) % N
      if abs(nn_site - i % N) == 1 and abs(nn_site // N - i // N) == 0: 
        nns.append(J[1,i//N,nn_site])
      elif abs(nn_site - i % N) == 0 and abs(nn_site // N - i // N) == 1:
        nns.append(J[2,i//N,nn_site])
      else:
        if j[0] == 0:
          nns.append(J[3,i//N,nn_site])
        else:
          nns.append(J[0,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = (h_site + total_energy)
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04188163580246916}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nn_sum = sum([J[k,i//N][i%N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.000591512345679012}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]
  
  # Sort the priority list by site energy in descending order
  sorted_indices = np.argsort(-priorities[:, 0])
  priorities = priorities[sorted_indices]
  
  return(priorities)




#score: {'data2D.txt': 0.04247083333333336}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00861466049382716}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])
    
    priorities[i][0] = np.exp(h_site + nn_sum)
    priorities[i][1] = 1 / priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.016232253086419752}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2) + np.sum(J[:,i//N,i%N])
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2) - np.sum(J[:,i//N,i%N])
      priorities[i][1] += 2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.21751404320987672}
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (np.sum(J[:,i//N,i%N])**2) * (1 + np.sign(np.sum(J[:,i//N,i%N])))
      priorities[i][1] -= 2*(np.sum(J[:,i//N,i%N]))**(3/2)
    else:
      priorities[i][0] -= (np.sum(J[:,i//N,i%N])**2) * (1 - np.sign(np.sum(J[:,i//N,i%N])))
      priorities[i][1] += 2*(np.sum(J[:,i//N,i%N]))**(3/2)
  return(priorities)




#score: {'data2D.txt': -0.016232253086419752}
#island_id: 0
#version_generated: 2
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2) + np.sum(J[:,i//N,i%N])
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2) - np.sum(J[:,i//N,i%N])
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': 0.0032714506172839514}
#island_id: 0
#version_generated: 2
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += (np.sum(J[:,i//N,i%N]) - 2) + total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= (np.sum(J[:,i//N,i%N]) + 2) - total_spin
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.0012023148148148151}
#island_id: 3
#version_generated: 2
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00044830246913580245}
#island_id: 3
#version_generated: 2
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00044830246913580245}
#island_id: 3
#version_generated: 2
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if i % (N2) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.28357793209876503}
#island_id: 1
#version_generated: 2
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][i%N] * J[3,i%N,j] > 0:
        total_spin += h[i//N][i%N]
      else:
        total_spin -= h[i//N][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 1
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site][i%N]
        priorities[i][1] -= h[site][i%N]
      else:
        priorities[i][0] -= h[site][i%N]
        priorities[i][1] += h[site][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.001649537037037037}
#island_id: 3
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k,i%N,i//N] * h[site_nbr][k] for k in range(4))
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0016745370370370373}
#island_id: 3
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    neighbor_sum = sum(J[k,i%N,i//N] * h[(i+k-1)%N][i%N] for k in range(4))
    priorities[i][0] = neighbor_sum + h_site
    priorities[i][1] = -priorities[i][0]
  return priorities




#score: {'data2D.txt': 0.0008146604938271612}
#island_id: 3
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = h_site
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site][i%N]
      else:
        total_spin -= h[site][i%N]

    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 3
#version_generated: 2
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07380231481481486}
#island_id: 1
#version_generated: 2
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_interaction = 0
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        site_interaction += h[site_nbr][j]
      else:
        site_interaction -= h[site_nbr][j]
    
    magnetism = 0
    if h[i//N][i%N] > 0:
      magnetism = -1
    else:
      magnetism = 1
    
    priorities[i][0] = total_spin + site_interaction + magnetism
    priorities[i][1] = -total_spin - site_interaction - magnetism
  
  return(priorities)




#score: {'data2D.txt': 0.1598229938271607}
#island_id: 1
#version_generated: 2
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.32749305555555464}
#island_id: 2
#version_generated: 2
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site
    else:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h - 2*h[site_nbr]))
    else:
      priorities[i][0] = np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = -np.sum(np.abs(h - 2*h[site_nbr]))

  return(priorities)




#score: {'data2D.txt': -0.11526250000000013}
#island_id: 1
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16621311728395086}
#island_id: 1
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for k in [0,1]:
      total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = 2*h[site_nbr][i%N]
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.09630354938271606}
#island_id: 0
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      if k == 0:
        total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
      elif k == 1 and i % N != site_nbr:
        total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.007288734567901235}
#island_id: 0
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      if k == 0:
        site_nbr1 = (i+k) % N
        site_nbr2 = ((i//N)+k-1)%N
        total_energy += J[0,i//N,i%N] * h[site_nbr1][site_nbr2]
      else:
        site_nbr1 = (i-k) % N
        site_nbr2 = ((i//N)-k+1)%N
        total_energy -= J[1,i//N,i%N] * h[site_nbr1][site_nbr2]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.08726959876543211}
#island_id: 0
#version_generated: 2
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0.5 * (h[site_nbr][i%N] + h[i%N][site_nbr])
    for k in [0,1]:
      if i+k < N**2:
        total_energy += J[k,i//N,i%N] * (h[(i+k)%N][i%N] - h[site_nbr][i%N])
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.02125879629629633}
#island_id: 2
#version_generated: 2
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -abs(h_site)
      priorities[i][1] = abs(h_site)
    else:
      priorities[i][0] = abs(h_site)
      priorities[i][1] = -abs(h_site)

  # Add the effect of magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] += abs(h[i//N][i%N])
      priorities[i][1] -= abs(h[i//N][i%N])
    else:
      priorities[i][0] -= abs(h[i//N][i%N])
      priorities[i][1] += abs(h[i//N][i%N])

  return(priorities)




#score: {'data2D.txt': 0.24326435185185175}
#island_id: 2
#version_generated: 2
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -abs(total_spin)
      priorities[i][1] = abs(total_spin)
    else:
      priorities[i][0] = abs(total_spin)
      priorities[i][1] = -abs(total_spin)

  return(priorities)




#score: {'data2D.txt': -0.09935478395061736}
#island_id: 0
#version_generated: 2
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy = 0
    for j in [J[0,i%N,i//N], J[1,i//N,site_nbr], J[2,i//N,site_nbr]]:
      if j > 0:
        nn_energy += h[i//N][i%N]
      else:
        nn_energy -= h[i//N][i%N]
    
    priorities[i][0] = -np.tanh(h[site_nbr][i%N] + nn_energy)
    priorities[i][1] = 1 - np.tanh(-h[site_nbr][i%N] - nn_energy)

  return(priorities)




#score: {'data2D.txt': -0.07481867283950623}
#island_id: 0
#version_generated: 2
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy = 0
    for j in [J[0,i%N,i//N], J[1,i//N,site_nbr], J[2,i//N,site_nbr]]:
      if j > 0:
        nn_energy += h[i//N][i%N]
      else:
        nn_energy -= h[i//N][i%N]
    
    priorities[i][0] = -np.tanh(h[site_nbr][i%N] + nn_energy)
    priorities[i][1] = np.exp(2*h[site_nbr][i%N]) * np.exp(-nn_energy) / (np.exp(2*h[site_nbr][i%N]) * np.exp(-nn_energy) + 1)

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy = 0
    for j in [J[0,i%N,i//N], J[1,i//N,site_nbr], J[2,i//N,site_nbr]]:
      if j > 0:
        nn_energy += h[i//N][i%N]
      else:
        nn_energy -= h[i//N][i%N]
    
    if np.abs(h[site_nbr][i%N] + nn_energy) < 1e-6:
      priorities[i][0] = 0.5
      priorities[i][1] = 0.5
    elif h[site_nbr][i%N] + nn_energy > 0:
      priorities[i][0] = np.exp(h[site_nbr][i%N] + nn_energy)
      priorities[i][1] = 1 / priorities[i][0]
    else:
      priorities[i][0] = 1 / np.exp(-h[site_nbr][i%N] - nn_energy)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k, i%N, i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N, N-1), min(i//N, 0)]])
    h_site = total_h_site - sum([abs(J[k, i%N, i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(-h + 2*h[site_nbr]))
    else:
      priorities[i][0] = np.sum(np.abs(-h + 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h - 2*h[site_nbr]))
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = -np.sum(np.abs(h - 2*h[site_nbr])) + np.sum(np.abs(h_site))
      priorities[i][1] = np.sum(np.abs(h - 2*h[site_nbr])) - np.sum(np.abs(h_site))
    else:
      priorities[i][0] = np.sum(np.abs(h - 2*h[site_nbr])) - np.sum(np.abs(h_site))
      priorities[i][1] = -np.sum(np.abs(h - 2*h[site_nbr])) + np.sum(np.abs(h_site))

  return(priorities)




#score: {'data2D.txt': 0.09998842592592604}
#island_id: 0
#version_generated: 2
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.08115848765432107}
#island_id: 0
#version_generated: 2
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr1][i%N]
    total_energy += sum(J[j,site_nbr2,(i%(N*N)-1+N)%N] if J[j,site_nbr2,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr2,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr2][i%N]
    total_energy += sum(J[j,i//N,(i%(N*N)-1+N)%N] if J[j,i//N,(i%(N*N)-1+N)%N]>0 else -J[j,i//N,(i%(N*N)-1+N)%N] for j in range(4)) * h[i//N][i%N]
    total_energy += sum(J[j,site_nbr1,(i%(N*N)-1+N)%N] if J[j,site_nbr1,(i%(N*N)-1+N)%N]>0 else -J[j,site_nbr1,(i%(N*N)-1+N)%N] for j in range(4)) * h[site_nbr1][i%N]
    priorities[i][0] = total_energy
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_energy = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    energy = sum(J[j,i//N,(site_nbr1+(j-1)%2-N)%N] if J[j,i//N,(site_nbr1+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr1+(j-1)%2-N)%N] for j in range(4))
    total_energy[i][0] = energy * h[site_nbr1][i%N]
    if h[i//N][i%N] > 0:
      total_energy[i][1] = -total_energy[i][0]
    else:
      total_energy[i][1] = total_energy[i][0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_energy[i][0] += 1
      total_energy[i][1] -= 1
    else:
      total_energy[i][0] -= 1
  return(total_energy)




#score: {'data2D.txt': 0.2323606481481481}
#island_id: 2
#version_generated: 2
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h + 2*h[site_nbr]))
    else:
      priorities[i][0] = np.sum(np.abs(h + 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h - 2*h[site_nbr]))

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_h_site = sum([J[k,i%N,i//N]*h[site_nbr][j] for k in range(4) for j in [max(i//N,N-1), min(i//N,0)]])
    h_site = total_h_site - sum([abs(J[k,i%N,i//N]) for k in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum(np.abs(h-2*h[site_nbr]))
      priorities[i][1] = -np.sum(np.abs(h-2*h[site_nbr]))
    else:
      priorities[i][0] = -np.sum(np.abs(h-2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h-2*h[site_nbr]))

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total magnetism at each site
  h_total = np.zeros_like(h)
  for i in range(N):
    for j in range(N):
      h_total[i][j] = sum([J[k,i,j]*h[(i+k-1)%N][j] for k in range(4)])
  
  # Calculate priority values based on site magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h_total[i//N][i%N] - sum([abs(J[k,i//N,i%N]) for k in range(4)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = np.sum(np.abs(h - 2*h[site_nbr]))
    else:
      priorities[i][0] = np.sum(np.abs(h - 2*h[site_nbr]))
      priorities[i][1] = -np.sum(np.abs(h - 2*h[site_nbr]))
  
  return(priorities)




#score: {'data2D.txt': 0.04254645061728395}
#island_id: 0
#version_generated: 2
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    priorities[i][0] = total_spin
    if np.random.rand() < 0.5:
      priorities[i][1] = -total_spin
    else:
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin_summed = np.sum(h, axis=0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] + total_spin_summed[i%N]
    
    if J[0, i//N, i%N] > 0:
      total_spin -= 1
    elif J[0, i//N, i%N] < 0:
      total_spin += 1
    
    for j in range(3):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += J[j, i//N, i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if total_spin > 0 else total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0006717592592592595}
#island_id: 0
#version_generated: 2
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    if total_spin < 0:
      priorities[i][1] = -total_spin
    else:
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.04195910493827161}
#island_id: 0
#version_generated: 2
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if np.random.rand() < 0.5 else total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.009848302469135803}
#island_id: 0
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((3-1)%2 - 1)) % N
    total_spin=h[site_nbr][i%N]
    for j in range(4):
      if h[(i+((j-1)%2 - 1))%N][i%N] > 0:
        total_spin += J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    magnetism = h[i//N][i%N]
    interaction = J[:, i//N, i%N].sum()
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': 0.015665895061728396}
#island_id: 0
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i//N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum([J[k][i//N,i%N] if h[site_nbr][i%N] > 0 else -J[k][i//N,i%N] for k, site_nbr in zip(range(4), site_nbrs)])
    magnetism = h[i//N][i%N]
    interaction = sum([1 if h[site_nbr][i%N] > 0 else -1 for site_nbr in site_nbrs])
    if magnetism > 0:
      priorities[i][0] = 3.5*(total_spin + interaction)
      priorities[i][1] = -2.5*(total_spin + interaction)
    else:
      priorities[i][0] = -3.5*(total_spin + interaction)
      priorities[i][1] = 2.5*(total_spin + interaction)
  return(priorities)




#score: {'data2D.txt': -0.0048973765432098765}
#island_id: 0
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = J[0,i%N,i//N] * h[i//N][i%N]
    energy_h = h[site_nbr][i%N]
    if energy_nn > 0:
      priorities[i][0] = energy_h + energy_nn
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = energy_h
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0036081790123456787}
#island_id: 0
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = J[0,i%N,i//N] * h[i//N][i%N]
    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -(priorities[i][0]) - (h[site_nbr][i%N])**2
  return(priorities)




#score: {'data2D.txt': -0.00048101851851851946}
#island_id: 0
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_nn = J[0,i%N,i//N] * h[i//N][i%N]
    priorities[i][0] = h[site_nbr][i%N] + energy_nn
    priorities[i][1] = -priorities[i][0]
    for j in range(i % (N*N), i // N * N + N):
      site_nbr2 = (j % N + ((j//N-1)%2 - 1)) % N
      if J[0,j%N,j//N] == J[0,i%N,i//N]:
        priorities[i][0] -= h[site_nbr2][j%N]
        priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005044907407407408}
#island_id: 3
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_h = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[site_nbr][i%N]
      priorities[i][0] = total_h
      priorities[i][1] = -priorities[i][0]
    else:
      total_h = sum([J[k,i//N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - h[site_nbr][i%N]
      priorities[i][0] = -total_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005007870370370372}
#island_id: 3
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N < N // 2:
        priorities[i][0] += np.sum([J[k, (i%N)*2+1, i//N]*h[(k+N-1)%N][(i%N)*2+1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      if i % N < N // 2:
        priorities[i][0] -= np.sum([J[k, (i%N)*2+1, i//N]*h[(k+N-1)%N][(i%N)*2+1] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005480401234567902}
#island_id: 3
#version_generated: 2
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      h_site = h[site_nbr][i%N]
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h_site + neighbors_sum
      priorities[i][1] = -priorities[i][0]
    else:
      h_site = -h[site_nbr][i%N]
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h_site - neighbors_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0036374999999999997}
#island_id: 3
#version_generated: 2
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    row_nb = (i // N) % N
    col_nb = i % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = (J[1,row_nb,col_nb]*h[(row_nb+1)%N][col_nb]+J[2,((row_nb+N-1)%N),col_nb]*h[(row_nb+N-1)%N][col_nb])*h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.000576388888888889}
#island_id: 3
#version_generated: 2
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    row_nb = i // N
    col_nb = i % N

    h_site = h[site_nbr][col_nb]
    if J[0,i//N,i%N] > 0:
      h_site *= 1
    else:
      h_site *= -1

    priorities[i][0] = h_site + J[2,row_nb,col_nb]*h[(row_nb+1)%N][col_nb] + J[3,row_nb,col_nb]*h[(row_nb+N-1)%N][col_nb]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00044830246913580245}
#island_id: 3
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] += h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] += h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0017640432098765437}
#island_id: 3
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      sum_neighbors = -np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.07061990740740741}
#island_id: 0
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      spin_polarity = np.sign(h[site_nbr][i%N])
      neighbor_sum = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
      if neighbor_sum > 0 and spin_polarity > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
      elif neighbor_sum < 0 and spin_polarity > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      elif neighbor_sum > 0 and spin_polarity < 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      elif neighbor_sum < 0 and spin_polarity < 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.07061990740740741}
#island_id: 0
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      if h[site_nbr][i%N] > 0:
        if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = 1
          priorities[i][1] = -1
      elif h[site_nbr][i%N] < 0:
        if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
        else:
          priorities[i][0] = -1
          priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.09301496913580247}
#island_id: 0
#version_generated: 2
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      site_energy = h[site_nbr][i%N]
      if abs(site_energy) > sum(abs(J[k,i//N,i%N]) for k in range(3)):
        priorities[i][0] = 1 if site_energy > 0 else -1
        priorities[i][1] = -1 if site_energy > 0 else 1
      else:
        if site_energy > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        elif site_energy < 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
  return(priorities)




#score: {'data2D.txt': -0.003007870370370371}
#island_id: 3
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_neighbors = np.sum([J[k,i%N,i//N]*h[site_nbr][i%N] for k in range(4)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h[site_nbr][i%N] - sum_neighbors
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16608132716049404}
#island_id: 1
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the energy from left and right neighbors
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,(i+1)%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate the energy from up and down neighbors
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[2,i%N,N-1-i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    site_nbr = (i % N + ((0)%2 - 1)) % N
    if J[3,i%N,0] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Apply the external field and update priorities
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin based on magnetism at each site
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Calculate priority for each spin assignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00846712962962963}
#island_id: 1
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((3)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr1][i//N]
    else:
      total_spin -= h[site_nbr1][i//N]
    
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      total_spin += h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr2][i%N]
    
    site_nbr3 = (i // N + ((i%N+1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      total_spin += h[site_nbr3][i%N]
    else:
      total_spin -= h[site_nbr3][i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.11174706790123468}
#island_id: 1
#version_generated: 2
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15055108024691377}
#island_id: 1
#version_generated: 2
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1,2]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[3,i%N,k] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16567083333333357}
#island_id: 1
#version_generated: 2
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr3][i//N]
      priorities[i][1] -= h[site_nbr4][i//N]
    else:
      priorities[i][0] -= h[site_nbr3][i//N]
      priorities[i][1] += h[site_nbr4][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.0018856481481481482}
#island_id: 0
#version_generated: 2
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3.5
      priorities[i][1] -= 2.5 * total_spin
    else:
      priorities[i][0] -= total_spin * 3.5
      priorities[i][1] += 2.5 * total_spin
    
    for k in range(3):
     site = (i % N + ((k-1)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] += 3.5 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
       priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] -= 2.5 * np.sum(J[:,site,i%N])*h[site][i%N]

    # Add interactions with diagonally neighboring sites
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
     priorities[i][0] -= np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
     priorities[i][1] += 3.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
    else:
     priorities[i][0] += np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]
     priorities[i][1] -= 2.5 * np.sum(J[:,site_nbr,i%N])*h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0010563271604938265}
#island_id: 0
#version_generated: 2
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 4
      priorities[i][1] -= 3 * total_spin
    else:
      priorities[i][0] -= total_spin * 4
      priorities[i][1] += 3 * total_spin
    
    for k in range(2):
     site = (i % N + ((k)%2 - 1)) % N
     if h[site][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] += 3 * np.sum(J[:,site,i%N])*h[site][i%N]
     else:
       priorities[i][0] += np.sum(J[:,site,i%N])*h[site][i%N]
       priorities[i][1] -= 3 * np.sum(J[:,site,i%N])*h[site][i%N]

  return(priorities)




#score: {'data2D.txt': 0.0022381172839506087}
#island_id: 2
#version_generated: 2
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site magnetism
  site_magnetisms = h.flatten()
  
  # Calculate interactions with nearest neighbors
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  # Calculate total priority for each spin assignment
  priorities[:, 0] = -site_magnetisms + np.sum(nn_interactions * (-h.reshape(N*N, 1)), axis=1)
  priorities[:, 1] = -priorities[:, 0]
  
  return priorities




#score: {'data2D.txt': -0.024706944444444445}
#island_id: 2
#version_generated: 2
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row_idx, col_idx = divmod(i, N)
    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (row_idx + offset[0]) % N, (col_idx + offset[1]) % N
      if J[offset[1],i//N,i%N] > 0:
        h_site += h[neighbor_row][neighbor_col]
      else:
        h_site -= h[neighbor_row][neighbor_col]

    if h[row_idx][col_idx] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site - 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site + 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])

  return(priorities)




#score: {'data2D.txt': -0.008151388888888889}
#island_id: 2
#version_generated: 2
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      j_index = (k+N-1)%N
      if J[k,i%N,j_index] > 0:
        h_site += J[k,i%N,j_index]*h[j_index][i%N]
      else:
        h_site -= J[k,i%N,j_index]*h[j_index][i%N]

    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0014964506172839508}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006821141975308643}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h[site_nbr][i%N] - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0014964506172839508}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin[i][0] + 1
      priorities[i][1] -= total_spin[i][1] + 1
    else:
      priorities[i][0] -= total_spin[i][0] - 1
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0009390432098765431}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

    for k in range(3):
      if J[k,i%N,i//N] > 0:
        h_site_nbr = h[site_nbr][i%N]
      else:
        h_site_nbr = -h[site_nbr][i%N]
      
      priorities[i][1] += J[k,i%N,i//N]*h_site_nbr
  
  return(priorities)




#score: {'data2D.txt': 0.004962808641975309}
#island_id: 3
#version_generated: 2
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - neighbor_sum
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      j_index = (k+N-1)%N
      h_site = J[k,i%N,j_index]*h[j_index][i%N]
      priorities[i][0] += h_site
      if h[i//N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      site_nbr = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      site_nbr = (i + ((j-2)%N + 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      site_nbr = (i + ((j+2)%N - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return(total_spin)




#score: {'data2D.txt': -0.01366280864197531}
#island_id: 2
#version_generated: 2
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    for k in range(3):
      j_index = (k+N-1)%N
      if J[k,i%N,j_index] > 0:
        h_site += J[k,i%N,j_index]*h[j_index][i%N]
      else:
        h_site -= J[k,i%N,j_index]*h[j_index][i%N]
    priorities[i][0] = h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0023029320987654318}
#island_id: 1
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Prioritize the assignment of spins based on total spin
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    elif total_spin < 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.006718981481481481}
#island_id: 2
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (i//N + offset[0]) % N, (i%N + offset[1]) % N
      if J[offset[1],neighbor_row,i%N] > 0:
        h_site += h[site_nbr][neighbor_col]
      else:
        h_site -= h[site_nbr][neighbor_col]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site - 2*(J[1,i//N,i%N]*h[i//N][i%N] + J[3,i//N,i%N]*h[(i//N+N-1)%N][i%N])
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site + 2*(J[1,i//N,i%N]*h[i//N][i%N] + J[3,i//N,i%N]*h[(i//N+N-1)%N][i%N])

  return(priorities)




#score: {'data2D.txt': 0.014965895061728397}
#island_id: 2
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    row_idx, col_idx = divmod(i, N)
    total_h = h[site_nbr][col_idx]
    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (row_idx + offset[0]) % N, (col_idx + offset[1]) % N
      total_h += J[offset[1],i//N,i%N]*h[neighbor_row][neighbor_col]
    if h[row_idx][col_idx] > 0:
      priorities[i][0] = total_h
      priorities[i][1] = -total_h - 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])
    else:
      priorities[i][0] = -total_h
      priorities[i][1] = total_h + 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])
  return(priorities)




#score: {'data2D.txt': -0.03190540123456791}
#island_id: 2
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row_idx, col_idx = divmod(i, N)
    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (row_idx + offset[0]) % N, (col_idx + offset[1]) % N
      if J[offset[1],i//N,i%N] > 0:
        h_site += h[neighbor_row][neighbor_col]
      else:
        h_site -= h[neighbor_row][neighbor_col]

    site_nbr = (row_idx + ((col_idx-1)%2 - 1)) % N
    if J[2,i//N,i%N] > 0:
      h_site += h[site_nbr][col_idx]
    else:
      h_site -= h[site_nbr][col_idx]

    if h[row_idx][col_idx] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site - 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site + 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])

  return(priorities)




#score: {'data2D.txt': -0.0010347222222222225}
#island_id: 2
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (i // N + offset[0]) % N, (i % N + offset[1]) % N
      total_spin += J[offset[1], i//N,i%N] * h[neighbor_row][neighbor_col]

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin - 2*(J[1,i//N,i%N]*h[i//N][i%N] + J[3,i//N,i%N]*h[(i//N+N-1)%N][i%N])
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 2*(J[1,i//N,i%N]*h[i//N][i%N] + J[3,i//N,i%N]*h[(i//N+N-1)%N][i%N])

  return(priorities)




#score: {'data2D.txt': -0.11828040123456797}
#island_id: 2
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row_idx, col_idx = divmod(i, N)
    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (row_idx + offset[0]) % N, (col_idx + offset[1]) % N
      if J[offset[1],i//N,i%N] > 0:
        h_site += J[offset[1],i//N,i%N]*h[neighbor_row][neighbor_col]
      else:
        h_site -= J[offset[1],i//N,i%N]*h[neighbor_row][neighbor_col]

    if h[row_idx][col_idx] > 0:
      priorities[i][0] = h_site + np.sum(J[:, i//N, i%N])
      priorities[i][1] = -h_site - 2*np.sum(h[row_idx], axis=0)
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site

  return(priorities)




#score: {'data2D.txt': -0.0008720679012345686}
#island_id: 2
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    # Calculate the priority based on the magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + J[:, i//N, i%N].sum()
      priorities[i][1] = -total_spin - 2*(J[1, i//N, i%N]*h[i//N][i%N] + J[3, i//N, i%N]*h[(i//N+N-1)%N][i%N])
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 2*(J[1, i//N, i%N]*h[i//N][i%N] + J[3, i//N, i%N]*h[(i//N+N-1)%N][i%N])
    
  return priorities




#score: {'data2D.txt': 0.005670833333333332}
#island_id: 2
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    row_idx, col_idx = divmod(i, N)
    site_nbr = (row_idx + ((col_idx-1)%2 - 1)) % N
    h_site = h[site_nbr][col_idx]
    
    if J[0,i//N,i%N] > 0:
      h_site += h[row_idx][col_idx]
    else:
      h_site -= h[row_idx][col_idx]

    for offset in [(1,0), (0,1), (-1,0), (0,-1)]:
      neighbor_row, neighbor_col = (row_idx + offset[0]) % N, (col_idx + offset[1]) % N
      if J[offset[1],i//N,i%N] > 0:
        h_site += h[neighbor_row][neighbor_col]
      else:
        h_site -= h[neighbor_row][neighbor_col]

    if h[row_idx][col_idx] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -h_site - 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = h_site + 2*(J[1,i//N,i%N]*h[row_idx][col_idx] + J[3,i//N,i%N]*h[(row_idx+N-1)%N][col_idx])

  return(priorities)




#score: {'data2D.txt': -0.2188405864197532}
#island_id: 1
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=(i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0]+=h[site_nbr][i%N]
    if h[i//N][i%N]>0:
      total_spin[i][1]-=1
    else:
      total_spin[i][1]+=1
    for k in range(4):
      if J[k,i%N,i//N]>0:
        total_spin[i][0]+=(h[site_nbr][i%N]*J[k,i//N,i//N])
        total_spin[i][1]-=h[site_nbr][i%N]*J[k,i//N,i//N]
      else:
        total_spin[i][0]-=h[site_nbr][i%N]*J[k,i//N,i//N]
        total_spin[i][1]+=(h[site_nbr][i%N]*J[k,i//N,i//N])
  return(total_spin)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0687257716049383}
#island_id: 0
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if J[2,i//N,site_nbr] > 0:
      total_energy += sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])
    else:
      total_energy -= sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])

    priorities[i][0] = (h_site + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.00029552469135802484}
#island_id: 0
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] * sum([J[j,i//N,site_nbr] for j in range(3)]) / abs(J[0,i//N,site_nbr])
    if J[0,i//N,site_nbr] > 0:
      total_energy -= h[i//N][i%N]
    else:
      total_energy += h[i//N][i%N]

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0023640432098765425}
#island_id: 0
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total energy of the site
    total_energy = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, nn_site] > 0:
        total_energy += h[nn_site][i%N]
      else:
        total_energy -= h[nn_site][i%N]

    # Calculate the priority for each spin state
    priorities[i][0] = (h[site_nbr][i%N] + total_energy) / abs(h[i//N][i%N])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.08992515432098773}
#island_id: 0
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if J[2,i//N,site_nbr] > 0:
      total_energy += sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])
    else:
      total_energy -= sum([h[k][i%N] for k in range(N) if ((k-1)%2 - 1) == (site_nbr-1)%N])

    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.10680663580246925}
#island_id: 1
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.03068101851851854}
#island_id: 1
#version_generated: 2
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N]
    
    if i % N > 0:
      total_spin += h[site_nbr2][i%N] + J[3,i//N,i%N]
    if i // N > 0:
      total_spin += h[i//N,(i+1)%N] + J[1,i//N,i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site magnetism
  site_magnetisms = h.flatten()
  
  # Calculate interactions with nearest neighbors
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  # Calculate total priority for each spin assignment
  priorities[:, 0] = -site_magnetisms + np.sum(nn_interactions * (-h.reshape(N*N, 1)), axis=1) + np.sum(nn_interactions * (h.reshape(N*N, 1)), axis=1)
  priorities[:, 1] = -priorities[:, 0]
  
  return priorities




#score: {'data2D.txt': 0.0036566358024691355}
#island_id: 0
#version_generated: 2
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = J[3,i//N,site_nbr] * h[i//N][i%N]
    nn_energy = (J[0,i//N,site_nbr] + J[1,i//N,site_nbr]) * h[i//N][i%N]
    if J[2,i//N,site_nbr] > 0:
      nn_energy += h_site
    else:
      nn_energy -= h_site

    priorities[i][0] = -h_site - nn_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0529408950617284}
#island_id: 0
#version_generated: 2
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + nn_energy
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.01092391975308642}
#island_id: 0
#version_generated: 2
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    # Prioritize the spin with lower energy
    priorities[i][0] = min(h_site + nn_energy, -h_site - nn_energy)
    priorities[i][1] = max(-priorities[i][0], 0)

  return(priorities)




#score: {'data2D.txt': 0.010981327160493827}
#island_id: 0
#version_generated: 2
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy = (J[1,i//N,site_nbr] + J[2,i//N,site_nbr]) * h[i//N][i%N]
    if J[3,i//N,site_nbr] > 0:
      nn_energy += h[i//N][i%N]
    else:
      nn_energy -= h[i//N][i%N]

    # Add the site's energy and its nearest neighbors' energies
    priorities[i][0] = h_site + nn_energy
    if J[0,i%N,i//N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.34004675925925826}
#island_id: 2
#version_generated: 2
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  site_magnetisms = h.flatten()
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  for i in range(N*N):
    total_spin = -site_magnetisms[i] + np.sum(nn_interactions[(i % N + ((i//N-1)%2 - 1)) % N * N:(i % N + ((i//N-1)%2 - 1)) % N + (i % N):(4*(i%N)+1)].flatten()) 
    priorities[i, 0] = total_spin
    priorities[i, 1] = -total_spin
  
  return priorities




#score: {'data2D.txt': 0.10706373456790137}
#island_id: 1
#version_generated: 2
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i // N) % N + ((i % N-1)%2 - 1)) % N
    total_spin1 = h[site_nbr1][i%N]
    total_spin2 = h[site_nbr2][i//N]
    
    if J[0,i//N,i%N] > 0:
      total_spin1 += 1
    else:
      total_spin1 -= 1
    
    if J[1,i//N,i%N] > 0:
      total_spin2 += 1
    else:
      total_spin2 -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin1 + total_spin2, -total_spin1 - total_spin2]
    else:
      priorities[i] = [-total_spin1 - total_spin2, total_spin1 + total_spin2]
    
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.038315895061728396}
#island_id: 1
#version_generated: 2
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    neighbor_spins = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += neighbor_spins
      priorities[i][1] -= neighbor_spins
    else:
      priorities[i][0] -= neighbor_spins
      priorities[i][1] += neighbor_spins
    
  return(priorities)




#score: {'data2D.txt': -0.0002788580246913579}
#island_id: 0
#version_generated: 2
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  # Sort sites by priority and reverse the order
  indices = np.argsort(priorities[:,0])[::-1]
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': -0.0002788580246913579}
#island_id: 0
#version_generated: 2
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  # Sort sites by priority and reverse the order
  indices = np.argsort(priorities[:,0])[::-1]
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': -0.0002788580246913579}
#island_id: 0
#version_generated: 2
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  # Sort sites by priority and reverse the order
  indices = np.argsort(priorities[:,0])[::-1]
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': -0.0002788580246913579}
#island_id: 0
#version_generated: 2
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    
    for j in range(4):
      neighbor = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
        neighbor = (neighbor + ((j-1)%2 - 1)) % N
      total_spin += np.sum(J[j, i//N, :])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  # Sort sites by priority and reverse the order
  indices = np.argsort(priorities[:,0])[::-1]
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.0010473765432098762}
#island_id: 1
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3-i)%2 - 1)) % N
    if h[site_nbr][i%N] * h[site_nbr2][i//N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.004962808641975309}
#island_id: 3
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - neighbor_sum
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.00119891975308642}
#island_id: 3
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum_h = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    neighbor_sum_J = np.sum([abs(J[k,i%N,i//N]) for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + neighbor_sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - (neighbor_sum_J - neighbor_sum_h)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.004962808641975309}
#island_id: 3
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i % (N * N) < N // 2:
      priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011495370370370368}
#island_id: 3
#version_generated: 2
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -neighbor_sum
      priorities[i][1] = neighbor_sum
    else:
      priorities[i][0] = neighbor_sum
      priorities[i][1] = -neighbor_sum
  
  return(priorities)




#score: {'data2D.txt': 0.06348842592592595}
#island_id: 2
#version_generated: 2
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  site_magnetisms = h.flatten()
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  for i in range(N*N):
    total_spin_magnetism = site_magnetisms[i] + np.sum(nn_interactions[2*i:2*i+2]) + np.sum(nn_interactions[2*i+1:2*i+3])
    priorities[i, 0] = -total_spin_magnetism
    priorities[i, 1] = total_spin_magnetism
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site magnetism
  site_magnetisms = h.flatten()
  
  # Calculate interactions with nearest neighbors
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  # Calculate total priority for each spin assignment
  priorities[:, 0] = -site_magnetisms + np.sum(nn_interactions * (-h.reshape(N*N, 1)), axis=1) + np.sum(nn_interactions * (h.reshape(N*N, 1)), axis=1)
  priorities[:, 1] = -priorities[:, 0]
  
  # Add a term to favor the spin with the same sign as site magnetism
  priorities[:, 0] += np.where(site_magnetisms > 0, 1, -1) * site_magnetisms
  priorities[:, 1] -= priorities[:, 0]
  
  return priorities




#score: {'data2D.txt': 0.03591589506172839}
#island_id: 2
#version_generated: 2
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  site_magnetisms = h.flatten()
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  for i in range(N*N):
    total_spin = -site_magnetisms[i]
    
    if i % (N * N // N) < N // N:
      total_spin += sum(nn_interactions[i:i+N//2])
    else:
      total_spin -= sum(nn_interactions[i-N//2:i])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site magnetism
  site_magnetisms = h.flatten()
  
  # Calculate interactions with nearest neighbors
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  # Calculate total priority for each spin assignment
  priorities[:, 0] = -site_magnetisms + np.sum(nn_interactions * (-h.reshape(N*N, 1)), axis=1) + np.sum(nn_interactions * (h.reshape(N*N, 1)), axis=1)
  priorities[:, 1] = -priorities[:, 0]
  
  return priorities




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  site_magnetisms = h.flatten()
  nn_interactions = J.reshape(4, N*N).T.flatten()

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return priorities




#score: {'data2D.txt': -0.001118364197530864}
#island_id: 0
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[k][i//N,i//N]*h[(site_nbr+k-1)%4][i%N] for k in range(4)])
    J_down = J[3][i//N,i//N]*h[site_nbr][i%N]

    if h_site * (J_up - J_down) > 0:
      priorities[i][0] = h_site * J_up
      priorities[i][1] = -priorities[i][0]
    else:
      total_energy = h_site * J_up + J_down
      priorities[i][0] = total_energy
      priorities[i][1] = total_energy
  return(priorities)




#score: {'data2D.txt': -0.0009245370370370373}
#island_id: 0
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns_up = [J[k][i//N,i//N]*h[(site_nbr+k-1)%4][i%N] for k in range(4)]
    J_up = np.sum(nns_up)
    priorities[i][0] = h_site * J_up
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0005674382716049384}
#island_id: 0
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [J[k][i//N,i//N]*h[(site_nbr+k-1)%4][i%N] for k in range(4)]
    J_up = np.sum(nns)
    J_down = -np.sum([J[k][i//N,i//N]*h[(site_nbr+k-1)%4][i%N] for k in range(4)])
    priorities[i][0] = h_site * J_up
    priorities[i][1] = -priorities[i][0]

  # Add an extra term to prioritize the site's magnetism if it is strong
  for i in range(N**2):
    priorities[i][0] += 0.5 * np.abs(h[i//N][i%N])
    priorities[i][1] -= 0.5 * np.abs(h[i//N][i%N])

  return(priorities)




#score: {'data2D.txt': 0.16370941358024707}
#island_id: 1
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [(0,i//N),(1,(i+N)%N),(2,(i-N)%N),(3,i//N)]:
      if J[k[0],k[1]%N,k[1]//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.12323688271604953}
#island_id: 1
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if J[3,i//N,i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16518070987654346}
#island_id: 1
#version_generated: 2
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i//N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr_row][site_nbr_col]
      total_spin -= h[site_nbr_col][i%N]
    else:
      total_spin -= h[site_nbr_row][site_nbr_col]
      total_spin += h[site_nbr_col][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.09978904320987664}
#island_id: 2
#version_generated: 2
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  site_magnetisms = h.flatten()
  
  nn_interactions = J.reshape(4, N*N).T.flatten()
  
  for i in range(N*N):
    if i % (N+1) < N//2:
      x_left = (i - 1) % (N*N) if i > 0 else None
      x_right = (i + 1) % (N*N) if i < N*N-1 else None
      y_top = (i-N) if i >= N else None
      y_bottom = (i+N) % (N*N) if i < N*N-N else None
      
      priorities[i][0] += site_magnetisms[i] + sum([nn_interactions[j] for j in [x_left, x_right, y_top, y_bottom] if j is not None])
      priorities[i][1] = -priorities[i][0]
    elif i % (N+1) == N//2:
      x_left = (i - 1) % (N*N) if i > 0 else None
      x_right = (i + 1) % (N*N) if i < N*N-1 else None
      
      priorities[i][0] += site_magnetisms[i] + sum([nn_interactions[j] for j in [x_left, x_right] if j is not None])
      priorities[i][1] = -priorities[i][0]
    else:
      y_top = (i-N) if i >= N else None
      y_bottom = (i+N) % (N*N) if i < N*N-N else None
      
      priorities[i][0] += site_magnetisms[i] + sum([nn_interactions[j] for j in [y_top, y_bottom] if j is not None])
      priorities[i][1] = -priorities[i][0]
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site magnetism
  site_magnetisms = h.flatten()
  
  # Calculate interactions with nearest neighbors
  nn_interactions = J.reshape(4, N*N).T.flatten().reshape(N,N,4)
  
  # Calculate total priority for each spin assignment
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priorities[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  
  return priorities




#score: {'data2D.txt': -9.120370370370368e-05}
#island_id: 3
#version_generated: 2
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -neighbor_sum - np.sum(J[:,i//N,i//N])
      priorities[i][1] = neighbor_sum + np.sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = neighbor_sum + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -neighbor_sum - np.sum(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.0008526234567901236}
#island_id: 3
#version_generated: 2
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -neighbor_sum
      priorities[i][1] = neighbor_sum
    else:
      priorities[i][0] = neighbor_sum
      priorities[i][1] = -neighbor_sum
  
  return(priorities)




#score: {'data2D.txt': 0.0011495370370370368}
#island_id: 3
#version_generated: 2
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -neighbor_sum * N
      priorities[i][1] = neighbor_sum * N
    else:
      priorities[i][0] = neighbor_sum * N
      priorities[i][1] = -neighbor_sum * N
    
  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 7.021604938271642e-05}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

    if J[3,i%N,i//N] > 0:
      priorities[i][0] += J[3,i%N,i//N]
      priorities[i][1] -= J[3,i%N,i//N]
    else:
      priorities[i][0] -= J[3,i%N,i//N]
      priorities[i][1] += J[3,i%N,i//N]

  return(priorities)




#score: {'data2D.txt': -0.001291820987654321}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0003566358024691363}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0016063271604938277}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    sum_neighbors1 = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    sum_neighbors2 = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if i % (N * N) < N // 2:
      priorities[i][0] = h_site1 + sum_neighbors1
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site2 + sum_neighbors2
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007473765432098768}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_neighbors = np.sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] = h_site + sum_neighbors
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = h_site - sum_neighbors
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.012409722222222223}
#island_id: 3
#version_generated: 2
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = h[site_nbr][i%N] + total_spin
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.001845216049382715}
#island_id: 3
#version_generated: 2
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin - 1
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.00801990740740741}
#island_id: 0
#version_generated: 2
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    elif J[0,i//N,i%N] < 0:
      total_spin -= 1
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      elif J[j,i//N,i%N] < 0:
        total_spin -= 1
    priorities[i][0] = 2*total_spin
    priorities[i][1] = -2*total_spin
  return(priorities)




#score: {'data2D.txt': -0.028455401234567884}
#island_id: 0
#version_generated: 2
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=((i//N)%N + ((i%N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    site_nbr=((i//N)%N + ((i%N+1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    site_nbr=((i-1)%N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[2,i//N,i%N]
      priorities[i][1] -= J[2,i//N,i%N]
    site_nbr=((i-1)%N + ((i//N+1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]
      priorities[i][1] -= J[3,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = 4*sum(priorities[i])
      priorities[i][1] = -3*sum(priorities[i])
    else:
      priorities[i][0] = -4*sum(priorities[i])
      priorities[i][1] = 3*sum(priorities[i])
  return(priorities)




#score: {'data2D.txt': -0.04364182098765432}
#island_id: 0
#version_generated: 2
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i+1) % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    else:
      priorities[i][0] -= J[0,i//N,i%N]
      priorities[i][1] += J[0,i//N,i%N]
    if h[site_nbr2][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N] + J[2,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N] - J[2,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N] - J[2,i//N,i%N]
      priorities[i][1] += J[1,i//N,i%N] + J[2,i//N,i%N]
  return(priorities)




