score: {'data3D.txt': -0.4916790000000001}
#island_id: None
#version_generated: None
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': 0.08978540000000002}
#island_id: 2
#version_generated: 2
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[(i + ((m % 3) - 1)) % N][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0006594000000000002}
#island_id: 3
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  return(priorities)




#score: {'data3D.txt': 0.0006594000000000002}
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0010730000000000004}
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= sum(J[d][i][j][k] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        else:
          priorities[i*N*j+k][1] += sum(J[d][i][j][k] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
  return(priorities)




#score: {'data3D.txt': 0.0006594000000000002}
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.002955}
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) + total_spin)
        else:
          priorities[i*N*j+k][1] += (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) - total_spin)
  return(priorities)




#score: {'data3D.txt': 0.0006594000000000002}
#island_id: 3
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  return(priorities)




#score: {'data3D.txt': 0.0448086}
#island_id: 2
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.06430659999999999}
#island_id: 2
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0009593999999999936}
#island_id: 2
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0448086}
#island_id: 2
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.029593400000000002}
#island_id: 2
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        if total_spin_1[0] > total_spin_minus_1[0]:
          priorities[i][j][k] = [total_spin_1[0], total_spin_1[1]]
        else:
          priorities[i][j][k] = [total_spin_minus_1[0], total_spin_minus_1[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.38087820000000006}
#island_id: 0
#version_generated: 2
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins - h).flatten()
    priorities += priority_change
  return np.array([priorities, np.zeros(N**3)]).T.reshape(-1,2)




#score: {'data3D.txt': 0.0011365999999999998}
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin/abs(total_spin)
        else:
          priorities[i*N*j+k][1] = total_spin/abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -1.1400000000000077e-05}
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[(d-1)%3], site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 1
        else:
          priorities[i*N*j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.2638766}
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[1] += 2*J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.05766619999999999}
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.10325419999999999}
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(2):
          priorities[i][j][k][m] = np.sum([J[n,i,j,k]*h[x][j][k] if h[x][j][k] == ((-1)**((n+m)%2))-1 else -J[n,i,j,k]*((-1)**((n+m)%2))+1 for n,x in enumerate(site_nbrs)])
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0847274}
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if site_nbrs[l] == site_nbr])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if site_nbrs[l] == site_nbr])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.10351900000000011}
#island_id: 2
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        total_spin[1] += 2*h[i][j][k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0010077999999999997}
#island_id: 2
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0016337999999999995}
#island_id: 3
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        else:
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)




#score: {'data3D.txt': 0.0001881999999999997}
#island_id: 0
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins.flatten() - h.flatten())
    priorities += np.array([priority_change, -priority_change]).T.reshape(-1, 2)
  return priorities




#score: {'data3D.txt': 0.05732220000000001}
#island_id: 2
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.05732220000000001}
#island_id: 2
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0788418}
#island_id: 2
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum(J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0010402}
#island_id: 3
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= max(1, abs(total_spin))
        else:
          priorities[i*N*j+k][1] = -max(1, abs(total_spin))
  return(priorities)




#score: {'data3D.txt': -0.0003534000000000004}
#island_id: 3
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][0] -= total_spin
          priorities[i*N*j+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.0006290000000000002}
#island_id: 3
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)




#score: {'data3D.txt': -0.0008465999999999998}
#island_id: 3
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([(-1)**d*h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6)])
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        else:
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)




#score: {'data3D.txt': -0.0027918}
#island_id: 2
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0019562}
#island_id: 2
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]])
          else:
            total_spin[0] -= sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.2885234000000002}
#island_id: 0
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + 1*h[i,j,k]
        priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]

  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.0233874}
#island_id: 0
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
    
  return priorities.reshape(-1,2)




#score: {'data3D.txt': 0.08978540000000002}
#island_id: 2
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0012654000000000007}
#island_id: 0
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2*N+N-1+i%N][0] += 1
      priorities[i//N**2*N+N-1+i%N][1] -= 1
    else:
      priorities[i//N**2*N+N-1+i%N][0] -= 1
  return priorities




#score: {'data3D.txt': -0.0012226}
#island_id: 0
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, i%N, (i // N) % N)
    total_spin = h[site_nbr[0]][site_nbr[1]] + h[site_nbr[0]][site_nbr[2]]
    
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
  
  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.0015158}
#island_id: 3
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= abs(total_spin)
        else:
          priorities[i*N*j+k][0] -= total_spin
          priorities[i*N*j+k][1] = -abs(total_spin)
  return(priorities)




#score: {'data3D.txt': 0.05766619999999999}
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.015800599999999998}
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] > 0:
            total_spin[0] += J[m,i,j,k]
            total_spin[1] -= J[m,i,j,k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m,i,j,k]
            total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0017517999999999998}
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0012226}
#island_id: 0
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, i%N, (i // N) % N)
    
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
      
  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.0023878}
#island_id: 0
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][(site_nbr[1]-1)%N] + h[site_nbr[0]][(site_nbr[1]+1)%N] + h[site_nbr[0]][(site_nbr[2]-1)%N] + h[site_nbr[0]][(site_nbr[2]+1)%N]
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
    
  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.38087820000000006}
#island_id: 0
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins - h).flatten()
    priorities += priority_change
  return np.array([priorities, np.zeros(N**3)]).T.reshape(-1,2)




#score: {'data3D.txt': 0.17591340000000003}
#island_id: 2
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1 += J[m,i,j,k]
          else:
            total_spin_0 += J[m,i,j,k]
        priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.1692022000000002}
#island_id: 2
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        priorities[i][j][k] = [total_spin_zeros, total_spin_ones]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0026205999999999994}
#island_id: 2
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        if all([h[s][j][k] > 0 for s in site_nbrs]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[s][j][k] < 0 for s in site_nbrs]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.08978540000000002}
#island_id: 2
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[(i + ((m % 3) - 1)) % N][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0056258}
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][(site_nbr[1]-1)%N] + h[site_nbr[0]][(site_nbr[1]+1)%N] + h[site_nbr[0]][(site_nbr[2]-1)%N] + h[site_nbr[0]][(site_nbr[2]+1)%N]
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = ((k-1)%2 - 1) % N
        interacting_spins = h[i][j]
        if J[k, i, j].flatten()[0] > 0:
          priorities[i,j,k][0] += 1
          priorities[i,j,k][1] -= 1
        else:
          priorities[i,j,k][0] -= 1
  
  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.002197}
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = ((i//N + ((i//N-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    total_spin = interacting_spins
    for k in range(3):
      site = ((i//N + ((k-1)%2 - 1)) % N, (i // N) % N, i%N)
      if h[site[0]][site[1]][site[2]] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if J[0, site_nbr[0], site_nbr[1], site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return priorities




#score: {'data3D.txt': -0.002955}
#island_id: 3
#version_generated: 3
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) + total_spin)
        else:
          priorities[i*N*j+k][1] += (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) - total_spin)
  return(priorities)




#score: {'data3D.txt': -0.002955}
#island_id: 3
#version_generated: 3
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) + total_spin)
        else:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] += (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) - total_spin)
  return(priorities)




#score: {'data3D.txt': 0.00046899999999999964}
#island_id: 3
#version_generated: 3
#generate time15:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for _ in range(3)]
          total_spin += J[d][site_nbrs[0], site_nbrs[1], site_nbrs[2]] * h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
        priorities[i*N*j+k][0] = -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.17591340000000003}
#island_id: 2
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            if J[m, i, j, k] > 0:
              total_spin_0 += J[m, i, j, k]
            else:
              total_spin_1 += J[m, i, j, k]
          else:
            if J[m, i, j, k] < 0:
              total_spin_0 += J[m, i, j, k]
            else:
              total_spin_1 += J[m, i, j, k]
        priorities[i*N**2+j*N+k][0] = total_spin_0
        priorities[i*N**2+j*N+k][1] = -total_spin_1
  return(priorities.astype(int))




#score: {'data3D.txt': 0.2748426}
#island_id: 2
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1 += J[m,i,j,k]
          else:
            total_spin_0 += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] == h[i][j][k]:
            total_spin_0 += J[m,i,j,k]
          else:
            total_spin_1 -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.17591340000000003}
#island_id: 2
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1 += J[m,i,j,k]
          else:
            total_spin_0 += J[m,i,j,k]
        priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            if J[m,i,j,k] > 0:
              total_spin_0 += J[m,i,j,k]
              total_spin_1 -= J[m,i,j,k]
            else:
              total_spin_0 -= J[m,i,j,k]
              total_spin_1 += J[m,i,j,k]
          priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0028334}
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, j, k]
          if h[tuple(site_nbrs)] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, j, k]
          if h[tuple(site_nbrs)] == h[i, j, k]:
            total_spin[0] += J[m, i, j, k]
          else:
            total_spin[0] -= J[m, i, j, k]
        priorities[i*N + j + k] = [total_spin[0], -total_spin[1]]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.0005510000000000004}
#island_id: 3
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[(d-1)%3], site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + 1)
        else:
          priorities[i*N*j+k][1] = total_spin - 1
  return(priorities)




#score: {'data3D.txt': -0.0010550000000000006}
#island_id: 2
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
            total_spin_minus_1[1] += J[m, i, j, k]
          else:
            total_spin_1[1] += J[m, i, j, k]
            total_spin_minus_1[1] -= J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin_1[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
            total_spin_minus_1[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
          else:
            total_spin_1[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
            total_spin_minus_1[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        if total_spin_1[0] > total_spin_minus_1[0]:
          priorities[i*N+j+k, 0] = -total_spin_1[1]
          priorities[i*N+j+k, 1] = 1
        else:
          priorities[i*N+j+k, 0] = -total_spin_minus_1[1]
          priorities[i*N+j+k, 1] = -1
  return(priorities)




#score: {'data3D.txt': -0.0018622}
#island_id: 2
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
            total_spin_minus_1[1] += J[m, i, j, k]
          else:
            total_spin_1[1] += J[m, i, j, k]
            total_spin_minus_1[1] -= J[m, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k, 0] = total_spin_1[0] + sum([J[l, i, j, k] for l in range(6) if h[site_nbrs[l]][j][k] > 0])
          priorities[i*N+j+k, 1] = -total_spin_1[1]
        else:
          priorities[i*N+j+k, 0] = total_spin_minus_1[0] + sum([J[l, i, j, k] for l in range(6) if h[site_nbrs[l]][j][k] < 0])
          priorities[i*N+j+k, 1] = -total_spin_minus_1[1]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.0011466000000000002}
#island_id: 2
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        priorities[i*N+j+k, 0] = -total_spin[1]
        priorities[i*N+j+k, 1] = total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0021342000000000006}
#island_id: 2
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbrs[m]][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbrs[m]][l][k]])
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0023478}
#island_id: 2
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] * h[site_nbr][j][k] > 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] * h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        if np.abs(h[i][j][k]) > 0.5:
          priorities[i*N+j+k, 0] = total_spin[0] + h[i][j][k] * (N**2)
          priorities[i*N+j+k, 1] = -total_spin[1] - h[i][j][k] * (N**2)
        else:
          priorities[i*N+j+k, 0] = total_spin[0]
          priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.0025702}
#island_id: 2
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m, i, j, k]
          else:
            total_spin[0] -= J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] > 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] < 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] > 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0021038000000000003}
#island_id: 0
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2*N+N-1+i%N][0] += 1
      priorities[i//N**2*N+N-1+i%N][1] -= 1
    else:
      priorities[i//N**2*N+N-1+i%N][0] -= 1
  for i in range(N):
    if h[0,i].sum() > 0:
      priorities[i*N:N*(i+1),0] = np.cumsum(priorities[i*N:N*(i+1),0])
    else:
      priorities[i*N:N*(i+1),1] = -np.cumsum(priorities[i*N:N*(i+1),0])
  return priorities




#score: {'data3D.txt': -0.1852278000000002}
#island_id: 2
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.11333740000000002}
#island_id: 0
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0,i,j,k] > 0:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
        else:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]

  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.2885234000000002}
#island_id: 0
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
        priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]

  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.046829}
#island_id: 2
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[p,i,j,k] for p in range(6)])
          else:
            total_spin[0] -= sum([J[p,i,j,k] for p in range(6)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.4288834000000002}
#island_id: 2
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_0 += J[m,i,j,k]
            total_spin_1 -= J[m,i,j,k]
          else:
            total_spin_0 -= J[m,i,j,k]
            total_spin_1 += J[m,i,j,k]
        if h[i][j][k] > 0:
          priorities[i][j][k] = [total_spin_0+sum(J[m,i,j,k] for m in range(6)), -total_spin_1]
        else:
          priorities[i][j][k] = [-total_spin_0, total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.102013}
#island_id: 2
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][j][k] == h[(i + ((l % 3) - 1)) % N][j][k]])
          priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0009470000000000007}
#island_id: 3
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin + sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N)) 
          priorities[i*N*j+k][1] -= total_spin - sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N))
        else:
          priorities[i*N*j+k][0] -= total_spin - sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N)) 
          priorities[i*N*j+k][1] = -total_spin + sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N))
  return(priorities)




#score: {'data3D.txt': -0.0009598000000000005}
#island_id: 3
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin + abs(total_spin)
          priorities[i*N*j+k][1] -= total_spin - abs(total_spin)
        else:
          priorities[i*N*j+k][0] -= total_spin + abs(total_spin)
          priorities[i*N*j+k][1] = -total_spin - abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.002787800000000001}
#island_id: 3
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[3]][site_nbrs[(d-1)%3]][site_nbrs[(d-2)%3]] * h[site_nbrs[d]][site_nbrs[(d-1)%3]][site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + abs(total_spin))
        else:
          priorities[i*N*j+k][1] = total_spin - abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.0021846000000000005}
#island_id: 3
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[(d-2)%3]] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + 1)
        else:
          priorities[i*N*j+k][1] = total_spin - 1
  return(priorities)




#score: {'data3D.txt': 0.080145}
#island_id: 2
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0788418}
#island_id: 2
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k]])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0009593999999999936}
#island_id: 2
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (h[i][j][k] == h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0025702}
#island_id: 2
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.38087820000000006}
#island_id: 0
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins - h).flatten()
    priorities += priority_change
  return np.array([priorities, np.zeros(N**3)]).T.reshape(-1,2)




#score: {'data3D.txt': -0.00038260000000000057}
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= total_spin + h[i][j][k]
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = total_spin - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 5.0200000000000576e-05}
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin + (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
          priorities[i*N*j+k][1] -= total_spin - (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin) + (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
          priorities[i*N*j+k][1] = total_spin - (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
  return(priorities)




#score: {'data3D.txt': -0.002045}
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = -2
  return(priorities)




#score: {'data3D.txt': 0.038330199999999995}
#island_id: 0
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (np.where(interacting_spins.flatten() > h.flatten(), 1, -1) - 0.5*np.ones(len(h.flatten())))
    priorities += np.array([priority_change, -priority_change]).T.reshape(-1, 2)
  return priorities




#score: {'data3D.txt': 2.740000000000009e-05}
#island_id: 0
#version_generated: 3
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
        else:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          
  return priorities.reshape(-1,2)




#score: {'data3D.txt': -0.0263994}
#island_id: 2
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0010077999999999997}
#island_id: 2
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0023117999999999997}
#island_id: 2
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[(i*N+j)*N+k] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': 0.005466200000000001}
#island_id: 2
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbrs.sort()
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0022966000000000006}
#island_id: 2
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum(J[:,i,j,k])
          else:
            total_spin[0] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0009582}
#island_id: 2
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            J_val = J[m,i,j,k]
          else:
            J_val = -J[m,i,j,k]
          total_spin[1] += J_val
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.001583000000000001}
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m, i, j, k] for l in range(N)])
          else:
            total_spin[0] += sum([J[m, i, j, k] for l in range(N)])
        priorities[i*N+j*N+k] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': 0.005433399999999999}
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[(i*N+j)*N+k, 0] = -total_spin[1]
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 1] = total_spin[0] + total_spin[1]
        else:
          priorities[(i*N+j)*N+k, 1] = -(total_spin[0] + total_spin[1])
  return(priorities)




#score: {'data3D.txt': 0.0402838}
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr_sum = sum([J[l,i,j,k] for l in range(6) if h[i][l][k] == h[site_nbrs[0]][l][k]])
        priorities[(i*N+j)*N+k] = [total_spin[1] + site_nbr_sum, -total_spin[0]]
  return(priorities)




#score: {'data3D.txt': 0.05210419999999992}
#island_id: 2
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priority_total = np.zeros((N*N,2))
        if h[i][j][k] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] = -1
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            priority_total[i*N+j][0] += 1 + total_spin[1]
            priority_total[i*N+j][1] -= 1 - total_spin[1]
          else:
            priority_total[i*N+j][0] -= 1 + total_spin[1]
            priority_total[i*N+j][1] = -1 + total_spin[1]
        priorities[(i*N+j)*N+k] = [priority_total[i*N+j][0], -priority_total[i*N+j][1]]
  return(priorities)




#score: {'data3D.txt': -0.0228986}
#island_id: 3
#version_generated: 2
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.013903800000000001}
#island_id: 1
#version_generated: 2
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            priorities[i*N+j*N+k][0] += 1
            priorities[i*N+j*N+k][1] -= 1
          else:
            priorities[i*N+j*N+k][0] -= 1
            priorities[i*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.006854600000000001}
#island_id: 2
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m, i, j, k] for l in range(N)])
          else:
            total_spin[0] += sum([J[m, i, j, k] for l in range(N)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0174594}
#island_id: 3
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0223118}
#island_id: 3
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.0120214}
#island_id: 3
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
        total_energy = np.sum(h)
        if total_energy > 0:
          for l in range(6):
            site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
        else:
          for l in range(6):
            site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
  return(priorities)




#score: {'data3D.txt': -0.0174594}
#island_id: 3
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0174594}
#island_id: 3
#version_generated: 3
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N**2 + j*N+k][0] += 1
            priorities[i*N**2 + j*N+k][1] -= 1
          else:
            priorities[i*N**2 + j*N+k][0] -= 1
            priorities[i*N**2 + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N**2+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N**2+j*N+k][1] -= 2
          else:
            priorities[i*N**2+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N**2+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.11155740000000003}
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l < 3:  # x-axis
            priorities[i,j,k] += -J[l,i,j,k]*(2*h[(i+1)%N,j,k]-h[(i-1)%N,j,k])
          elif l < 6:  # y-axis and z-axis
            priorities[i,j,k] += -J[l,i,j,k]*(2*h[i,(j+1)%N,k]-h[i,j,k]+2*h[i,j,(k+1)%N]-h[i,j,k])
  return np.array([priorities.flatten(), np.zeros(N**3)]).T




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i<3 else 1, axis = i//3)
    interacting_spins = interacting_spins + h
    for j in range(N):
      for k in range(N):
        for l in range(N):
          priorities[j,k,l] += -J[i,j,k,l]*(2*interacting_spins[j,k,l]-1)
  return(priorities.reshape((N**3, 2)))




#score: {'data3D.txt': 0.09253659999999994}
#island_id: 1
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities.append([-1 * sum(J[0:3, i, j, k]) + 1, -sum(J[3:, i, j, k]) - 1])
        else:
          priorities.append([sum(J[0:3, i, j, k]) + 1, -sum(J[3:, i, j, k]) + 1])
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            total_spin[0] -= h[i][j][k]
            total_spin[1] += h[i][j][k]

        for l in range(6):
          if l < 3:
            priorities[site_nbr][0] = -total_spin[0]
            priorities[site_nbr][1] = -total_spin[1]
          else:
            if J[l, i, j, k] > 0:
              priorities[site_nbr][0] = total_spin[0]
              priorities[site_nbr][1] = -total_spin[1]
            else:
              priorities[site_nbr][0] = -total_spin[0]
              priorities[site_nbr][1] = total_spin[1]

  return priorities




#score: {'data3D.txt': -0.07541339999999999}
#island_id: 1
#version_generated: 3
#generate time15:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities.append([-1*sum(J[l,i,j,k]*h[(i+n)%N][(j+m)%N][(k+p)%N] for l,n,m,p in [(0,1,0,0), (1,0,1,0), (2,0,0,1), (3,-1,0,0), (4,0,-1,0), (5,0,0,-1)]), 1])
        else:
          priorities.append([float('-inf'), -1*sum(J[l,i,j,k]*h[(i+n)%N][(j+m)%N][(k+p)%N] for l,n,m,p in [(0,1,0,0), (1,0,1,0), (2,0,0,1), (3,-1,0,0), (4,0,-1,0), (5,0,0,-1)])])
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)    
  for i in range(N**3):
    site_nbrs = [(i // (N**2)) % N, (i % (N**2)) // N, i % N]
    total_spin = [0, 0]
    for m in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[1] -= J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[1] += J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] -= J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[0] += J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
    priorities[i] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0017517999999999998}
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0025702}
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        total_spin.sort()
        priorities[i*N+j+k%N] = [total_spin[1], -total_spin[0]]
  return(priorities)




#score: {'data3D.txt': -0.0017517999999999998}
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0451562}
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][1] += 2
        
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2
      
  return(priorities)




#score: {'data3D.txt': -0.0451562}
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.0451562}
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.0048722}
#island_id: 0
#version_generated: 2
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  # Compute priorities for each site with magnetism > 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  # Compute priorities for each site with magnetism < 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0016166000000000008}
#island_id: 1
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j].sum()
      if h[i][j].mean() > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= 3*total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += 3*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] * (h[i][j] > 0) - (1-h[i][j]) * (h[i][j] <= 0)
        priorities[i*N+j*N+k][0] += (total_spin >= 0).sum() * 2
        priorities[i*N+j*N+k][1] -= (total_spin < 0).sum() * 2
  return(priorities)




#score: {'data3D.txt': -0.0095574}
#island_id: 1
#version_generated: 3
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.13726819999999998}
#island_id: 2
#version_generated: 3
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if all([h[site_nbrs[m]][j][k] > 0 for m in range(6)]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[site_nbrs[m]][j][k] < 0 for m in range(6)]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        if h[i][j][k] > 0:
          priority_total = [total_spin[0], -total_spin[1]]
        else:
          priority_total = [-total_spin[0], total_spin[1]]
        priorities[i][j][k] = priority_total
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0263994}
#island_id: 2
#version_generated: 3
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if all([h[s][j][k] > 0 for s in site_nbrs]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[s][j][k] < 0 for s in site_nbrs]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        else:
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.019725799999999998}
#island_id: 2
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            if h[i][j][k] > 0:
              total_spin[0] += J[m,i,j,k]
            else:
              total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.034100200000000004}
#island_id: 2
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0] - np.sum(J[:,i,j,k]), -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.28522020000000003}
#island_id: 1
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            site_nbr2 = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr2][j][k] > 0:
              total_spin[0] += 1
              total_spin[1] -= 1
            else:
              total_spin[0] -= 1
              total_spin[1] += 1
        priorities[site_nbr][0] = -total_spin[0]
        priorities[site_nbr][1] = -total_spin[1]
  return priorities




#score: {'data3D.txt': -0.11626380000000008}
#island_id: 1
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            site_nbr_l = i * N * N + (j+((l-1)%2 - 1)) % N + k
            if l < 3:
              total_spin[0] += h[int(site_nbr_l // N)][site_nbr_l % N][k]
              total_spin[1] -= h[int(site_nbr_l // N)][site_nbr_l % N][k]
            else:
              site_nbr_l = i * N * N + (j+((l-3)%2 - 1)) % N + k
              if l < 3:
                total_spin[0] -= h[int(site_nbr_l // N)][site_nbr_l % N][k]
                total_spin[1] += h[int(site_nbr_l // N)][site_nbr_l % N][k]
              else:
                site_nbr_l = i * N * N + j + (k+((l-4)%2 - 1)) % N
                if l < 3:
                  total_spin[0] -= h[i][j][int(site_nbr_l // N)]
                  total_spin[1] += h[i][j][int(site_nbr_l // N)]
                else:
                  site_nbr_l = i * N * N + j + (k+((l-5)%2 - 1)) % N
                  if l < 3:
                    total_spin[0] += h[i][j][int(site_nbr_l // N)]
                    total_spin[1] -= h[i][j][int(site_nbr_l // N)]

        for l in range(6):
          if J[l, i, j, k] > 0:
            priorities[site_nbr][0] = -total_spin[0]
            priorities[site_nbr][1] = -total_spin[1]
          else:
            priorities[site_nbr][0] = total_spin[0]
            priorities[site_nbr][1] = total_spin[1]

  return priorities




#score: {'data3D.txt': -0.0021538000000000004}
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0031962}
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][0] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][0]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][0]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0014782000000000003}
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[i][site_nbr][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        elif h[i][site_nbr][k] < 0:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        elif h[site_nbr][j][k] < 0:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.004089}
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.005573000000000001}
#island_id: 1
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.003985799999999941}
#island_id: 1
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  return(total_spin.flatten().reshape(N**3,2))




#score: {'data3D.txt': 0.011732199999999998}
#island_id: 1
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbr[0],site_nbr[1],site_nbr[2]])
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0013662000000000008}
#island_id: 0
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.003733}
#island_id: 0
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0012638}
#island_id: 0
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(3):
          if h[site_nbr][j][l] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*k+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][1] -= 2*total_spin
        else:
          priorities[i*N+j*k+k][1] += 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.004180199999999999}
#island_id: 1
#version_generated: 3
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        total_spin[1] -= h[site_nbr][j][k]
      if np.mean(h[i].flatten()) > 0:
        priorities[i*N*N:i*N*N+N**2, 0] += total_spin[0]
        priorities[i*N*N:i*N*N+N**2, 1] -= 3*total_spin[1]
      else:
        priorities[i*N*N:i*N*N+N**2, 0] -= total_spin[0]
        priorities[i*N*N:i*N*N+N**2, 1] += 3*total_spin[1]
  return priorities




#score: {'data3D.txt': -0.0016166000000000008}
#island_id: 1
#version_generated: 3
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j].sum()
      
      if h[i][j].mean() > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= 3*total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += 3*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0036366}
#island_id: 0
#version_generated: 3
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0036366}
#island_id: 0
#version_generated: 3
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0026610000000000006}
#island_id: 0
#version_generated: 3
#generate time16:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin[i*N+j*k+k][0]
          priorities[i*N+j*k+k][1] -= 1 - total_spin[i*N+j*k+k][0]
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin[i*N+j*k+k][0]
          priorities[i*N+j*k+k][1] = -1 + total_spin[i*N+j*k+k][0]

  return(priorities)




#score: {'data3D.txt': -0.0012394}
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        for spin in [1, -1]:
          if h[i][j][k] * spin > 0:
            priorities[i][j][k][0] += total_spin_zeros
            priorities[i][j][k][1] -= total_spin_ones
          else:
            priorities[i][j][k][0] -= total_spin_zeros
            priorities[i][j][k][1] += total_spin_ones
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.16672620000000024}
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        priority_total = [total_spin_zeros, total_spin_ones]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i][j][k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0520462}
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs])
        total_spin_zeros = 5 - total_spin_ones
        if h[i][j][k] > 0:
          priorities[i][j][k] = [total_spin_zeros, total_spin_ones]
        else:
          priorities[i][j][k] = [total_spin_ones, total_spin_zeros]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.004028600000000001}
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Compute total spin for each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
  
  # Compute interaction sum for each site
  interaction_sum = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if J[l][site_nbr][j][k] > 0:
            interaction_sum[i*N+j*k+k][0] += J[l][site_nbr][j][k]
            interaction_sum[i*N+j*k+k][1] -= J[l][site_nbr][j][k]
          else:
            interaction_sum[i*N+j*k+k][0] -= J[l][site_nbr][j][k]
            interaction_sum[i*N+j*k+k][1] += J[l][site_nbr][j][k]
  
  # Combine total spin and interaction sum to get final priorities
  for i in range(N**3):
    if total_spin[i][0] > 0:
      priorities[i][0] += -total_spin[i][1] + interaction_sum[i][0]
      priorities[i][1] -= -total_spin[i][1] + interaction_sum[i][0]
    elif total_spin[i][0] < 0:
      priorities[i][0] -= -total_spin[i][1] + interaction_sum[i][0]
      priorities[i][1] += -total_spin[i][1] + interaction_sum[i][0]
  
  return(priorities)




#score: {'data3D.txt': -0.002058199999999999}
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[0, i, j, k] == 1 and h[site_nbr_l][j][k]:
            total_spin += 1
          elif J[0, i, j, k] == -1 and not h[site_nbr_l][j][k]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[3, i, j, k] == 1 and h[i][site_nbr_l][k]:
            total_spin += 1
          elif J[3, i, j, k] == -1 and not h[i][site_nbr_l][k]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[4, i, j, k] == 1 and h[i][j][site_nbr_l]:
            total_spin += 1
          elif J[4, i, j, k] == -1 and not h[i][j][site_nbr_l]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[5, i, j, k] == 1 and h[i][j][site_nbr_l]:
            total_spin += 1
          elif J[5, i, j, k] == -1 and not h[i][j][site_nbr_l]:
            total_spin -= 1
          
        priorities[i*N+j*k+k][0] = total_spin
        priorities[i*N+j*k+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.004089}
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.004089}
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j][k] > 0:
        total_spin[i*N+j*k+k][1] -= 1
      else:
        total_spin[i*N+j*k+k][1] += 1

  for i in range(N):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[i][j][k] > 0:
      total_spin[i*N+j*k+k][0] -= 1
    else:
      total_spin[i*N+j*k+k][0] += 1

  return(priorities)




#score: {'data3D.txt': 0.011732199999999998}
#island_id: 1
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbr[0],site_nbr[1],site_nbr[2]])
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': 0.011732199999999998}
#island_id: 1
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0016438}
#island_id: 0
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0016438}
#island_id: 0
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0016438}
#island_id: 0
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0027994}
#island_id: 0
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0, 1, 2]]
      total_spin = [h[s][j].sum() if s == i else 0 for s in site_nbrs]
      
      spin_counts = {1: sum(1 for t in total_spin if t > 0), -1: sum(1 for t in total_spin if t < 0)}
      priority_total = np.array([spin_counts.get(1, 0), spin_counts.get(-1, 0)])
      
      priorities[i*N+j][0] -= priority_total[1]
      priorities[i*N+j][1] += priority_total[0]
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.count_nonzero(h[site_nbr][j][k] < 0)
        else:
          priorities[i*N+j*N+k][0] -= np.count_nonzero(h[site_nbr][j][k] > 0)
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  return(priorities)




#score: {'data3D.txt': 0.003175}
#island_id: 1
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  return(np.concatenate([np.sum(total_spin,axis=3),-np.sum(total_spin,axis=3)],axis=1).reshape(N**3,2))




#score: {'data3D.txt': 0.0013173999999999994}
#island_id: 1
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0014245999999999998}
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if h[i][j][k] > 0:
          total_spin[1] += 1
        else:
          total_spin[1] -= 1
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin[0] += sum(J[:,i,j,k])
          else:
            total_spin[0] -= sum(J[:,i,j,k])
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[1] += sum(J[:,i,j,k])
          else:
            total_spin[1] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.0028362}
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum(J[m,:,j,k])
          else:
            total_spin[0] -= sum(J[m,:,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022966000000000006}
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_0 = [0, 0]
        total_spin_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
          if h[i][j][k] == h[site_nbrs[m]][j][k]:
            if h[site_nbrs[m]][j][k] > 0:
              total_spin_0[1] -= J[m,i,j,k]
            else:
              total_spin_0[1] += J[m,i,j,k]
          elif h[i][j][k] > 0 and h[site_nbrs[m]][j][k] < 0:
            total_spin_0[1] -= J[m,i,j,k]
          elif h[i][j][k] < 0 and h[site_nbrs[m]][j][k] > 0:
            total_spin_0[1] += J[m,i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin_0[0] += sum(J[:,i,j,k])
          else:
            total_spin_0[0] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin_0[0], total_spin_1[1]]
  return(priorities)




#score: {'data3D.txt': 0.0448086}
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // (N ** 2)) % N, (i % (N ** 2)) // N, i % N]
    total_spin = [0, 0]
    for k in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] == h[(site_nbrs[0] + ((k % 3) - 1)) % N][site_nbrs[1]][site_nbrs[2]]:
        total_spin[0] += J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[0] -= J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      if h[(site_nbrs[0] + ((k % 3) - 1)) % N][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[1] -= J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[1] += J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
    priorities[i] = [total_spin[0], total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.013435800000000001}
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 1, -1])
        else:
          priorities.append([-total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.03930020000000002}
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 2, -3])
        else:
          priorities.append([-total_spin - 2, 3])
  return(np.array(priorities))




#score: {'data3D.txt': 0.011732199999999998}
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0019562}
#island_id: 2
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]])
          else:
            total_spin[0] -= sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0278966}
#island_id: 2
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for _ in range(3)]
          total_spin[0] += np.sum([J[m,i,j,k] if h[n][j][k] == h[i][j][k] else -J[m,i,j,k] for n in site_nbrs])
          total_spin[1] += np.sum([J[m,i,j,k] if h[n][j][k] != h[i][j][k] else -J[m,i,j,k] for n in site_nbrs])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.034100200000000004}
#island_id: 2
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priority = [total_spin[0] - np.sum(J[:,i,j,k]), -total_spin[1]]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.029593400000000002}
#island_id: 2
#version_generated: 3
#generate time16:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        spin_count = sum([int(h[i][j][k]) for i in range(N) for j in range(N) for k in range(N)])
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0] - spin_count, -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0034062000000000003}
#island_id: 0
#version_generated: 3
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][jj][kk] for jj in range(N) for kk in range(N))
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0198606}
#island_id: 3
#version_generated: 3
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] += 2
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][0] -= J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.017322200000000003}
#island_id: 3
#version_generated: 3
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1

      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][0] -= J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.1158998}
#island_id: 3
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] += 2
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          interacting_spin_counts = [0]*2
          for m in range(3):
            if np.sum(h[site_nbrs[m]]) > 0:
              interacting_spin_counts[0] += 1
              interacting_spin_counts[1] -= 1
            else:
              interacting_spin_counts[0] -= 1
              interacting_spin_counts[1] += 1
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*np.dot(interacting_spin_counts, [1, -2])
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*np.dot(interacting_spin_counts, [-1, 2])
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0051066}
#island_id: 1
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0122874}
#island_id: 1
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,(j+((i-1)%2 - 1)) % N,(k+((j-1)%2 - 1)) % N])
        if h[(i + ((k-1)%2 - 1)) % N][j][k] > 0:
          priorities.append([total_spin + 1, -1])
        else:
          priorities.append([-total_spin + 1, -1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + N**2, -1])
        else:
          priorities.append([-total_spin + N**2, -1])
  return(np.array(priorities))




#score: {'data3D.txt': 0.001118599999999999}
#island_id: 1
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[max(0,i-1):min(i+2,N),max(0,j-1):min(j+2,N),max(0,k-1):min(k+2,N)]))
          priorities[i*N+j*N+k][1] -= 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[max(0,i-1):min(i+2,N),max(0,j-1):min(j+2,N),max(0,k-1):min(k+2,N)]))
          priorities[i*N+j*N+k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': 0.0006769999999999999}
#island_id: 1
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[max(i-1,0):i+3, max(j-1,0):j+3, k]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[max(i-1,0):i+3, max(j-1,0):j+3, k]))
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.008434200000000001}
#island_id: 1
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        
        # Calculate the priority based on the magnetism and interactions
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + total_spin
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - total_spin
          priorities[i*N+j*N+k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4195346000000001}
#island_id: 0
#version_generated: 2
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins = np.array([interacting_spins_x, interacting_spins_y, interacting_spins_z])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[0][i,j,k]
          elif l % 3 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[1][i,j,k]
          else:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[2][i,j,k]
  
  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)




#score: {'data3D.txt': -0.4195346000000001}
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 3 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          else:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
  
  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)




#score: {'data3D.txt': -0.41692540000000006}
#island_id: 0
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 4 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 4 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          elif l % 4 == 2:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
          else:
            if l % 4 == 3:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xy[i,j,k]
            elif l % 4 == 4:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xz[i,j,k]
            else:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_yz[i,j,k]

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)




#score: {'data3D.txt': 0.034988199999999935}
#island_id: 0
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_x[i,j,k] - h[i,j,k])
          elif l % 3 == 1:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_y[i,j,k] - h[i,j,k])
          else:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_z[i,j,k] - h[i,j,k])

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)




#score: {'data3D.txt': -0.04052860000000001}
#island_id: 1
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 4, -5])
        else:
          priorities.append([-total_spin - 4, 5])
  return(np.array(priorities))




#score: {'data3D.txt': -0.3383045999999997}
#island_id: 1
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin + 2, -3])
        else:
          priorities.append([-total_spin - 2, 3])
  return(np.array(priorities))




#score: {'data3D.txt': 0.0428734}
#island_id: 2
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin_1[0] += J[m,i,j,k]
            total_spin_minus_1[0] -= J[m,i,j,k]
        priority = [total_spin_1[0], -total_spin_1[1]]
        if np.prod(total_spin_1) > 0:
          priorities[i][j][k] = priority
        else:
          priorities[i][j][k] = [-priority[0], -priority[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.2712526000000003}
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for _ in range(3)]
          if np.all([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs]):
            total_spin_1[1] -= J[m,i,j,k]
          elif np.any([h[site_nbr][j][k] < 0 for site_nbr in site_nbrs]):
            total_spin_minus_1[1] += J[m,i,j,k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0229374}
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        priority = [total_spin_1[0] - np.sum(J[:,i,j,k]), -total_spin_1[1]] if h[i][j][k] > 0 else [-total_spin_minus_1[0], total_spin_minus_1[1]]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = [total_spin_1[0] + total_spin_1[1], total_spin_minus_1[0] - total_spin_minus_1[1]]
        else:
          priority_total = [-total_spin_1[0] - total_spin_1[1], -total_spin_minus_1[0] + total_spin_minus_1[1]]
        priorities[i][j][k] = priority_total
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.125719}
#island_id: 2
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1)%3) - 1) % N
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = sum([J[m,i,j,k] for m in range(6)]) + total_spin[1]
          priorities[(i*N+j)*N+k, 1] = -total_spin[0]
        else:
          priorities[(i*N+j)*N+k, 0] = -sum([J[m,i,j,k] for m in range(6)]) - total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_spin[0]
  return(priorities)




#score: {'data3D.txt': 0.0636342}
#island_id: 2
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_energy = sum([J[m,i,j,k] for m in range(6)])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -total_energy
  return(priorities)




#score: {'data3D.txt': 0.00017540000000000033}
#island_id: 2
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        priorities[i*N+j*N+k, 0] = -total_spin[1]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k, 1] = total_spin[0] + total_spin[1]
        else:
          priorities[i*N+j*N+k, 1] = -(total_spin[0] + total_spin[1])
  return(priorities)




#score: {'data3D.txt': -0.005784200000000001}
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[0] += 2
          total_spin[1] -= 3
        else:
          total_spin[0] -= 2
          total_spin[1] += 3
      priorities[i*N*N:i*N*N+N**2, 0] = total_spin[0]
      priorities[i*N*N:i*N*N+N**2, 1] = total_spin[1]
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**3):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, (i%N)//N]
    total_spin = [0, 0]
    for k in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][k] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities.append([total_spin[0], -total_spin[1]])
  return np.array(priorities)




#score: {'data3D.txt': -0.00010980000000000057}
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+k, 0] = total_spin[0]
          priorities[i*N*N+k, 1] = -total_spin[1] + np.mean(h[i].flatten())
        else:
          priorities[i*N*N+k, 0] = -total_spin[0]
          priorities[i*N*N+k, 1] = total_spin[1] + np.mean(h[i].flatten())
  return priorities




#score: {'data3D.txt': -0.001757}
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        for l in [0, 1, 2]:
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= 3*total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += 3*total_spin[1]
  return priorities




#score: {'data3D.txt': 0.007909000000000001}
#island_id: 1
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        
        # Calculate the priority based on the magnetism and interactions
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + 1
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - 1
          priorities[i*N+j*N+k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.0040846}
#island_id: 3
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 3
#version_generated: 2
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[(i + ((k-1)%2 - 1)) % N][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.098221}
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        if np.allclose(total_spin, [0, 0]):
          priorities[i][j][k] = [0, 0]
        elif total_spin[0] > total_spin[1]:
          priorities[i][j][k] = [1, 0]
        else:
          priorities[i][j][k] = [0, 1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': 0.0859046}
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        if sum([h[i][l][k] > 0 for l in range(N)]) > N//2:
          total_spin[0] = -sum([h[i][j][k] > 0 for j in range(N)])
        else:
          total_spin[0] = sum([h[i][j][k] > 0 for j in range(N)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.002517}
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbr[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
      priorities[i*N+j] = [total_spin[0], -total_spin[1]]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.002407}
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          total_spin[0] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + total_spin[1], -total_spin[1]]
        else:
          priority = [-total_spin[0] - total_spin[1], total_spin[1]]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0018638000000000007}
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          site_nbr = site_nbrs[m // 2]
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + 1, -total_spin[1] - 1]
        else:
          priority = [-total_spin[0] - 1, total_spin[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0020498000000000005}
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = priority[1]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0025702}
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m, i, j, k]
          else:
            total_spin[0] -= J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] > 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] < 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] > 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.41692540000000006}
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  interacting_spins_xyz = np.roll(np.roll(h, -1, axis=0), -1, axis=1)[:, :, None] * np.roll(h, 1, axis=2)[None, :, :]
  interacting_spins_xzy = np.roll(np.roll(h, -1, axis=0), 1, axis=2)[:, None, :] * np.roll(h, -1, axis=1)[None, :, :]
  interacting_spins_yxz = np.roll(np.roll(h, -1, axis=1), -1, axis=0)[None, :, :] * np.roll(h, 1, axis=2)[None, :, :]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 4 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 4 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          elif l % 4 == 2:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
          else:
            if l % 4 == 3:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xy[i,j,k]
            elif l % 4 == 4:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xz[i,j,k]
            else:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_yz[i,j,k]

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)




#score: {'data3D.txt': -0.0037614000000000002}
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0014729999999999997}
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0015286}
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin_1[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin_minus_1[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin_minus_1[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0023898}
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs_x = [(i + ((m % 3) - 1)) % N for m in range(6)]
        site_nbrs_yz = [(j + ((m // 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs_x[m//2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if h[i][site_nbrs_yz[m%3]][k] > 0:
            total_spin[0] -= J[m, i, j, k]
          else:
            total_spin[0] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + 1, -total_spin[1] - 1]
        else:
          priority = [-total_spin[0] - 1, total_spin[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0014729999999999997}
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m//2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': 0.0636342}
#island_id: 2
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k, 0] = -total_spin[1]
          priorities[i*N**2 + j*N + k, 1] = sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i*N**2 + j*N + k, 0] = -(-total_spin[1])
          priorities[i*N**2 + j*N + k, 1] = -sum([J[l, i, j, k] for l in range(6)])
  return(priorities)




#score: {'data3D.txt': 0.0636342}
#island_id: 2
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_energy = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -total_energy
  return(priorities)




#score: {'data3D.txt': 0.0439306}
#island_id: 2
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr_energy = sum([J[l, i, j, k] for l in range(6) if h[i][j][k] == h[site_nbrs[l]][j][k]])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = site_nbr_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -site_nbr_energy
  return(priorities)




#score: {'data3D.txt': 0.005573000000000001}
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0095574}
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0018969999999999998}
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,i,site_nbr,k]) + h[i][site_nbr][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[i][site_nbr][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  total_spin = np.zeros((N,N,N))
  for k in range(N):
    site_nbr = (k + ((k-1)%2 - 1)) % N
    for j in range(N):
      for i in range(N):
        total_spin[i][j] += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0053774}
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        for l in range(3):
          site = (i + ((l-1)%2 - 1)) % N
          if J[l, i, j, k] > 0:
            total_spin += h[site][j]
          else:
            total_spin -= h[site][j]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0014729999999999997}
#island_id: 2
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = np.sum(np.array([priority[0], priority[1]]))
  return(priorities)




#score: {'data3D.txt': -0.0023662}
#island_id: 2
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if sum(total_spin_1) + h[i][j][k] > 0:
          priority = [sum(total_spin_1) + 1, -sum(total_spin_minus_1) - 1]
        else:
          priority = [-sum(total_spin_minus_1) - 1, sum(total_spin_1) + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0025417999999999994}
#island_id: 2
#version_generated: 3
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        for m in range(6):
          if h[i][site_nbrs[m // 2]][k] > 0:
            total_spin_1[0] -= J[m, i, site_nbrs[m // 2], k]
          else:
            total_spin_minus_1[0] += J[m, i, site_nbrs[m // 2], k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.002445400000000001}
#island_id: 3
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      if total_spin > 0:
        priorities[i][0] += -1
        priorities[i][1] -= 1
      elif total_spin < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.0012197999999999996}
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4
  return(priorities)




#score: {'data3D.txt': -0.0023002}
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          total_spin += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities.append([total_spin, -1])
        else:
          total_spin -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities.append([-total_spin, 1])
  return(np.array(priorities))




#score: {'data3D.txt': -0.11218379999999999}
#island_id: 2
#version_generated: 3
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin[1] += J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
          else:
            total_spin[1] -= J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
          else:
            total_spin[0] -= J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
        priority_total = [total_spin[0], -total_spin[1]]
        priorities[i][j][k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.0015286}
#island_id: 2
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin_1[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin_minus_1[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin_minus_1[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0020142000000000003}
#island_id: 2
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0020142000000000003}
#island_id: 2
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= 3*total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += 3*total_spin[1]
  return priorities




#score: {'data3D.txt': -0.0024006000000000006}
#island_id: 2
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m % 3]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[m, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]])
          else:
            total_spin[0] -= sum([J[m, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])
        if h[i][j][k] > 0:
          priority = [total_spin[0] + total_spin[1], -total_spin[0]]
        else:
          priority = [-total_spin[0], total_spin[0] + total_spin[1]]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0014698000000000003}
#island_id: 2
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        priority = [total_spin[0], -total_spin[1]]
        if h[i][j][k] > 0:
          priorities[i*N+j+k] = [priority[0] + 1, -(priority[1] + 1)]
        else:
          priorities[i*N+j+k] = [-priority[0] - 1, priority[1] + 1]
  return(priorities)




#score: {'data3D.txt': -0.001563}
#island_id: 2
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          site_nbr = site_nbrs[m // 2]
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]]), 
                 -total_spin[1] - sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])]
        else:
          priority = [-total_spin[0] - sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]]), 
                 total_spin[1] + sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)




#score: {'data3D.txt': -0.0019866000000000003}
#island_id: 3
#version_generated: 3
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if any(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0036690000000000004}
#island_id: 3
#version_generated: 3
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.005709400000000001}
#island_id: 2
#version_generated: 3
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs])
        total_spin_zeros = 5 - total_spin_ones
        priority_total = [total_spin_zeros, total_spin_ones]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i*N+j*N+k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))




#score: {'data3D.txt': -0.16672620000000024}
#island_id: 2
#version_generated: 3
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbrs[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        if h[i][j][k] > 0:
          priority_total = [total_spin_zeros, total_spin_ones]
        else:
          priority_total = [-total_spin_zeros, -total_spin_ones]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[(i*N+j)*N+k] = [priority_total[0], priority_total[1]]
  return(priorities.astype(int))




#score: {'data3D.txt': -0.1073042}
#island_id: 2
#version_generated: 3
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbrs[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        site_nbr_sum = sum([J[l,i,j,k] * (2*h[i][l][k]-1) for l in range(6)])
        priorities[(i*N+j)*N+k] = [total_spin_zeros + site_nbr_sum, -total_spin_ones]
  return(priorities)




#score: {'data3D.txt': -0.002445400000000001}
#island_id: 3
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
    else:
      if total_spin > N**3/2:
        priorities[i][1] -= 1
      elif total_spin < -N**3/2:
        priorities[i][0] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0022646000000000003}
#island_id: 3
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0038998000000000006}
#island_id: 1
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          if J[0, site_nbr, j, k] > 0:
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][1] += 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          if J[0, site_nbr, j, k] > 0:
            priorities[i*N+j*N+k][1] += 4
          else:
            priorities[i*N+j*N+k][1] -= 4
  return(priorities)




#score: {'data3D.txt': 0.004780200000000001}
#island_id: 1
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
  return(priorities)




#score: {'data3D.txt': 0.003477}
#island_id: 1
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4
          site_nbr = (j + ((k-1)%2 - 1)) % N
          total_spin += sum(J[:,site_nbr,i,k]) + h[site_nbr][i][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4
          site_nbr = (j + ((k-1)%2 - 1)) % N
          total_spin = sum(J[:,site_nbr,i,k]) + h[site_nbr][i][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
  return(priorities)




#score: {'data3D.txt': 0.0012197999999999996}
#island_id: 1
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4
  return(priorities)




#score: {'data3D.txt': 0.0034509999999999996}
#island_id: 1
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] -= 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] += 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
  return(priorities)




#score: {'data3D.txt': -0.004623399999999999}
#island_id: 1
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += 3*total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= 3*total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
  return priorities




#score: {'data3D.txt': -0.0025702}
#island_id: 2
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0023790000000000005}
#island_id: 2
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, (j + ((m // 3) % 2 - 1)) % N, (k + ((m // 1) % 2 - 1)) % N]
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0025106}
#island_id: 2
#version_generated: 3
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          total_spin[0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022409999999999995}
#island_id: 2
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022409999999999995}
#island_id: 2
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.04480420000000002}
#island_id: 1
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(6):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin[0] + 4 * (h[i].flatten().sum() + h[j].flatten().sum() + h[k].flatten().sum()), -5])
        else:
          priorities.append([-total_spin[0] - 4 * (h[i].flatten().sum() + h[j].flatten().sum() + h[k].flatten().sum()), 5])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0346446}
#island_id: 1
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin[0] + np.mean(h[i].flatten()), -total_spin[1]])
        else:
          priorities.append([-total_spin[0] + np.mean(h[i].flatten()), total_spin[1]])
  return(np.array(priorities))




#score: {'data3D.txt': -0.0040846}
#island_id: 3
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0038401999999999998}
#island_id: 3
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        else:
          priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0031982000000000004}
#island_id: 3
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] += len([m for m in site_magnetisms if m < 0])
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms)
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms)

  return(priorities)




#score: {'data3D.txt': -0.0026246000000000004}
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.002271000000000001}
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        total_spin[0] += h[i][j][k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0025354}
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] if h[site_nbrs[m]][j][k] > 0 else -h[site_nbrs[m]][j][k])
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.002603400000000001}
#island_id: 2
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0032094000000000003}
#island_id: 2
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] += J[m,i,j,k]
          else:
            total_spin[1] -= J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0016273999999999998}
#island_id: 2
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[1], -total_spin[0]]
  return(priorities)




#score: {'data3D.txt': -0.0059162}
#island_id: 1
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*N+k][1] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
        else:
          total_spin[i*N+j*N+k][1] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
  return(total_spin)




#score: {'data3D.txt': 0.0013173999999999994}
#island_id: 1
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for d in range(3):
    for i in range(1,N):
      interacting_spins[d] = np.where(np.arange(N) == (i + ((np.arange(N) - 1) % 2 - 1)) % N, h, interacting_spins[d])
      interacting_spins[3+d] = np.where(np.arange(N) == (i - ((np.arange(N) - 1) % 2 - 1)) % N, h, interacting_spins[3+d])
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.3049978000000001}
#island_id: 1
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(np.abs(interacting_spins[0,i,j,k])) + \
                      np.sum(np.abs(interacting_spins[3,i,j,k]))
          total_spin[i][j][k][1] -= 2
        else:
          total_spin[i][j][k][0] -= np.sum(np.abs(interacting_spins[0,i,j,k])) + \
                      np.sum(np.abs(interacting_spins[3,i,j,k]))
          total_spin[i][j][k][1] += 2
  
  return(total_spin.flatten().reshape(N**3,2))




#score: {'data3D.txt': -0.002445400000000001}
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0001225999999999998}
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += -1 * len([m for m in site_magnetisms if m < 0])
  return(priorities)




#score: {'data3D.txt': -0.002445400000000001}
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][1] += -sum(1 for _ in site_magnetisms if _ > 0)
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= sum(1 for _ in site_magnetisms if _ < 0)
    else:
      if total_spin > 0:
        priorities[i][1] += -sum(1 for _ in site_magnetisms if _ > 0)
      elif total_spin < 0:
        priorities[i][0] -= sum(1 for _ in site_magnetisms if _ < 0)

  return(priorities)




#score: {'data3D.txt': -0.20221180000000022}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
        if h[site_nbr_x][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[0,i,j,k]
        
        if h[i][site_nbr_y][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[1,i,j,k]
        
        if h[i][j][site_nbr_z] > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[2,i,j,k]
        
  return(priorities)




#score: {'data3D.txt': -0.001835}
#island_id: 2
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)

  site_interactions = []
  for k in range(N):
    site_interactions.append([])
    for j in range(N):
      site_interactions[k].append([])
      for i in range(N):
        total_spin = [0, 0]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -J[m,i,j,k]*interacting_spins[m,i,j,k]
        site_interactions[k][j].append(total_spin)
  for k in range(N):
    for j in range(N):
      priorities[k*N+j] = [np.prod([x[0] for x in site_interactions[k][j]]), np.prod([x[1] for x in site_interactions[k][j]])]
  return(priorities)




#score: {'data3D.txt': -0.0027434000000000004}
#island_id: 2
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0025106}
#island_id: 2
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          total_spin[0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0018174000000000005}
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022321999999999997}
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[l]][j][k]):
            if h[i][j][k] > 0:
              total_spin[0] -= J[l,i,j,k]
            else:
              total_spin[0] += J[l,i,j,k]
          else:
            if h[i][j][k] > 0:
              total_spin[0] += J[l,i,j,k]
            else:
              total_spin[0] -= J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0008797999999999999}
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          site = site_nbrs[l]
          if abs(h[i][j][k]) == abs(h[site][j][k]):
            total_spin[0] += 2*J[l,i,j,k]
          elif h[i][j][k] * h[site][j][k] > 0:
            total_spin[0] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.20221180000000022}
#island_id: 0
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
        if h[site_nbr_x][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[0,i,j,k]
        
        if h[i][site_nbr_y][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[1,i,j,k]
        
        if h[i][j][site_nbr_z] > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[2,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0022534000000000005}
#island_id: 2
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0025434}
#island_id: 2
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 + total_spin[0]
          priorities[i*N+j+k%N][1] = -2 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022534000000000005}
#island_id: 2
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017062000000000004}
#island_id: 2
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priorities[i*N+j+k%N][0] = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][1] = -np.sum([x if h[i][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)




#score: {'data3D.txt': -0.0006694000000000004}
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - total_spin
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + total_spin
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -6.26000000000006e-05}
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(J[:,(i + (k%2 - 1)) % N,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(J[:,(i + (k%2 - 1)) % N,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.00010980000000000057}
#island_id: 1
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs.append([(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N])
          total_spin[0] += J[l, site_nbrs[l][0], site_nbrs[l][1], site_nbrs[l][2]]
          total_spin[1] -= J[l, site_nbrs[l][0], site_nbrs[l][1], site_nbrs[l][2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+k, 0] = total_spin[0]
          priorities[i*N*N+k, 1] = -total_spin[1] + np.mean(h[i].flatten())
        else:
          priorities[i*N*N+k, 0] = -total_spin[0]
          priorities[i*N*N+k, 1] = total_spin[1] + np.mean(h[i].flatten())
  return priorities




#score: {'data3D.txt': -0.0015778}
#island_id: 1
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        J_sum = sum(J[:,site_nbrs[0], site_nbrs[1], site_nbrs[2]])
        h_val = h[i][j][k]
        if h_val > 0:
          priorities[i*N*N+k, 0] = J_sum + np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N*N+k, 1] = -J_sum + h_val
        else:
          priorities[i*N*N+k, 0] = -J_sum - np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) + np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N*N+k, 1] = J_sum - h_val
  return priorities




#score: {'data3D.txt': 0.0034509999999999996}
#island_id: 1
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] -= 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] += 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
  return(priorities)




#score: {'data3D.txt': -0.0105946}
#island_id: 1
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] -= 4 + (total_spin > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] += 4 + (total_spin > 0)
  return(priorities)




#score: {'data3D.txt': -0.0022534000000000005}
#island_id: 2
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + sum(interacting_spins)
          priorities[i*N+j+k%N][1] -= 1 - sum(total_spin[1:])
        else:
          priorities[i*N+j+k%N][0] -= 1 + sum(interacting_spins)
          priorities[i*N+j+k%N][1] = -1 + sum(total_spin[1:])
  return(priorities)




#score: {'data3D.txt': -0.0024482}
#island_id: 2
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 * total_spin[0]
          priorities[i*N+j+k%N][1] = -2 * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.005795399999999999}
#island_id: 3
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022646000000000003}
#island_id: 3
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0016385999999999998}
#island_id: 2
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += sum(total_spin[0] for _ in range(6))
          priorities[i*N+j+k%N][1] -= sum(total_spin[1] for _ in range(6))
        else:
          priorities[i*N+j+k%N][0] -= sum(total_spin[0] for _ in range(6))
          priorities[i*N+j+k%N][1] = -sum(total_spin[1] for _ in range(6))
  return(priorities)




#score: {'data3D.txt': -0.0018797999999999994}
#island_id: 2
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        magnetism = h[i][j][k]
        for m in range(6):
          total_spin[0] += J[m,i,j,k] * (h[site_nbrs[m]][j][k] > 0)
          total_spin[1] -= J[m,i,j,k] * (h[site_nbrs[m]][j][k] < 0)
        if magnetism > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0016385999999999998}
#island_id: 2
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0013794000000000002}
#island_id: 2
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.07869580000000002}
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[site_nbr_x][j][k]
        for x in range(3):
          if J[x, i, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if J[y, i, site_nbr_y, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if J[z, site_nbr_x, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.33024339999999974}
#island_id: 0
#version_generated: 3
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][j][0]
      if h[i][j][0] > 0:
        priorities[i*N*N+j][0] += 1
        priorities[i*N*N+j][1] -= 1
      else:
        priorities[i*N*N+j][0] -= 1
        priorities[i*N*N+j][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0001225999999999998}
#island_id: 3
#version_generated: 3
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] = sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms)
  return(priorities)




#score: {'data3D.txt': -0.0001225999999999998}
#island_id: 3
#version_generated: 3
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      spin = -1 if sum(m for m in site_magnetisms) > 0 else 1
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += np.sum(total_spin)
          priorities[i*N*N + j + k, 1] -= np.prod(np.array([3, 1])) * total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= np.sum(total_spin)
          priorities[i*N*N + j + k, 1] += np.prod(np.array([3, 1])) * total_spin[1]
  return priorities




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)




#score: {'data3D.txt': 0.0019558}
#island_id: 1
#version_generated: 3
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          priorities[i*N*N + j + k, 0] += J[l, site_nbr, j, k]
          priorities[i*N*N + j + k, 1] -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin
          priorities[i*N*N + j + k, 1] -= total_spin * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin
          priorities[i*N*N + j + k, 1] += total_spin * 3
  return priorities




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)




#score: {'data3D.txt': -0.005795399999999999}
#island_id: 3
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum([h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs])
    
    if all(m > 0 for m in [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]):
      priorities[k][0] -= 1
      priorities[k][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.005795399999999999}
#island_id: 3
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.012296600000000001}
#island_id: 0
#version_generated: 3
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        magnetism = h[i][j][k]

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

        total_spin = 0

        for x in range(N):
          if h[x][j][k] > 0:
            total_spin += J[0, i, j, k]
          else:
            total_spin -= J[0, i, j, k]

        for y in range(N):
          if h[i][y][k] > 0:
            total_spin += J[1, i, j, k]
          else:
            total_spin -= J[1, i, j, k]

        for z in range(N):
          if h[i][j][z] > 0:
            total_spin += J[2, i, j, k]
          else:
            total_spin -= J[2, i, j, k]

        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0041618}
#island_id: 3
#version_generated: 3
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += len([m for m in site_magnetisms if m < 0])
        else:
          site_spin = sum(m > 0 for m in site_magnetisms) - sum(m < 0 for m in site_magnetisms)
          priorities[i*N+j+k][0] -= site_spin
          priorities[i*N+j+k][1] += abs(site_spin)
  return(priorities)




#score: {'data3D.txt': -0.0027174000000000005}
#island_id: 3
#version_generated: 3
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1 + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] = -1 - total_spin
        else:
          if any(m > 0 for m in site_magnetisms):
            priorities[i*N+j+k][0] += -1 + (len([m for m in site_magnetisms if m > 0]))
            priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
          else:
            priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
            priorities[i*N+j+k][1] += 1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0032998000000000003}
#island_id: 3
#version_generated: 3
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        else:
          priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
  return(priorities)




#score: {'data3D.txt': -0.0028774}
#island_id: 3
#version_generated: 3
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in range(6)]])
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        for p in range(6):
          site_nbr = (i + ((p-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k][0] -= total_spin
            priorities[i*N+j+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.07869580000000002}
#island_id: 0
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority_x = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority_x
        priorities[i*N*N+j*N+k][1] = priority_x
        
  return(priorities)




#score: {'data3D.txt': -0.07869580000000002}
#island_id: 0
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priority = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.24526700000000007}
#island_id: 0
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        for x in range(3):
          if J[x, i, j, k] > 0:
            site_interactions[i][j][k] += 1
          else:
            site_interactions[i][j][k] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.0001225999999999998}
#island_id: 3
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms)

  return(priorities)




#score: {'data3D.txt': -0.0030110000000000002}
#island_id: 3
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] = -sum(m for m in site_magnetisms)
      priorities[i][1] = sum(m for m in site_magnetisms)

  return(priorities)




#score: {'data3D.txt': -0.0001225999999999998}
#island_id: 3
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      total_spin = sum((site_magnetisms[j-1] + site_magnetisms[(j+1)%6]) / 2.0 for j in range(6))
      priorities[i][0] += -total_spin
      priorities[i][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = np.zeros((N, N, N, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        magnetism = h[i][j][k]
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        if magnetism > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] = total_spin[i][j][k][0]
        priorities[i*N*N+j*N+k][1] = -total_spin[i][j][k][1]

  return(priorities)




#score: {'data3D.txt': -0.34395820000000016}
#island_id: 0
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        magnetism = h[i][j][k]

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[0, x, j, k] for x in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[0, x, j, k] for x in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[0, x, j, k] for x in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[0, x, j, k] for x in range(N))

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[1, i, y, k] for y in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[1, i, y, k] for y in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[1, i, y, k] for y in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[1, i, y, k] for y in range(N))

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[2, i, j, z] for z in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[2, i, j, z] for z in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[2, i, j, z] for z in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[2, i, j, z] for z in range(N))

  return(priorities)




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][i][k] > 0:
        priorities[i*N*N + j + k, 0] += total_spin[0]
        priorities[i*N*N + j + k, 1] -= total_spin[1]
      else:
        priorities[i*N*N + j + k, 0] -= total_spin[0]
        priorities[i*N*N + j + k, 1] += total_spin[1]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[i][j][site_nbr] > 0:
        priorities[i*N*N + j + k, 0] += total_spin[0]
        priorities[i*N*N + j + k, 1] -= total_spin[1]
      else:
        priorities[i*N*N + j + k, 0] -= total_spin[0]
        priorities[i*N*N + j + k, 1] += total_spin[1]

  return priorities




#score: {'data3D.txt': -0.0013142}
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)




#score: {'data3D.txt': -0.24526700000000007}
#island_id: 0
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        for x in range(3):
          if J[x, i, j, k] > 0:
            site_interactions[i][j][k] += 1
          else:
            site_interactions[i][j][k] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': 0.0548146}
#island_id: 0
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for x in range(3):
          if J[x, i, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if J[y, i, (j+1)%N, k] > 0:
            total_spin += 1
          elif J[y, i, j, k] <= 0 and J[y, i, (j+1)%N, k] < 0:
            total_spin -= 2
          else:
            total_spin += 1
        for z in range(3):
          if J[z, (i+1)%N, j, k] > 0:
            total_spin += 1
          elif J[z, i, j, k] <= 0 and J[z, (i+1)%N, j, k] < 0:
            total_spin -= 2
          else:
            total_spin += 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.24526700000000007}
#island_id: 0
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        for x in range(3):
          if J[x, i, j, k] > 0:
            site_interactions[i][j][k] += 1
          else:
            site_interactions[i][j][k] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.1011122}
#island_id: 0
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.1011122}
#island_id: 0
#version_generated: 3
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.1011122}
#island_id: 0
#version_generated: 3
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.1011122}
#island_id: 0
#version_generated: 3
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.1011122}
#island_id: 0
#version_generated: 3
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)




#score: {'data3D.txt': -0.0025310000000000007}
#island_id: 2
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        for m in range(6):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  # Calculate priorities along each axis
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)




#score: {'data3D.txt': -0.0022497999999999997}
#island_id: 2
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0]
            priorities[i*N+j+k%N][1] -= total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0]
            priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002426600000000001}
#island_id: 2
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0025578000000000003}
#island_id: 2
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
          priorities[i*N+j+k%N][0] = total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
          priorities[i*N+j+k%N][0] = -total_spin[0]
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0024482}
#island_id: 2
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate priorities along each axis
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m, i, j, k]
            else:
              total_spin[1] += J[m, i, j, k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0022078000000000006}
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate priorities along each axis
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)




#score: {'data3D.txt': -0.004795400000000001}
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        for l in range(3):
          site = (i + ((l-1)%2 - 1)) % N
          if J[l, i, j, k] > 0:
            total_spin += h[site][j]
          else:
            total_spin -= h[site][j]
        for l in range(6):
          if J[l, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]:
          total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i*N*N + j*N + k
        total_spin[site_nbr][0] += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin[site_nbr][0] += 1
          total_spin[site_nbr][1] -= 1
        else:
          total_spin[site_nbr][0] -= 1
          total_spin[site_nbr][1] += 1
        
  # assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i*N*N + j*N + k
        if h[i][j][k] > 0:
          priorities[site_nbr][0] = total_spin[site_nbr][0]
          priorities[site_nbr][1] = -total_spin[site_nbr][0]
        else:
          priorities[site_nbr][0] = -total_spin[site_nbr][0]
          priorities[site_nbr][1] = total_spin[site_nbr][0]
        
  return priorities




#score: {'data3D.txt': -0.0029902}
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * (len([m for m in site_magnetisms if m > 0]) + total_spin)
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * (len([m for m in site_magnetisms if m < 0]) + total_spin)
          priorities[i*N+j+k][1] = -1 - len([m for m in site_magnetisms if m < 0]) - total_spin
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms) + total_spin
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms) - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0032974000000000002}
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
        else:
          if any(m > 0 for m in site_magnetisms):
            priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
            priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
          else:
            priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
            priorities[i*N+j+k][1] = -1 * (len([m for m in site_magnetisms if m < 0]) - 1) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0029006}
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms)
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0023334000000000002}
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0016506000000000001}
#island_id: 2
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)




#score: {'data3D.txt': -0.0015374}
#island_id: 2
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum
        priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum)
  return(priorities)




#score: {'data3D.txt': -0.002399000000000001}
#island_id: 2
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][0] = priority
        priorities[i*N+j+k%N][1] = -priority
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': 0.0194198}
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs)
          priorities[i*N**2 + j*N + k][1] -= len(site_nbrs)
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs)
          priorities[i*N**2 + j*N + k][1] += len(site_nbrs)
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.21795620000000032}
#island_id: 1
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.001998600000000001}
#island_id: 1
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
      for k in range(N):
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin += h[i][site_nbr_y][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.005795399999999999}
#island_id: 3
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.001998600000000001}
#island_id: 1
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.001998600000000001}
#island_id: 1
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = (J[:, i, j, k].sum() - total_spin)
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -(J[:, i, j, k].sum() - total_spin)
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  return priorities




#score: {'data3D.txt': 0.001998600000000001}
#island_id: 1
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([h[site_nbr][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  return priorities




#score: {'data3D.txt': 0.001998600000000001}
#island_id: 1
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.22429860000000038}
#island_id: 1
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
      
      site_nbr_y = (j + ((k-1)%2 - 1)) % N
      total_spin += h[i][site_nbr_y][k]
      if h[i][j][k] > 0:
        priorities[i*N**2 + j*N + k][0] += 1
        priorities[i*N**2 + j*N + k][1] -= 1
      else:
        priorities[i*N**2 + j*N + k][0] -= 1
        priorities[i*N**2 + j*N + k][1] += 1
      
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr_z = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        total_spin += h[site_nbr_z][k][i]
        if h[i][k][j] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
      
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in [i-1, i+1]:
          if 0 <= l < N:
            site_nbr_x = (l + ((k-1)%2 - 1)) % N
            total_spin += h[site_nbr_x][j]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
            
        for l in [j-1, j+1]:
          if 0 <= l < N:
            site_nbr_y = (i + ((l-1)%2 - 1)) % N
            total_spin += h[i][site_nbr_y][k]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
        
        for l in [k-1, k+1]:
          if 0 <= l < N:
            site_nbr_z = (i + ((j-1)%2 - 1)) % N
            total_spin += h[site_nbr_z][l]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0029753999999999996}
#island_id: 2
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += sum([abs(t) for t in total_spin])
          priorities[i*N+j+k%N][1] -= sum([-t for t in total_spin])
        else:
          priorities[i*N+j+k%N][0] -= sum([abs(t) for t in total_spin])
          priorities[i*N+j+k%N][1] = -sum([-t for t in total_spin])
  return(priorities)




#score: {'data3D.txt': -0.0024482}
#island_id: 2
#version_generated: 3
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 * total_spin[0]
          priorities[i*N+j+k%N][1] = -2 * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0028618000000000003}
#island_id: 2
#version_generated: 3
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(J[m,i,j,k] for m in range(6))
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(J[m,i,j,k] for m in range(6))
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002906600000000001}
#island_id: 2
#version_generated: 3
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.004173}
#island_id: 3
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      site_spin = sum(m > 0 for m in site_magnetisms) - sum(m < 0 for m in site_magnetisms)
      priorities[i][0] -= site_spin
      priorities[i][1] += abs(site_spin)
  return(priorities)




#score: {'data3D.txt': 0.006669400000000001}
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    if all(m > 0 for m in interacting_spin_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in interacting_spin_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0025198000000000004}
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1 * (sum(1 for _ in site_magnetisms) + total_spin)
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0031289999999999985}
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if any(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.002441000000000001}
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0]) + total_spin
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += -1 * len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms) + total_spin
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2080138000000003}
#island_id: 1
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in [-1, 0, 1]:
          site_nbr_x = (i + x) % N
          if h[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [-1, 0, 1]:
          site_nbr_y = (j + y) % N
          if h[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [-1, 0, 1]:
          site_nbr_z = (i + z) % N
          if h[site_nbr_z][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr_x = (i + ((j-1)%2 - 1)) % N
      site_nbr_y = (j + ((k-1)%2 - 1)) % N
      site_nbr_z = (i + ((k-1)%2 - 1)) % N
      
      for k in range(N):
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0034342}
#island_id: 2
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []
        
        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)
          
          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)
          
          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)
        
        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])
        
        priorities[i*N+j+k%N] = [priority_x, -priority_y]
  
  return(priorities)




#score: {'data3D.txt': -0.0018502}
#island_id: 2
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          interacting_spins = []
          
          for l in range(6):
            if h[site_nbrs[l]][j][k] > 0:
              interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
              total_spin[1] -= interacting_spin
            else:
              interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
              total_spin[0] += interacting_spin
            
            if h[i][j][k] > 0:
              priority_total = [total_spin[0] + 1, -total_spin[1] - 1]
            else:
              priority_total = [-total_spin[0] - 1, total_spin[1] + 1]
            
            priorities[i*N+j+k%N] = priority_total
  
  return(priorities)




#score: {'data3D.txt': -0.0019285999999999997}
#island_id: 2
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priority = np.sum([x if h[i][j][k] > 0 else -x for x in total_spin])
        priorities[i*N+j+k%N][0] = priority
        priorities[i*N+j+k%N][1] = -priority
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin += h[i][site_nbr_y][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr_z][k][i]
        if h[i][k][j] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.021464199999999982}
#island_id: 1
#version_generated: 3
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr_x][j][k]
        priorities[i*N**2 + j*N + k][0] += np.sign(total_spin)
        priorities[i*N**2 + j*N + k][1] -= np.sign(total_spin)
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin = h[i][site_nbr_y][k]
        priorities[i*N**2 + j*N + k][0] += np.sign(total_spin)
        priorities[i*N**2 + j*N + k][1] -= np.sign(total_spin)
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr_z][k][i]
        priorities[i*N**3:(i+1)*N**3+j].T[0] += np.sign(total_spin)
        priorities[i*N**3:(i+1)*N**3+j].T[1] -= np.sign(total_spin)
        
  return priorities




#score: {'data3D.txt': -0.17237619999999995}
#island_id: 1
#version_generated: 3
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0024550000000000006}
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        priority_total = total_spin[0]
        for m in range(6):
          if h[i][j][k] > 0:
            priority_total += J[m,i,j,k] * (h[site_nbrs[m]][j][k] > 0)
          else:
            priority_total -= J[m,i,j,k] * (1 - (h[site_nbrs[m]][j][k] > 0))
        priorities[i*N+j+k%N][0] = priority_total
        priorities[i*N+j+k%N][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.002603400000000001}
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(-2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1))
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        total_spin[0] += sum(interacting_spins)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0017518000000000002}
#island_id: 2
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': 0.0046226}
#island_id: 3
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    # Sort the interacting spins based on their magnetism
    sorted_spin_magnetisms = sorted(zip(interacting_spin_magnetisms, range(len(interacting_spin_magnetisms))), key=lambda x: abs(x[0]))
    
    for site_nbr, _ in sorted_spin_magnetisms:
      if site_nbr > 0:
        priorities[k][0] += -1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.006184599999999999}
#island_id: 3
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    if all(m > 0 for m in interacting_spin_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1 + (len([m for m in interacting_spin_magnetisms if m > 0]))
    elif any(m < 0 for m in interacting_spin_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] = 1 - total_spin
    else:
      if any(m > 0 for m in interacting_spin_magnetisms):
        priorities[k][0] += -1 + (len([m for m in interacting_spin_magnetisms if m > 0]))
        priorities[k][1] -= len([m for m in interacting_spin_magnetisms if m > 0]) - total_spin
      else:
        priorities[k][0] -= len([m for m in interacting_spin_magnetisms if m < 0])
        priorities[k][1] += 1 + total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0161782}
#island_id: 3
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    magnetisms = [h[site_nbr][k%N][k//N%N] if J[0, k%N, k//N%N, k//((N*N))] > 0 else -h[site_nbr][k%N][k//N%N] for site_nbr in site_nbrs]
    total_spin = sum(magnetisms)
    
    if all(m > 0 for m in magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1 + total_spin
    elif any(m < 0 for m in magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] = -1 - total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.17237619999999995}
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.004119800000000001}
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [0., 0.]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for x in range(2):
          for y in range(2):
            for z in range(2):
              site_nbr_x = (i + ((k-1)%2 - 1)) % N
              site_nbr_y = (j + ((x-1)%2 - 1)) % N
              site_nbr_z = (i + ((y-1)%2 - 1)) % N
              
              total_spin[0] += h[site_nbr_x][site_nbr_y][site_nbr_z]
              if h[site_nbr_x][site_nbr_y][site_nbr_z] > 0:
                total_spin[1] -= 1
              else:
                total_spin[1] += 1
        
        if total_spin[0] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': 0.0005897999999999993}
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # Calculate total magnetism at each site and its neighbors
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin[i*N**2 + j*N + k][0] += h[site_nbr_x][j][k]
        total_spin[i*N**2 + j*N + k][0] += h[i][site_nbr_y][k]
        total_spin[i*N**2 + j*N + k][0] += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          total_spin[i*N**2 + j*N + k][1] -= 1
        else:
          total_spin[i*N**2 + j*N + k][1] += 1
        
  # Assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin[i*N**2 + j*N + k][0]
          priorities[i*N**2 + j*N + k][1] = -total_spin[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin[i*N**2 + j*N + k][0]
          priorities[i*N**2 + j*N + k][1] = total_spin[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        total_spin[site_nbr][0] += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin[site_nbr][0] += 1
          total_spin[site_nbr][1] -= 1
        else:
          total_spin[site_nbr][0] -= 1
          total_spin[site_nbr][1] += 1
  
  # assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        if h[i][j][k] > 0:
          priorities[site_nbr][0] += total_spin[site_nbr][0]
          priorities[site_nbr][1] -= total_spin[site_nbr][0]
        else:
          priorities[site_nbr][0] -= total_spin[site_nbr][0]
          priorities[site_nbr][1] = -total_spin[site_nbr][0]
  
  return priorities




#score: {'data3D.txt': -0.1929298000000003}
#island_id: 1
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] -= np.sum([J[l, i, j, k] for l in [1, 4]])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] += np.sum([J[l, i, j, k] for l in [1, 4]])
  
  return priorities




#score: {'data3D.txt': -0.0020873999999999997}
#island_id: 2
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0020874}
#island_id: 2
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_center = (i, j, k)
        for dir in [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]:
          site = tuple(a + b for a, b in zip(site_center, dir))
          if 0 <= site[0] < N and 0 <= site[1] < N and 0 <= site[2] < N:
            total_spin[0] += J[3,i,j,k]
            total_spin[1] -= J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017938000000000006}
#island_id: 2
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += (2*h[site_nbrs[m]][j][k] - 1) * J[m,i,j,k]
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin[0] + J[5,i,j,k]
          priorities[i*N+j+k%N][1] = -total_spin[1] - J[5,i,j,k]
        else:
          priorities[i*N+j+k%N][0] = total_spin[0] - J[5,i,j,k]
          priorities[i*N+j+k%N][1] = -total_spin[1] + J[5,i,j,k]
  return(priorities)




#score: {'data3D.txt': -0.0008041999999999999}
#island_id: 0
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        if J[1,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[1,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        if J[2,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[2,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.32622659999999987}
#island_id: 1
#version_generated: 3
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      total_spin = np.zeros(2)
      site_nbr_x = (i + ((N-1)%2 - 1)) % N
      site_nbr_y = (j + ((N-1)%2 - 1)) % N
      
      total_spin[0] += h[i][site_nbr_y][0]
      total_spin[0] += h[site_nbr_x][j][0]
      
      if h[i][j][0] > 0:
        priorities[i*N**2 + j*N][0] += total_spin[0]
        priorities[i*N**2 + j*N][1] -= total_spin[0]
      else:
        priorities[i*N**2 + j*N][0] -= total_spin[0]
        priorities[i*N**2 + j*N][1] += total_spin[0]
  
  return priorities




#score: {'data3D.txt': 0.16642819999999994}
#island_id: 1
#version_generated: 3
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.0161782}
#island_id: 3
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    magnetisms = [h[site_nbr][k%N][k//N%N] if J[0, k%N, k//N%N, k//((N*N))] > 0 else -h[site_nbr][k%N][k//N%N] for site_nbr in site_nbrs]
    total_spin = sum(magnetisms)
    
    if all(m > 0 for m in magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1 + total_spin
    elif any(m < 0 for m in magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] = -1 - total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0161782}
#island_id: 3
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    magnetisms = [h[site_nbr][k%N][k//N%N] if J[0, k%N, k//N%N, k//((N*N))] > 0 else -h[site_nbr][k%N][k//N%N] for site_nbr in site_nbrs]
    total_spin = sum(magnetisms)
    
    priority_total = np.zeros(2)
    
    if all(m > 0 for m in magnetisms):
      priority_total[0] += -1
      priority_total[1] -= 1 + total_spin
    elif any(m < 0 for m in magnetisms):
      priority_total[0] -= 1
      priority_total[1] = -1 - total_spin
    
    priorities[k] = priority_total
  
  return(priorities)




#score: {'data3D.txt': -0.0021149999999999997}
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] -= J[l,i,j,k]
            priorities[i*N+j*k][1] += J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] += J[l,i,j,k]
            priorities[i*N+j*k][1] -= J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.003267400000000001}
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(interacting_spins)
        if all(m > 0 for m in interacting_spins):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif any(m < 0 for m in interacting_spins):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0022646000000000003}
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -sum(1 for _ in range(N))
      priorities[i][1] -= len([_ for _ in range(N)])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= sum(1 for _ in range(N))
      priorities[i][1] += len([_ for _ in range(N)])

  return(priorities)




#score: {'data3D.txt': -0.0022646000000000003}
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022646000000000003}
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum([h[site_nbr][k%N][k//N] for site_nbr in site_nbrs])
    if all(m > 0 for m in [h[site_nbr][k%N][k//N] for site_nbr in site_nbrs]):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in [h[site_nbr][k%N][k//N] for site_nbr in site_nbrs]):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0023334000000000002}
#island_id: 2
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0023125999999999997}
#island_id: 2
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins]) + total_spin[0]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017054000000000006}
#island_id: 2
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(J[m,i,j,k] * (2*h[site_nbr][j][k] - 1))
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum(interacting_spins)
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum(interacting_spins)
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0023125999999999997}
#island_id: 2
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins]) + total_spin[0]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0015242000000000005}
#island_id: 0
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0015242000000000005}
#island_id: 0
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0018574000000000004}
#island_id: 0
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(6):
        if J[k,i,j,(i+(((k-1)%2)-1))%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0021106}
#island_id: 0
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(6):
        if J[k,i,j,site_nbr] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0011421999999999997}
#island_id: 3
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N][(k//N)**2%N] if J[p, k%N, (k//N)**2%N, k//((N*N*N))] > 0 else -h[site_nbr][k%N][(k//N)**2%N] for p, site_nbr in enumerate(site_nbrs)]
    total_spin = sum(site_magnetisms)
    
    priority_total = np.zeros(2)
    
    if all(m > 0 for m in site_magnetisms):
     priority_total[0] += -1 * len([m for m in site_magnetisms if m > 0])
     priority_total[1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif any(m < 0 for m in site_magnetisms):
     priority_total[0] += -1 * len([m for m in site_magnetisms if m < 0])
     priority_total[1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
     priority_total[0] += sum(m for m in site_magnetisms)
     priority_total[1] = -sum(m for m in site_magnetisms) + total_spin
    
    priorities[k] = priority_total
  
  return(priorities)




#score: {'data3D.txt': -0.0005562000000000005}
#island_id: 3
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum(h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)), (i // (N*N)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs)
    site_magnetisms = [h[site_nbr][i % N][(i // (N*N)) % N] if J[0, i % N, (i // (N*N)), (i // (N*N)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0003650000000000004}
#island_id: 3
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)) % N, (i // ((N*N))) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      for m in site_magnetisms:
        if m > 0:
          priorities[i][0] += -1
          priorities[i][1] -= 1
        elif m < 0:
          priorities[i][0] -= 1
          priorities[i][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.0018301999999999997}
#island_id: 3
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)) % N, (i // ((N*N)**2)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    
    priority_total = np.zeros(2)
    if all(m > 0 for m in site_magnetisms):
      priority_total[0] += -1 * len([m for m in site_magnetisms if m > 0])
      priority_total[1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priority_total[0] += -1 * len([m for m in site_magnetisms if m < 0])
      priority_total[1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priority_total[0] += sum(m for m in site_magnetisms)
      priority_total[1] = -sum(m for m in site_magnetisms) + total_spin
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0,0]
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j,site_nbr] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priorities[i*N+j][0] = total_spin[0]
      priorities[i*N+j][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002054200000000001}
#island_id: 3
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][((i // (N//3)) % N)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = 1 + total_spin
    else:
      if any(m > 0 for m in site_magnetisms):
        priorities[i][0] += -1 * (len([m for m in site_magnetisms if m > 0]) - total_spin)
        priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
      else:
        priorities[i][0] -= len([m for m in site_magnetisms if m < 0]) - total_spin
        priorities[i][1] = 1 + (len([m for m in site_magnetisms if m < 0]))
  return(priorities)




#score: {'data3D.txt': -0.0037498}
#island_id: 3
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += -1 + len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
        elif h[i][j][k] < 0:
          priorities[i*N+j+k][0] -= 1 + len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -1 - total_spin + len([m for m in site_magnetisms if m < 0])
        else:
          priorities[i*N+j+k][0] += -total_spin
          priorities[i*N+j+k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.0016422000000000001}
#island_id: 2
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 4 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 4 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 4 * total_spin[0]
          priorities[i*N+j+k%N][1] = -4 * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0024586000000000005}
#island_id: 2
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 3 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 3 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 3 * total_spin[0]
          priorities[i*N+j+k%N][1] = -3 * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0016422000000000001}
#island_id: 2
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 4 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 4 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 4 * total_spin[0]
          priorities[i*N+j+k%N][1] = -4 * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022382000000000005}
#island_id: 2
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        interacting_spins.sort(key=lambda x: abs(x), reverse=True)
        for spin in interacting_spins:
          if h[i][j][k] > 0:
            priority[0] += spin
            priority[1] -= spin
          else:
            priority[0] -= spin
            priority[1] = -spin
        priorities[i*N+j+k%N] = priority
  return(priorities)




#score: {'data3D.txt': -0.0013982000000000003}
#island_id: 0
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if J[0,i,j,k] > 0:
          total_spin += 1
        elif J[0,i,j,k] < 0:
          total_spin -= 1
        if J[1,i,j,k] > 0:
          total_spin += interacting_spins[1][i,site_nbr,k]
        elif J[1,i,j,k] < 0:
          total_spin -= interacting_spins[1][i,site_nbr,k]
        if J[2,i,j,k] > 0:
          total_spin += interacting_spins[2][i,site_nbr,k]
        else:
          total_spin -= interacting_spins[2][i,site_nbr,k]
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0021149999999999997}
#island_id: 0
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  
  # Calculate interacting spins
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate priority for each site based on its neighbors and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] -= sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N+j*k][1] += sum([J[l,i,j,k] for l in range(6)])
        else:
          priorities[i*N+j*k][0] += sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N+j*k][1] -= sum([J[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': 0.0368114}
#island_id: 1
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = h[i][j][k]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.0194198}
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.0194198}
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.0194198}
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_nbr_values)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.0018898000000000003}
#island_id: 0
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(3):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.0368114}
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = h[i][j][k]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': 0.4288834000000002}
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          priority_total = [np.sum(J[:, i, j, k]) - 1, -(np.sum(J[:, i, j, k])) - 1]
          priorities[i*N**2 + j*N + k] = priority_total
        else:
          priority_total = [-np.sum(J[:, i, j, k]) + 1, -(np.sum(J[:, i, j, k])) + 1]
          priorities[i*N**2 + j*N + k] = priority_total
  
  return priorities




#score: {'data3D.txt': 0.0368114}
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = h[i][j][k] + sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.0030509999999999995}
#island_id: 3
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][1] += -sum(1 for _ in site_magnetisms)
        else:
          priorities[i*N+j+k][1] -= -sum(1 for _ in site_magnetisms)
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -total_spin
          priorities[i*N+j+k][1] -= total_spin
        else:
          priorities[i*N+j+k][0] -= total_spin
          priorities[i*N+j+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.003267400000000001}
#island_id: 3
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif any(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        else:
          if total_spin > N**2 / 2:
            priorities[i*N+j+k][0] += -1
            priorities[i*N+j+k][1] -= 1
          elif total_spin < -N**2 / 2:
            priorities[i*N+j+k][0] -= 1
            priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0043526}
#island_id: 3
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        
        if any(m > 0 for m in site_magnetisms):
          priority = np.sum([J[p,i,j,k]*m for p,m in enumerate(site_magnetisms)])
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1 + priority
        else:
          priority = np.sum([-J[p,i,j,k]*m for p,m in enumerate(site_magnetisms)])
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1 - priority
  
  return(priorities)




#score: {'data3D.txt': -0.0023334000000000002}
#island_id: 2
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0] + (h[i][j][k])
            priorities[i*N+j+k%N][1] -= total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0] - (h[i][j][k])
            priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0025902000000000004}
#island_id: 2
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
            priorities[i*N+j+k%N][1] -= total_spin[1] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
            priorities[i*N+j+k%N][1] = total_spin[1] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
  return(priorities)




#score: {'data3D.txt': -0.0017585999999999995}
#island_id: 2
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[0] - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = 2 * total_spin[0] - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0011890000000000008}
#island_id: 2
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + 1
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] - 1
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0015242000000000005}
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0017138}
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in range(6):
          if J[d//3, i, j, k] > 0:
            total_spin += 1
          elif J[d//3, i, j, k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0037186}
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(3):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j,k]
        if h[i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0017138}
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if J[d//3,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0016189999999999996}
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      for k in range(N):
        if h[site_nbr][j,k] > 0:
          priorities[i*N+j+k][1] += 1
        else:
          priorities[i*N+j+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0018674000000000004}
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += 3 * J[4,i,j,k]
          total_spin[1] -= 2 * J[5,i,j,k]
        else:
          total_spin[0] -= 3 * J[4,i,j,k]
          total_spin[1] += 2 * J[5,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0018558000000000003}
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 2) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
          else:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0037186}
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2
          priorities[i*N+j+k%N][1] -= 2
        else:
          priorities[i*N+j+k%N][0] -= 2
          priorities[i*N+j+k%N][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.0021065999999999997}
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = -total_spin[0] + total_spin[1]
        else:
          priorities[i*N+j+k%N][0] = -total_spin[0] - total_spin[1]
          priorities[i*N+j+k%N][1] = total_spin[0] + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 3
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 3
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -3.100000000000069e-05}
#island_id: 1
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N if m == 0 else (j + ((k-1)%2 - 1)) % N if m == 1 else (i + ((j-1)%2 - 1)) % N
          total_spin += h[site_nbr][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] += len([x for x in [i, j, k] if (x+1) % N == site_nbr])
  
  return priorities




#score: {'data3D.txt': -0.22190700000000033}
#island_id: 1
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.0026066}
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1 + total_spin[0]
            priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
            priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0026018}
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        priority = [total_spin[0], -total_spin[1]]
        priorities[i*N+j+k][0] += total_spin[0]
        priorities[i*N+j+k][1] -= total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0010702000000000005}
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        for m in range(6):
          total_spin[1] -= J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002383}
#island_id: 3
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] if k == 0 else 0
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.002303800000000001}
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = 3*total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = -(4*total_spin[0] + 2*total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -3*total_spin[0] - total_spin[1]
          priorities[i*N+j+k%N][1] = (4*total_spin[0] - 2*total_spin[1])
  return(priorities)




#score: {'data3D.txt': -0.0026601999999999997}
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0019838}
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.002906600000000001}
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0005037999999999999}
#island_id: 2
#version_generated: 3
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for l in range(6):
          total_spin[0] += -2*J[l,i,j,k]
          if h[site_nbrs[l]][j][k] > 0:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
          else:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.003011}
#island_id: 2
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs.sort()
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)




#score: {'data3D.txt': -0.0013025999999999995}
#island_id: 2
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        total_spin_sum = np.sum(total_spin)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin_sum
          priorities[i*N+j+k%N][1] -= total_spin_sum
        else:
          priorities[i*N+j+k%N][0] -= total_spin_sum
          priorities[i*N+j+k%N][1] = -total_spin_sum
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += abs(h[site_nbr_x][j][k]) + abs(h[i][site_nbr_y][k]) + abs(h[i][j][site_nbr_z])
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= abs(h[site_nbr_x][j][k]) + abs(h[i][site_nbr_y][k]) + abs(h[i][j][site_nbr_z])
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.018762599999999987}
#island_id: 1
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin - np.sum(J[:(i+1),:,:])
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin - np.sum(J[:(i+1),:,:])
  
  return priorities




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 3
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins + total_spin
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0023070000000000005}
#island_id: 3
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j] if k == 0 else h[site_nbr2][j]
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0020866}
#island_id: 3
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            interacting_spins += 1
          else:
            interacting_spins -= 1
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.002322200000000001}
#island_id: 3
#version_generated: 3
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins_sum = 0
        interacting_spins_count = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins_sum += J[l,i,j,k]
          interacting_spins_count += np.roll(h, -1, axis=l)[i][j][k] if l < 3 else np.roll(h, 1, axis=l-3)[i][j][k]
        total_spin *= h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins_sum + interacting_spins_count
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins_sum - interacting_spins_count
  return(priorities)




#score: {'data3D.txt': -0.0017666000000000003}
#island_id: 3
#version_generated: 3
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0021498}
#island_id: 3
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        for l in range(6):
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority_total = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -priority_total - interacting_spins
          priorities[i*N+j*k][1] = priority_total + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0020902000000000004}
#island_id: 3
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0027406}
#island_id: 3
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        if h[site_nbr1][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        interacting_spins += J[0,i,j,k]
        interacting_spins += J[1,i,j,k]
        interacting_spins += J[2,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': 0.16642819999999994}
#island_id: 1
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.22190700000000033}
#island_id: 1
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.22190700000000033}
#island_id: 1
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.0020874000000000005}
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[1]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0020633999999999995}
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017377999999999996}
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0015374}
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0026990000000000004}
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0029674000000000007}
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        total_spin = [0, 0]
        for m in range(6):
          if h[i][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
            total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
          else:
            total_spin[1] += J[m,i,j,k]
            total_spin[0] -= -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022694000000000004}
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        for m in range(6):
          if h[i][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
            total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
          else:
            total_spin[1] += J[m,i,j,k]
            total_spin[0] -= -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0019682}
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0026018}
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        site_nbr1 = (i + ((0)%2 - 1)) % N
        site_nbr2 = (i + ((2)%2 - 1)) % N
        site_nbr3 = (i + ((4)%2 - 1)) % N
        for l in range(6):
          if l < 3:
            interacting_spins += J[l,i,j,k] + np.roll(h, -1, axis=l)[site_nbr1][j][k]
          else:
            interacting_spins += J[l,i,j,k] + np.roll(h, 1, axis=l-3)[site_nbr2][j][k]
        total_spin += h[site_nbr1][j][k] if k == 0 else (h[site_nbr2][j][k] if k == N-1 else h[site_nbr3][j][k])
        for l in range(2):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*(interacting_spins + h[site_nbr1][j][k])
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*(interacting_spins + h[site_nbr1][j][k])
  return(priorities)




#score: {'data3D.txt': -0.0029146000000000007}
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] = total_spin + interacting_spins
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
          else:
            priorities[i*N+j*k][0] = -total_spin - interacting_spins
            priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0022754000000000003}
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = 0
        total_energy = 0
        for m in range(6):
          neighbor_spin = (i + ((m % 3) - 1)) % N
          if h[neighbor_spin][j][k] > 0:
            site_spin += 1
          else:
            site_spin -= 1
          total_energy += J[m,i,j,k]*site_spin*h[neighbor_spin][j][k]
        priorities[i*N+j+k%N] = [total_energy, -total_energy]
  return(priorities)




#score: {'data3D.txt': -0.0024638}
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)

  site_interactions = []
  for k in range(N):
    site_interactions.append([])
    for j in range(N):
      site_interactions[k].append([])
      for i in range(N):
        total_spin = [0, 0]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        site_interactions[k][j].append(total_spin)
  for k in range(N):
    for j in range(N):
      priorities[k*N+j] = [np.prod([x[0] for x in site_interactions[k][j]]), np.prod([x[1] for x in site_interactions[k][j]])]
  return(priorities)




#score: {'data3D.txt': -0.004303800000000001}
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)




#score: {'data3D.txt': -0.003162200000000001}
#island_id: 3
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.002391}
#island_id: 3
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0037186}
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        for l in range(6):
          site = (i + ((l%2) - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
          else:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0027369999999999994}
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[l]][j][k]):
            if h[i][j][k] > 0:
              total_spin[0] -= J[l,i,j,k]
            else:
              total_spin[0] += J[l,i,j,k]
          else:
            if h[i][j][k] > 0:
              total_spin[0] += J[l,i,j,k]
            else:
              total_spin[0] -= J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        for m in range(3):
          if h[i][j][k] > 0:
            total_spin[0] += J[m,i,j,k]
            total_spin[1] -= J[m+3,i,j,k]
          else:
            total_spin[0] -= J[m+3,i,j,k]
            total_spin[1] += J[m,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0020838000000000002}
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        if h[i][j][k] > 0:
          priority = [total_spin[0], -total_spin[1]]
        else:
          priority = [-total_spin[0], total_spin[1]]
        priorities[i*N+j+k%N] = priority
  return(priorities)




#score: {'data3D.txt': -0.0026994000000000007}
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0] + 2*h[i][j][k]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0020798}
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority = 0
        if h[i][j][k] > 0:
          priority = total_spin + interacting_spins * 2
        else:
          priority = -total_spin - interacting_spins * 2
        priorities[i*N+j*k][0] = priority
        priorities[i*N+j*k][1] = -priority
  return(priorities)




#score: {'data3D.txt': -0.0027330000000000006}
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k]
        interacting_spins = J[0,i,j,k] + J[1,i,j,k] + J[2,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          for m in range(3):
            site_nbr2 = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr2][j][k] > 0:
              interacting_spins += 1
            else:
              interacting_spins -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0023577999999999993}
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][i,j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][i,j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + sum(interacting_spins)
          priorities[i*N+j*k][1] = -total_spin - 3*sum(interacting_spins)
        else:
          priorities[i*N+j*k][0] = -total_spin - sum(interacting_spins)
          priorities[i*N+j*k][1] = total_spin + 3*sum(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0034342}
#island_id: 2
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []
        
        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)
          
          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)
          
          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)
        
        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])
        
        priorities[i*N+j+k%N] = [priority_x, -priority_y]
  
  return(priorities)




#score: {'data3D.txt': -0.0034342}
#island_id: 2
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]

        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]

        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []

        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)

          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)

          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)

        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])

        priorities[i*N+j+k%N] = [priority_x, -priority_y]

  return(priorities)




#score: {'data3D.txt': -0.0034342}
#island_id: 2
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []
        
        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)
          
          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)
          
          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)
        
        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])
        
        priorities[i*N+j+k%N] = [priority_x, -priority_y]
  
  return(priorities)




#score: {'data3D.txt': -0.0016385999999999998}
#island_id: 2
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.005343400000000001}
#island_id: 0
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0027402000000000004}
#island_id: 2
#version_generated: 3
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins]) + total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0023334000000000002}
#island_id: 2
#version_generated: 3
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0016914000000000007}
#island_id: 2
#version_generated: 3
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) - len(interacting_spins)
          priorities[i*N+j+k%N][1] = -np.sum([x for x in interacting_spins])
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) + len(interacting_spins)
          priorities[i*N+j+k%N][1] = np.sum([x for x in interacting_spins])
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)




#score: {'data3D.txt': -0.0026990000000000004}
#island_id: 2
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.002084200000000001}
#island_id: 2
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
  return(priorities)




#score: {'data3D.txt': -0.002962600000000001}
#island_id: 2
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(6):
          site_nbr = (i + ((m % 2) - 1)) % N
          interacting_spin = J[m, i, j, k] * (2*h[site_nbr][j][k] - 1)
          total_spin += interacting_spin
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0021966}
#island_id: 2
#version_generated: 3
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = len(interacting_spins) - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0025537999999999993}
#island_id: 2
#version_generated: 3
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
      for k in range(N):
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum(total_spin) - len(site_nbrs) * total_spin[1]
          priorities[i*N+j+k%N][1] = -np.sum(total_spin) + len(site_nbrs) * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= np.sum(total_spin) - len(site_nbrs) * total_spin[1]
          priorities[i*N+j+k%N][1] = -np.sum(total_spin) + len(site_nbrs) * total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022758000000000006}
#island_id: 2
#version_generated: 3
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
      for k in range(N):
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017338000000000002}
#island_id: 2
#version_generated: 3
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = [J[l,i,j,k] * (2*h[site_nbr][j][k] - 1) if h[site_nbr][j][k] > 0 else J[l,i,j,k] * (2*h[site_nbr][j][k] + 1) for l, site_nbr in enumerate(site_nbrs)]
        total_spin[1] = -np.sum(interacting_spins)
        total_spin[0] = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.04857700000000003}
#island_id: 1
#version_generated: 3
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x - total_spin_y - total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  for i in range(N):
    for j in range(N):
      total_spin = np.zeros(2)
      site_nbr_x = (i + ((N-1)%2 - 1)) % N
      site_nbr_y = (j + ((N-1)%2 - 1)) % N

      total_spin[0] += h[i][site_nbr_y][0]
      total_spin[0] += h[site_nbr_x][j][0]

      if h[i][j][0] > 0:
        priorities[i*N**2 + j*N][0] += total_spin[0]
        priorities[i*N**2 + j*N][1] = -priorities[i*N**2 + j*N][0]
      else:
        priorities[i*N**2 + j*N][0] -= total_spin[0]
        priorities[i*N**2 + j*N][1] = -priorities[i*N**2 + j*N][0]

  return priorities




#score: {'data3D.txt': -0.21306860000000036}
#island_id: 1
#version_generated: 3
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((N-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        site_nbr_z = [(i + ((N-1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N]
        
        total_spin_x = np.sum([h[site_nbr][k] for site_nbr in site_nbrs_x])
        total_spin_y = np.sum([h[i][site_nbr][k] for site_nbr in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site_nbr] for site_nbr in site_nbr_z])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
          
  return priorities




#score: {'data3D.txt': -0.0021414000000000008}
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        priorities[i*N+j*k][0] = priority_total
        if site_magnetism > 0:
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.0034662000000000004}
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0021994000000000002}
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = (total_spin + interacting_spins) / 2
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -(total_spin + interacting_spins) / 2
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0032534}
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0022613999999999993}
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0006622000000000008}
#island_id: 0
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]

  return(priorities)




#score: {'data3D.txt': 0.0013521999999999994}
#island_id: 0
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]
  return(priorities)




#score: {'data3D.txt': -0.21514300000000028}
#island_id: 1
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -1 - total_spin
          priorities[i*N**2 + j*N + k][1] = 1 + total_spin
  
  return priorities




#score: {'data3D.txt': -0.00028700000000000063}
#island_id: 1
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_y = (j - 1) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_z = (i - 1) % N
        if h[site_nbr_z][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities




#score: {'data3D.txt': -0.0016062}
#island_id: 1
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities




#score: {'data3D.txt': -0.006596999999999999}
#island_id: 1
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in [-1, 0, 1]:
          site_nbr_x = (i + x) % N
          if h[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [-1, 0, 1]:
          site_nbr_y = (j + y) % N
          if h[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [-1, 0, 1]:
          site_nbr_z = (i + z) % N
          if h[site_nbr_z][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin + 1
          priorities[i*N**2 + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin - 1
          priorities[i*N**2 + j*N + k][1] = total_spin + 1
  
  return priorities




#score: {'data3D.txt': -0.002399000000000001}
#island_id: 2
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum)
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) - priority_sum
  return(priorities)




#score: {'data3D.txt': -0.0011158000000000008}
#island_id: 2
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -priority_sum + total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = priority_sum - total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0024002000000000008}
#island_id: 2
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0015374}
#island_id: 2
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0017270000000000005}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 1 + total_spin
        priority_down = -1 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up)
        priorities[i*N+j*k][1] = max(0, priority_down)
  return(priorities)




#score: {'data3D.txt': -0.002521400000000001}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = -spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0008838000000000003}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 3 * total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] = -3 * total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.002245}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum((h[i][j][k] if h[site][j][k] > 0 else -1) * (1 if h[site][j][k] == h[i][j][k] else -1) for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0017054000000000006}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0025050000000000003}
#island_id: 3
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = np.sum(h[(i + ((k-1)%2 - 1)) % N, j, :], axis=0)
        interacting_spins = np.sum(J[:, i, j, k], axis=0)
        
        total_spin = np.dot(site_nbr_sum, interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.003162200000000001}
#island_id: 3
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0026601999999999997}
#island_id: 3
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': 0.0007705999999999998}
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr_x = (i // N**2 % N - 1) % N
    site_nbr_y = ((i // N) % N - 1) % N
    site_nbr_z = (i % N - 1) % N
    
    total_spin = h[site_nbr_x][site_nbr_y][site_nbr_z]
    
    if total_spin > 0:
      priorities[i][0] += 3 - site_nbr_x - site_nbr_y - site_nbr_z
      priorities[i][1] -= 3 - site_nbr_x - site_nbr_y - site_nbr_z
    else:
      priorities[i][0] -= 3 - site_nbr_x - site_nbr_y - site_nbr_z
      priorities[i][1] += 3 - site_nbr_x - site_nbr_y - site_nbr_z
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N if i > 0 else N - 1
        site_nbr_y = (j - 1) % N if j > 0 else N - 1
        site_nbr_z = (k - 1) % N if k > 0 else N - 1
        
        total_spin += h[site_nbr_x][i][j] + h[i][site_nbr_y][k] + h[site_nbr_z][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities




#score: {'data3D.txt': 0.0006549999999999995}
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr_x = (i//N//N + ((i%N)//N - 1)) % N
    site_nbr_y = ((i//N)%N + ((i%N) // N - 1)) % N
    site_nbr_z = (i//N % N + ((i%N-1)%N - 1)) % N
    
    if h[site_nbr_x][site_nbr_y][site_nbr_z] > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 3
    else:
      priorities[i][0] -= 2
      priorities[i][1] += 3
    
  return priorities




#score: {'data3D.txt': -0.00028700000000000063}
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_y = (j - 1) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_z = (i - 1) % N
        if h[site_nbr_z][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N**2 + j*N + k][0] = total_spin + abs(total_spin)
        priorities[i*N**2 + j*N + k][1] = -total_spin + abs(total_spin)

  return priorities




#score: {'data3D.txt': -0.0008797999999999999}
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          site = site_nbrs[l]
          if abs(h[i][j][k]) == abs(h[site][j][k]):
            total_spin[0] += 2*J[l,i,j,k]
          elif h[i][j][k] * h[site][j][k] > 0:
            total_spin[0] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0025098000000000004}
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
      for k in range(N):
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = [1, 0]
        else:
          total_spin = [-1, 0]
        priorities[i*N+j+k%N][0] += total_spin[0]
        priorities[i*N+j+k%N][1] -= total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0017130000000000003}
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0008797999999999999}
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          site = site_nbrs[l]
          if abs(h[i][j][k]) == abs(h[site][j][k]):
            total_spin[0] += 2*J[l,i,j,k]
          elif h[i][j][k] * h[site][j][k] > 0:
            total_spin[0] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.3109617999999999}
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N if m == 0 else (j + ((m-1)%2 - 1)) % N if m == 1 else (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] += len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        
  return priorities




#score: {'data3D.txt': -0.3399837999999996}
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N

        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + len([x for x in [i, j, k] if (x-1) % N == site_nbr_x])
          priorities[i*N**2 + j*N + k][1] -= 1 - len([x for x in [i, j, k] if (x+1) % N == site_nbr_y]) - len([x for x in [i, j, k] if (x-1) % N == site_nbr_z])
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 - len([x for x in [i, j, k] if (x+1) % N == site_nbr_x])
          priorities[i*N**2 + j*N + k][1] += 1 + len([x for x in [i, j, k] if (x-1) % N == site_nbr_y]) + len([x for x in [i, j, k] if (x+1) % N == site_nbr_z])

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if m == 0 else (j+1)%N if m == 1 else (k+1)%N for m in range(3)]
        total_spin = sum(h[site_nbr][i][j] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in site_nbrs if x < i])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in site_nbrs if x > i])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in site_nbrs if x < i])
          priorities[i*N**2 + j*N + k][1] += len([x for x in site_nbrs if x > i])
  
  return priorities




#score: {'data3D.txt': -0.0023250000000000002}
#island_id: 2
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1) + h[i][j][k]
          if h[i][j][k] > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) - total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0023974}
#island_id: 2
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
          interacting_spins.append(total_spin[0 - int(h[site_nbrs[l]][j][k] > 0)])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(interacting_spins) + total_spin[1]
          priorities[i*N+j+k%N][1] = -sum(interacting_spins) - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] = -sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = sum(interacting_spins) + total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0017377999999999996}
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0040838}
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += interacting_spin
            priorities[i*N+j+k%N][1] -= 1
          else:
            priorities[i*N+j+k%N][0] -= interacting_spin
            priorities[i*N+j+k%N][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0019766000000000002}
#island_id: 3
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0017166000000000009}
#island_id: 3
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 1 + total_spin
        priority_down = -1 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up + interacting_spins)
        priorities[i*N+j*k][1] = max(0, priority_down - interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0028058000000000007}
#island_id: 3
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0027458}
#island_id: 3
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0033858000000000004}
#island_id: 3
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [site_nbr1, site_nbr2])
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6) if l < 3)
        interacting_spins_sum += sum(J[l, i, j, k] for l in range(6) if l >= 3)
        total_spin += interacting_spins_sum
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [site_nbr1, site_nbr2])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0025337999999999997}
#island_id: 3
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= 1 - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          for y in range(3):
            if h[site_nbr][j][(x+y)%3] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)




#score: {'data3D.txt': -0.0025337999999999997}
#island_id: 3
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= 1 - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)




#score: {'data3D.txt': -0.0017626000000000002}
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + (k+1)%N) % N])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)




#score: {'data3D.txt': -0.0025337999999999997}
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= 1 - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr_x = (i//N//N + ((i%N)//N - 1)) % N
    site_nbr_y = ((i//N)%N + ((i%N) // N - 1)) % N
    site_nbr_z = (i//N % N + ((i%N-1)%N - 1)) % N

    total_spin = np.sum([h[site_nbr_x][j][k] for j in range(N) for k in range(N)])

    if h[i//N//N][i//N%N][i%N] > 0:
      priorities[i][0] += 2 + total_spin
      priorities[i][1] -= 3 - total_spin
    else:
      priorities[i][0] -= 2 - total_spin
      priorities[i][1] += 3 + total_spin

  return priorities




#score: {'data3D.txt': 0.001840599999999999}
#island_id: 1
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  return priorities




#score: {'data3D.txt': -0.000921}
#island_id: 3
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N**3,))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6)) + sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0018482000000000008}
#island_id: 3
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0029653999999999995}
#island_id: 3
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N, N, N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin[i][j][k][0] += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin[i][j][k][1] = -total_spin[i][j][k][0]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += total_spin[i][j][k][0]
          priorities[i*N+j*k][1] = -total_spin[i][j][k][0]
        else:
          priorities[i*N+j*k][0] -= total_spin[i][j][k][0]
          priorities[i*N+j*k][1] = total_spin[i][j][k][0]
  return(priorities)




#score: {'data3D.txt': -0.0018742000000000006}
#island_id: 3
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -9.999999999993348e-07}
#island_id: 1
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr_x = (i // N**2 % N - 1) % N
    site_nbr_y = ((i // N) % N - 1) % N
    site_nbr_z = (i % N - 1) % N
    
    total_spin = h[site_nbr_x][site_nbr_y][site_nbr_z]
    
    if total_spin > 0:
      priorities[i][0] += np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
      priorities[i][1] -= np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
    else:
      priorities[i][0] -= np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
      priorities[i][1] += np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
  
  return priorities




#score: {'data3D.txt': -0.22190700000000033}
#island_id: 1
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities




#score: {'data3D.txt': -0.0027698}
#island_id: 3
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] -= 2*total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 2*total_spin - 2*interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': -0.0026601999999999997}
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': -0.0022834000000000005}
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + 1
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= total_spin + 1
          priorities[i*N+j*k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0026990000000000004}
#island_id: 2
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin[0] += np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 - total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0018646000000000008}
#island_id: 2
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        total_spin[0] += h[i][j][k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1 + total_spin[0]
            priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
            priorities[i*N+j+k%N][1] = -1 - total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002271000000000001}
#island_id: 2
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        total_spin[0] += h[i][j][k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)




#score: {'data3D.txt': -0.0026990000000000004}
#island_id: 2
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N]
          interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
          total_spin += np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0271254}
#island_id: 1
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((N-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        site_nbr_z = [(i + ((N-1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N]
        
        total_spin_x = np.sum([h[site_nbr][k] for site_nbr in site_nbrs_x])
        total_spin_y = np.sum([h[i][site_nbr][k] for site_nbr in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site_nbr] for site_nbr in site_nbr_z])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
          
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] > 0]) - len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] < 0])
          priorities[i*N**2 + j*N + k][1] -= priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] > 0]) - len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] < 0])
          priorities[i*N**2 + j*N + k][1] += priorities[i*N**2 + j*N + k][0]
          
  return priorities




#score: {'data3D.txt': 0.0005897999999999993}
#island_id: 1
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin_x = h[site_nbr_x][j][k]
        total_spin_y = h[i][site_nbr_y][k]
        total_spin_z = h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.0178806}
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0095574}
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.008441}
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] = -total_spin[0][j][k][0]
  return(priorities)




#score: {'data3D.txt': -0.0027458}
#island_id: 3
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0027458}
#island_id: 3
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0031022000000000007}
#island_id: 3
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[i][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 - interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0027458}
#island_id: 3
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0178806}
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return priorities




#score: {'data3D.txt': -0.0178806}
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0178806}
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        for l in range(3):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
  return(priorities)




#score: {'data3D.txt': -0.0022833999999999997}
#island_id: 2
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin[0] += -2*np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] -= 1
          priorities[i*N+j+k%N][1] += 1
        else:
          priorities[i*N+j+k%N][0] += 1
          priorities[i*N+j+k%N][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0018086}
#island_id: 2
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            priorities[i*N+j+k%N][0] += interacting_spin
            priorities[i*N+j+k%N][1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            priorities[i*N+j+k%N][0] -= interacting_spin
            priorities[i*N+j+k%N][1] += interacting_spin
  return(priorities)




#score: {'data3D.txt': -0.0016253999999999997}
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        total_spin[0] += np.sum([-2*J[l,i,j,k] for l in range(6)])
        if np.mean(h[i].flatten()) > 0:
          priorities[i*N+j+k%N][0] += np.sum([1 if h[i][j][k] > 0 else -1 for j in range(N) for k in range(N)])
          priorities[i*N+j+k%N][1] -= np.sum([1 if h[i][j][k] < 0 else -1 for j in range(N) for k in range(N)])
        else:
          priorities[i*N+j+k%N][0] -= np.sum([1 if h[i][j][k] > 0 else -1 for j in range(N) for k in range(N)])
          priorities[i*N+j+k%N][1] = -np.sum([1 if h[i][j][k] < 0 else -1 for j in range(N) for k in range(N)])
  return(priorities)




#score: {'data3D.txt': -0.2869110000000003}
#island_id: 1
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] -= np.sum([J[l, i, j, k] for l in [1, 4]])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] += np.sum([J[l, i, j, k] for l in [1, 4]])
        
  return priorities




#score: {'data3D.txt': -0.31795419999999996}
#island_id: 1
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
        for l in range(6):
          if J[l, i, j, k] > 0:
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
          
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr_x = (i//N//N + ((i%N)//N - 1)) % N
    site_nbr_y = ((i//N)%N + ((i%N) // N - 1)) % N
    site_nbr_z = (i//N % N + ((i%N-1)%N - 1)) % N

    total_spin = np.sum([h[site_nbr_x][j][k] for j in range(N) for k in range(N)])

    if h[i//N//N][i//N%N][i%N] > 0:
      priorities[i][0] += 2 + total_spin
      priorities[i][1] -= 3 - total_spin
    else:
      priorities[i][0] -= 2 - total_spin
      priorities[i][1] += 3 + total_spin

  return priorities




#score: {'data3D.txt': -0.18127899999999983}
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = 0
        total_spin_y = 0
        total_spin_z = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin_x += 1
        else:
          total_spin_x -= 1
          
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin_y += 1
        else:
          total_spin_y -= 1
          
        site_nbr_z = (i + ((k-1)%2 - 1)) % N
        if h[i][j][site_nbr_z] > 0:
          total_spin_z += 1
        else:
          total_spin_z -= 1
        
        priorities[i*N**2 + j*N + k][0] = total_spin_x + total_spin_y + total_spin_z + abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
        priorities[i*N**2 + j*N + k][1] = -total_spin_x - total_spin_y - total_spin_z + abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
  
  return priorities




#score: {'data3D.txt': -0.0021914000000000005}
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 2 * np.sum(total_spin1)
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] + 2 * np.sum(total_spin1)
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.0023506}
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 5 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] - 5 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.0019838}
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.0021914000000000005}
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 2 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] + 2 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.0024322000000000002}
#island_id: 3
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        total_spin -= 2 * interacting_spins
        spin_diff -= 2 * sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0022642}
#island_id: 3
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 3 * total_spin + spin_diff
          priorities[i*N+j*k][1] = -1 - 2 * spin_diff
        else:
          priorities[i*N+j*k][0] = -3 * total_spin - spin_diff
          priorities[i*N+j*k][1] = 1 + 2 * spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0008838000000000003}
#island_id: 3
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 3 * total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] = -3 * total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0029998000000000004}
#island_id: 3
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        site_nbrs_sum = sum(sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)]) for _ in range(6))
        interacting_spins_sum -= site_nbrs_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -1 - (1 + total_spin + interacting_spins_sum)
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 1 - (1 + total_spin + interacting_spins_sum)
  return(priorities)




#score: {'data3D.txt': -0.0012109999999999998}
#island_id: 2
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
  return(priorities)




#score: {'data3D.txt': -0.002084200000000001}
#island_id: 2
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
  return(priorities)




#score: {'data3D.txt': -0.002069}
#island_id: 2
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += (total_spin + np.sum([x if x > 0 else -1 for x in interacting_spins])) + 1
          priorities[i*N+j+k%N][1] -= (total_spin + np.sum([x if x < 0 else -1 for x in interacting_spins])) - 1
        else:
          priorities[i*N+j+k%N][0] -= (total_spin + np.sum([x if x > 0 else -1 for x in interacting_spins])) + 1
          priorities[i*N+j+k%N][1] = -(total_spin + np.sum([x if x < 0 else -1 for x in interacting_spins])) - 1
  return(priorities)




#score: {'data3D.txt': -0.0020558000000000004}
#island_id: 2
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
  return(priorities)




#score: {'data3D.txt': -0.002285}
#island_id: 3
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)]]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0025838000000000007}
#island_id: 3
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
                  -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.004045400000000001}
#island_id: 3
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0027826000000000005}
#island_id: 3
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = []
      interacting_spins = []
      total_spin = 0
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          interacting_spins.append(1)
        else:
          interacting_spins.append(-1)
        total_spin += h[i][j][k]
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j, k] > 0:
          total_spin -= interacting_spins[k]
      priority_total = [total_spin, -total_spin]
      priorities[i*N+j*N+N-1] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0034902000000000006}
#island_id: 3
#version_generated: 3
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for _ in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = interacting_spins - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0023882000000000005}
#island_id: 3
#version_generated: 3
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 - interacting_spins + total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + interacting_spins - total_spin
  return(priorities)




#score: {'data3D.txt': -0.005760600000000001}
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          
  return(priorities)




#score: {'data3D.txt': -0.003230600000000001}
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0049998}
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 3
        else:
          total_spin[i*N+j*N+k][0] -= 3

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][0]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][0]

  return(priorities)




#score: {'data3D.txt': -0.005279400000000001}
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.006683400000000001}
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          total_spin = 0
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          total_spin = 0
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin -= 1
            else:
              total_spin += 1
          priorities[i*N+j*N+k][0] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.0016858000000000005}
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(1,N):
    for j in range(1,N):
      for k in range(1,N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+N+k][0] += 1
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N*j+N+k][0] -= 1
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.005343400000000001}
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])

  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0032534}
#island_id: 3
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0026022000000000007}
#island_id: 3
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin * (1 + sum(J[l,i,j,k] for l in range(6)))
          priorities[i*N+j*k][1] -= -total_spin + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= total_spin * (1 + sum(J[l,i,j,k] for l in range(6)))
          priorities[i*N+j*k][1] = -total_spin - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0038838000000000006}
#island_id: 3
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] if J[l, i, j, k] > 0 else -1 for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*N+k][0] += 1 + total_spin
        priorities[i*N+j*N+k][1] -= 1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] if J[l, i, j, k] > 0 else -1 for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        for site_nbr_sum_val in [site_nbr_sum]:
          priority_total = [total_spin + site_nbr_sum_val, -total_spin - site_nbr_sum_val]
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0171698}
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] if J[l, (i + ((l-1)%2 - 1)) % N, j, k] > 0 else -J[l, (i + ((l-1)%2 - 1)) % N, j, k] for l in range(6))
        total_spin = site_nbr_sum + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1 + total_spin
          priorities[i*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0026166}
#island_id: 3
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': -0.0028182000000000007}
#island_id: 3
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins_sum
          priorities[i*N+j*k][1] -= 2 * site_nbr_sum - 2 * interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum - interacting_spins_sum
          priorities[i*N+j*k][1] = 2 * site_nbr_sum + 2 * interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': -0.0026822000000000005}
#island_id: 3
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + 1
          priorities[i*N+j*k][1] -= interacting_spins_sum - site_nbr_sum - 1
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + 1
          priorities[i*N+j*k][1] = interacting_spins_sum - site_nbr_sum + 1
  return(priorities)




#score: {'data3D.txt': -0.0018969999999999998}
#island_id: 3
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins_sum
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0023769999999999998}
#island_id: 0
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
            else:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
            else:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0014010000000000008}
#island_id: 0
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0031582000000000003}
#island_id: 0
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          for y in range(3):
            for z in range(3):
              site = (i + ((x-1)%2 - 1)) % N
              if h[i][j][k] > 0:
                total_spin += J[(((x+y+z)-3)//2)%6, i, j, k]
              else:
                total_spin -= J[(((x+y+z)-3)//2)%6, i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0017905999999999998}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          else:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = -priorities[i*N+j*N+k][0]
  return(priorities)




#score: {'data3D.txt': -0.007495}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][0] = -2*(N**3-total_spin-1)*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][l][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0,0.0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.011892199999999999}
#island_id: 0
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.016707}
#island_id: 0
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][l][k] for l in range(3))
        priorities[i*N+j*N+k][0] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.0020893999999999995}
#island_id: 0
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if any(h[site][j][k] > 0 for site in site_nbrs):
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.0052606}
#island_id: 0
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(J[:,site_nbr,j,k]) * h[site_nbr][j][k]
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.0143014}
#island_id: 0
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site][j][k] for site in [i, site_nbr])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 2*total_spin*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 2*total_spin*np.sum(J[:, i, j, k])
  return(priorities)




#score: {'data3D.txt': -0.0026846000000000005}
#island_id: 0
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          site_nbrs.append((site_nbr, d))
        priorities[i*N+j*N+k][0] = -total_spin
        for site_nb in site_nbrs:
          if h[site_nb[0]][j][k] > 0:
            priorities[i*N+j*N+k][0] += 1
          else:
            priorities[i*N+j*N+k][0] -= 1
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][1] -= J[l,i,j,k]
          else:
            priorities[i*N+j*N+k][1] += J[l,i,j,k]
  return(priorities)




#score: {'data3D.txt': -0.0025838000000000007}
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
         -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0025838000000000007}
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
                  -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0025838000000000007}
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
                  -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
        priorities[i*N+j+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.0028450000000000003}
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 + 2*interacting_spins - total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + 2*interacting_spins - total_spin
  return(priorities)




#score: {'data3D.txt': 0.0022542}
#island_id: 2
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      total_spin[0] += J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]]*h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': -0.0022614}
#island_id: 2
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
        site_nbr2 = (i + ((k-1)%2 - 1)) % N
        for m in range(N):
          if J[3][site_nbr][m][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.0040154}
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 4*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 4*np.sum(J[:,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.013463000000000001}
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
        
        # calculate the priority for assigning spins to -1 and 1
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin**2
          priorities[i*N+j*N+k][1] -= (total_spin+1)**2
        else:
          priorities[i*N+j*N+k][0] -= (total_spin-1)**2
          priorities[i*N+j*N+k][1] += total_spin**2
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for x in range(3):
          if h[i][(x+1)%N][((k+1)%2)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)




#score: {'data3D.txt': -0.0023838}
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = total_spin * np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k]) * (total_spin + 1)
        else:
          priorities[i*N+j*N+k][0] = -(total_spin + 1) * np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k]) * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.007283799999999999}
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': 0.0022542}
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      neighbor_sites = []
      if (site_nbr[0] == 0 or site_nbr[0] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[1] == 0 or site_nbr[1] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[2] == 0 or site_nbr[2] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      for k in range(len(neighbor_sites)):
        total_spin[0] += J[j][neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]*h[neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': -0.0064789999999999995}
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': -0.002607000000000001}
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': -0.0022478000000000003}
#island_id: 3
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l, i, j, k] + (np.roll(h, -1, axis=l)[site_nbrs[0]][j][k] if l < 3 else np.roll(h, 1, axis=l-3)[site_nbrs[0]][j][k]) for l in range(6)]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 + total_spin
          priorities[i*N+j*k][1] = -4 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 2 + total_spin
          priorities[i*N+j*k][1] = 4 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0022478000000000003}
#island_id: 3
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = sum(J[l,i,j,k] if (l < 3 and site_nbr == i) or (l >= 3 and site_nbr == (i+1)%N) else 0 for l,site_nbr in zip(range(6),site_nbrs))
        total_spin = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        spin_diff = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 + spin_diff
          priorities[i*N+j*k][1] -= 3 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 2 - spin_diff
          priorities[i*N+j*k][1] = 1 + spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0031598000000000004}
#island_id: 3
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins + total_spin
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0019682}
#island_id: 3
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0030886000000000004}
#island_id: 3
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = -total_spin
          priorities[i*N+j*k][1] += 1
        else:
          priorities[i*N+j*k][0] = total_spin
          priorities[i*N+j*k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.001739}
#island_id: 3
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6))
        for l, interacting_spin in enumerate(interacting_spins):
          total_spin += J[l, i, j, k]*interacting_spin
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.002607000000000001}
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0026414}
#island_id: 0
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.005998200000000001}
#island_id: 0
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate total spin and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.009281000000000001}
#island_id: 0
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (site + ((y-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_spin += np.sum(J[:,site,j,k])
            else:
              total_spin -= np.sum(J[:,site,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.004881800000000001}
#island_id: 0
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        # Add magnetism and interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
            total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0064789999999999995}
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0033862}
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0064789999999999995}
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0019385999999999997}
#island_id: 3
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] = -(total_spin+interacting_spins)
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = 1 + (total_spin+interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.0016726000000000004}
#island_id: 3
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 2 + total_spin
          priorities[i*N+j*k][1] = -2 - spin_diff
        else:
          priorities[i*N+j*k][0] = -2 + total_spin
          priorities[i*N+j*k][1] = 2 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0016726000000000004}
#island_id: 3
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = sum(1 for _ in range(N)) + total_spin
          priorities[i*N+j*k][1] = -sum(1 for _ in range(N)) - spin_diff
        else:
          priorities[i*N+j*k][0] = -sum(1 for _ in range(N)) + total_spin
          priorities[i*N+j*k][1] = sum(1 for _ in range(N)) - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0038721999999999997}
#island_id: 3
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N] + [(i + (k+1)%N) % N]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in site_nbrs)
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(h[i][l][k] if h[i][l][k]>0 else -1 for l in range(N)), -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0017458000000000003}
#island_id: 3
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        priority_total = [total_spin + interacting_spins, -total_spin - interacting_spins]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2
          priorities[i*N+j*k][1] -= 2
        else:
          priorities[i*N+j*k][0] -= 2
          priorities[i*N+j*k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.002741}
#island_id: 3
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins_site = [J[l, i, j, k] if J[l, i, j, k]>0 else -1 for l in range(6)]
        interacting_spins = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += h[site_nbr][j][k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)




#score: {'data3D.txt': -0.0035954000000000008}
#island_id: 3
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site) else h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        total_spin[0] += h[i][j][k]
        total_spin[1] -= h[i][j][k]
        if site_nbr_sum > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        elif site_nbr_sum < 0:
          total_spin[0] -= 1
          total_spin[1] += 1
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin[0]
          priorities[i*N+j*k][1] = -total_spin[1]
        else:
          priorities[i*N+j*k][0] = -total_spin[0]
          priorities[i*N+j*k][1] = total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0049366}
#island_id: 0
#version_generated: 3
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k] + h[i][site_nbr2][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
        
        # Calculate total spin for sites with the same z-coordinate as site (i,j)
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.001957400000000001}
#island_id: 0
#version_generated: 3
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0029598000000000003}
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0033862}
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [site_nbrs[0], site_nbrs[1], (j+1)%3]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0033446}
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = [0.0] * 2
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0033862}
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Add the magnetism and interaction energy to the priority
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.0025166000000000003}
#island_id: 3
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] = -(total_spin + interacting_spins) - spin_diff
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0026634000000000002}
#island_id: 3
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -2 * (h[i][j][k] <= 0) for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -total_spin - interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.0022906000000000003}
#island_id: 3
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        spin_sum = total_spin + spin_diff
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 * spin_sum + interacting_spins
          priorities[i*N+j*k][1] -= 2 * spin_sum - 2 * interacting_spins
        else:
          priorities[i*N+j*k][0] -= 2 * spin_sum + interacting_spins
          priorities[i*N+j*k][1] = 2 * spin_sum - 2 * interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0027698}
#island_id: 3
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] -= 2*total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 2*total_spin - 2*interacting_spins_sum
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0032166}
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or \
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] + \
                   interacting_spins[1][site_nbr_ij][k] + \
                   interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -priorities[i][0]
    priorities[i][1] = -priorities[i][1]
  
  return(priorities)




#score: {'data3D.txt': -0.0044142}
#island_id: 2
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
  for i in range(N**3):
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)




#score: {'data3D.txt': -0.0064789999999999995}
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': 0.0022542}
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      neighbor_sites = []
      if (site_nbr[0] == 0 or site_nbr[0] == N-1) and (j < 3):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[1] == 0 or site_nbr[1] == N-1) and (j >= 3):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      for k in range(len(neighbor_sites)):
        total_spin[0] += J[j][neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]*h[neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0038457999999999995}
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i+((k-1)%2 - 1))%N,(i%N//N)%N,i%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      for k in range(8):
        if k < 4:
          total_spin[0] += J[j][site_nbr[0]][(site_nbr[1]+k%2-N//2)%N][(site_nbr[2]+k%2-N//2)%N]*h[(site_nbr[0]+k%2-N//2)%N][(site_nbr[1]+k%2-N//2)%N][k%2]
        else:
          total_spin[1] -= J[j][site_nbr[0]][(site_nbr[1]+k%2-N//2)%N][(site_nbr[2]+k%2-N//2)%N]*h[(site_nbr[0]+k%2-N//2)%N][(site_nbr[1]+k%2-N//2)%N][k%2]
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)




#score: {'data3D.txt': -0.005343400000000001}
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.010131800000000002}
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 3
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 3
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': 0.007420199999999998}
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= total_spin - 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0418206}
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr_ij = (i + ((k-1)%2 - 1)) % N
        interacting_spin = (
          h[site_nbr_ij][j][k] +
          J[0][site_nbr_ij][j][k]*h[(site_nbr_ij+1)%N][j][k] +
          J[1][i][j][k]*h[i][(j+1)%N][k] +
          J[2][i][j][k]*h[i][j][(k+1)%N]
        )
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      site_nbr_j = (j + ((2-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((1-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0064789999999999995}
#island_id: 2
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0019410000000000002}
#island_id: 2
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.002607000000000001}
#island_id: 2
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0025518}
#island_id: 2
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1 - total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1 + total_spin[0]
        priorities[i][1] -= 1
    return(priorities)




#score: {'data3D.txt': -0.011540600000000002}
#island_id: 2
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr[0]]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        priorities[i*N+j*k][0] = np.exp(site_magnetism * (2*priority_total))
        priorities[i*N+j*k][1] = -priorities[i*N+j*k][0]
  return(priorities)




#score: {'data3D.txt': -0.0020710000000000004}
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        site_magnetism = h[i][j][k]
        priority_total = np.sum(interacting_spins)
        if site_magnetism > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][0] = -priority_total
          priorities[i*N+j*k][1] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0024246}
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = (total_spin + sum(interacting_spins)) * site_magnetism
        priorities[i*N+j*k][0] = priority_total
        if site_magnetism > 0:
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.0026509999999999997}
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        if site_magnetism > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][0] = -priority_total
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.0016338000000000004}
#island_id: 3
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + sum(a>0 for a in priority_total)
          priorities[i*N+j*k][1] -= 1 - sum(1-a for a in priority_total)
        else:
          priorities[i*N+j*k][0] -= 1 + sum(a>0 for a in priority_total)
          priorities[i*N+j*k][1] = 1 - sum(1-a for a in priority_total)
  return(priorities)




#score: {'data3D.txt': -0.0018742000000000006}
#island_id: 3
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0023453999999999997}
#island_id: 3
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs), 
                  -total_spin - sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.002421000000000001}
#island_id: 3
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + len([x for x in interacting_spins_site if x > 0]), -total_spin - len([x for x in interacting_spins_site if x < 0])]
        priorities[i*N+j*k] = priority_total
  return(priorities)




#score: {'data3D.txt': -0.0024390000000000006}
#island_id: 3
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        h_site = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        J_site = sum(J[l, i, j, k]*h[site_nbr][j][k] for l, site_nbr in enumerate(site_nbrs))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = h_site + J_site
          priorities[i*N+j*k][1] = -h_site - J_site
        else:
          priorities[i*N+j*k][0] = -h_site - J_site
          priorities[i*N+j*k][1] = h_site + J_site
  return(priorities)




#score: {'data3D.txt': -0.0018782000000000004}
#island_id: 3
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0018782000000000004}
#island_id: 3
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0010029999999999998}
#island_id: 0
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate magnetization and interaction energies
  total_spin_magnetism = np.zeros((N,N,N,2))
  for i in range(N):
   for j in range(N):
    for k in range(N):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     total_spin_magnetism[i][j][k] = [h[site_nbr][j][k], np.sum(J[:,i,j,k])]
  
  # Calculate priorities based on magnetization and interaction energies
  for i in range(N):
   for j in range(N):
    for k in range(N):
     total_spin_magnetism[i][j][k][0] += h[i][j][k]
     if h[i][j][k] > 0:
      priorities[i*N+j*N+k][0] = -total_spin_magnetism[i][j][k][1]
      priorities[i*N+j*N+k][1] += total_spin_magnetism[i][j][k][1]
     else:
      priorities[i*N+j*N+k][0] = total_spin_magnetism[i][j][k][1]
      priorities[i*N+j*N+k][1] -= total_spin_magnetism[i][j][k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.0023742}
#island_id: 0
#version_generated: 3
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Calculate final priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0026414}
#island_id: 0
#version_generated: 3
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0023742}
#island_id: 0
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Calculate final priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0031098000000000007}
#island_id: 0
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N-1):
    for j in range(1,N-1):
      for k in range(1,N-1):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site_x = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_x,j,k])
          else:
            total_spin -= np.sum(J[:,site_x,j,k])
        
        for y in range(3):
          site_y = (i + ((y-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,site_y,k])
          else:
            total_spin -= np.sum(J[:,i,site_y,k])
        
        for z in range(3):
          site_z = (i + ((z-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,site_z])
          else:
            total_spin -= np.sum(J[:,i,j,site_z])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+N+k][0] = -total_spin
          priorities[i*N*j+N+k][1] += total_spin
        else:
          priorities[i*N*j+N+k][0] = total_spin
          priorities[i*N*j+N+k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0023742}
#island_id: 0
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Calculate final priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0004918000000000005}
#island_id: 0
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N):
    for j in range(1,N):
      for k in range(1,N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.001957400000000001}
#island_id: 0
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          if x == 0:
            site = (i + ((x-1)%2 - 1)) % N
          elif x == 1:
            site = (j + ((x-1)%2 - 1)) % N
          else:
            site = (k + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.001957400000000001}
#island_id: 0
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005760600000000001}
#island_id: 0
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0038838000000000006}
#island_id: 3
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins

  return(priorities)




#score: {'data3D.txt': -0.0038838000000000006}
#island_id: 3
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
          interacting_spins = sum(J[l,i,j,k] for l in range(6))
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
          interacting_spins = sum(J[l,i,j,k] for l in range(6))
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0034578}
#island_id: 3
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        total_spin = site_nbr_sum + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin + 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0019370000000000004}
#island_id: 3
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        for l in range(6):
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority_total = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = priority_total + abs(total_spin) * 2
          priorities[i*N+j*k][1] = -priority_total - 4*abs(total_spin)
        else:
          priorities[i*N+j*k][0] = -priority_total - 2*interacting_spins
          priorities[i*N+j*k][1] = priority_total + 4*abs(total_spin) - interacting_spins
  return(priorities)




#score: {'data3D.txt': 0.006143399999999999}
#island_id: 0
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = 0
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spin = np.sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + interacting_spin
          priorities[i*N+j*N+k][1] -= total_spin - interacting_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin - interacting_spin
          priorities[i*N+j*N+k][1] += total_spin + interacting_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((k+1)%2 - 1)) % N]
        total_spin = np.sum(J[:,site_nbrs[0],j,k]) * h[site_nbrs[0]][j][k] - np.sum(J[:,site_nbrs[1],j,k]) * h[site_nbrs[1]][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.007443000000000001}
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[1]
    priorities[i][1] = -total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0008774000000000001}
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = [0, 0]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] -= -total_spin[1]
    elif J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': 0.0025758000000000005}
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(N):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0021474000000000007}
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum + total_spin - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = -2*interacting_spins_sum - total_spin + site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0020434000000000003}
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum + total_spin - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins_sum - total_spin + site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0034966}
#island_id: 3
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.0022274000000000005}
#island_id: 3
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2 * interacting_spins_sum + site_nbr_sum - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = -2 * interacting_spins_sum + site_nbr_sum + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0178806}
#island_id: 0
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0058418}
#island_id: 0
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1
  
  # Calculate priority for each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      for i in range(N):
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] + sum(h[i][m] for m in range(3))
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0300662}
#island_id: 1
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_x = interacting_spins_x[site_nbr_i][j][k]
        interacting_spin_y = interacting_spins_y[i][site_nbr_j][k]
        interacting_spin_z = interacting_spins_z[i][j][site_nbr_k]
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_x + interacting_spin_y + interacting_spin_z
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)  

  total_spin = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        total_spin[k*N**2+j*N+i][0] += h[i][j][k] 
        if h[i][j][k] > 0:
          total_spin[k*N**2+j*N+i][1] -= 1
        else:
          total_spin[k*N**2+j*N+i][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_k = (k + ((2-1)%2 - 1)) % N
        site_nbr_j = (j + ((1-1)%2 - 1)) % N
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        priority_total = np.zeros((1,2))
        site_nbr_kk = (k + ((2-1)%2 - 1)) % N
        for ll in range(6):
          if h[site_nbr_kk][j][i] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if total_spin > 0:
          priority_total[0][0] += 1
          priority_total[0][1] -= 1
        else:
          priority_total[0][0] -= 1
          priority_total[0][1] += 1
        priorities[i*N**2+j*N+k][0] = priority_total[0][0]
        priorities[i*N**2+j*N+k][1] = priority_total[0][1]
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#island_id: 1
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        site_spin = (total_spin > 0) * 1
        priorities[k*N**2+j*N+i][0] = site_spin + np.sum(h == h[site_nbr_k][j][i])
        priorities[k*N**2+j*N+i][1] = -site_spin + N**3 - np.sum(h == h[site_nbr_k][j][i])
  return(priorities)




#score: {'data3D.txt': -0.0025390000000000005}
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = max(total_spin + interacting_spins, 0) 
        priority_down = max(-total_spin - spin_diff, 0)
        priorities[i*N+j*k][0] = priority_up
        priorities[i*N+j*k][1] = priority_down
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = max(0, total_spin + interacting_spins)
        priority_down = max(0, spin_diff + interacting_spins)
        priorities[i*N+j*k][0] = priority_up
        priorities[i*N+j*k][1] = -priority_down
  return(priorities)




#score: {'data3D.txt': -0.0016638000000000002}
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 2 + total_spin
        priority_down = -3 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up)
        priorities[i*N+j*k][1] = max(0, priority_down)
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = total_spin + interacting_spins
        priority_down = spin_diff + total_spin
        priorities[i*N+j*k][0] = max(0, min(priority_up, priority_down))
        priorities[i*N+j*k][1] = -priorities[i*N+j*k][0]
  return(priorities)




#score: {'data3D.txt': -0.00010939999999999983}
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N%N] > 0:
      total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6) if interacting_spins[k][site_nbr][i//N%N][i%N%N] == h[site_nbr][i//N%N][i%N%N])
    else:
      total_spin = sum(-J[k, site_nbr, i//N%N, i%N%N] for k in range(6) if interacting_spins[k][site_nbr][i//N%N][i%N%N] == h[site_nbr][i//N%N][i%N%N])

    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': 0.0029226}
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N//N][i%N%N] > 0:
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': 0.006143399999999999}
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    total_spin = 0
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': -0.0018294000000000003}
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((i-1)%2 - 1)) % N
        site_nbr3 = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for x in range(6):
          if J[x, i, j, k] > 0:
            total_spin += h[site_nbr1][j][k]
          else:
            total_spin -= h[site_nbr1][j][k]
        
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.0048318}
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_h = sum(J[k, site_nbr, i//N%N, i%N%N] * h[site_nbr][i//N%N][i%N%N] for k in range(6) if abs(h[site_nbr][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
  
  return priorities




#score: {'data3D.txt': -0.002607000000000001}
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.002469800000000001}
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    priorities[i][1] = -total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
  return(priorities)




#score: {'data3D.txt': -0.0017749999999999999}
#island_id: 3
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          for axis, offset in [(0, -1), (0, 1), (1, -1), (1, 1), (2, -1), (2, 1)]:
            if site_nbr1 != i and abs(site_nbr1-i) == offset:
              interacting_spins += h[site_nbr1][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.0017998000000000005}
#island_id: 3
#version_generated: 3
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = i + ((l-3)%2 - 1) % N if l < 3 else i + ((l-9)%2 - 1) % N
          total_spin += h[site_nbr1][j][k]
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
            interacting_spins -= np.roll(h, -2, axis=l-3)[i][j][k] if i > 0 else 0
          elif l < 6:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
            interacting_spins -= np.roll(h, 2, axis=l-3)[i][j][k] if i < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spin_x = interacting_spins_x[i][j][k]
        interacting_spin_y = interacting_spins_y[i][j][k]
        interacting_spin_z = interacting_spins_z[i][j][k]
        interacting_spin_xo = interacting_spins_xo[i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][k]

        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.035633}
#island_id: 1
#version_generated: 3
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for x in [0, 1]:
          site_nbr_x = (i + ((x-1)%2 - 1)) % N
          if interacting_spins_x[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [0, 1]:
          site_nbr_y = (j + ((y-1)%2 - 1)) % N
          if interacting_spins_y[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [0, 1]:
          site_nbr_z = (k + ((z-1)%2 - 1)) % N
          if interacting_spins_z[i][j][site_nbr_z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.023341}
#island_id: 1
#version_generated: 3
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_x = interacting_spins_x[site_nbr_i][j][k]
        interacting_spin_y = interacting_spins_y[i][site_nbr_j][k]
        interacting_spin_z = interacting_spins_z[i][j][site_nbr_k]
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_x + interacting_spin_y + interacting_spin_z
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
        
  # Calculate interactions along each axis and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_xo + interacting_spin_yo + interacting_spin_zo
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.28452779999999994}
#island_id: 1
#version_generated: 3
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins_x = h[(i+1)%N][j][k] if (i+1)<N else h[0][j][k]
        interacting_spins_y = h[i][(j+1)%N][k] if (j+1)<N else h[i][0][k]
        interacting_spins_z = h[i][j][(k+1)%N] if (k+1)<N else h[i][j][0]
        
        # Calculate total spin and update priorities
        if total_spin + interacting_spins_x > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_x < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
        
        if total_spin + interacting_spins_y > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_y < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j+N*k][1] += 1
        
        if total_spin + interacting_spins_z > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_z < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0027002}
#island_id: 2
#version_generated: 3
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1 - (total_spin[0] + 1) if np.sum(h[site_nbr]) > 0 else 1 + (total_spin[0] + 1)
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1 + (total_spin[0] + 1) if np.sum(h[site_nbr]) < 0 else -1 + (total_spin[0] + 1)
        priorities[i][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.0023001999999999988}
#island_id: 2
#version_generated: 3
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1] + 2 * np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.0060886}
#island_id: 2
#version_generated: 3
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
    
  return(priorities)




#score: {'data3D.txt': -0.0016669999999999999}
#island_id: 2
#version_generated: 3
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    total_spin = [0, 0]
    for j in range(6):
      site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(N):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[1]
        priorities[i][1] = total_spin[0]
      else:
        priorities[i][0] = total_spin[1]
        priorities[i][1] = -total_spin[0]
  return(priorities)




#score: {'data3D.txt': -0.0025245999999999997}
#island_id: 2
#version_generated: 3
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    return(priorities)




#score: {'data3D.txt': -0.0036874}
#island_id: 2
#version_generated: 3
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0006514000000000004}
#island_id: 0
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 4*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 4*np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.00021900000000000042}
#island_id: 0
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] - h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0006514000000000004}
#island_id: 0
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        
        total_spin1 = h[site_nbr1][j][k] + np.sum(J[:,i,j,k])
        total_spin2 = h[i][site_nbr2][k] + np.sum(J[:,i,site_nbr2,k])
        
        if total_spin1 > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        elif total_spin1 < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
          
        if total_spin2 > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,site_nbr2,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,site_nbr2,k])
        elif total_spin2 < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,site_nbr2,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,site_nbr2,k])
  
  return(priorities)




#score: {'data3D.txt': -0.002564200000000001}
#island_id: 0
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0005530000000000006}
#island_id: 0
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*j+N+k][0] = total_spin*np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': 0.0012865999999999995}
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.0079794}
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  site_interactions = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          # Update priorities based on total spin and magnetism
          site_interactions[site_nbr][j][k][0] = -total_spin
          site_interactions[site_nbr][j][k][1] += total_spin
          
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0020098000000000004}
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] = np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k])

  return(priorities)




#score: {'data3D.txt': -0.0013914000000000003}
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0077794}
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)




#score: {'data3D.txt': 0.0069822}
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k] + h[i][site_nbr2][k]
        
        if np.sum(J[:, i, j, k]) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.0069338}
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        total_spin[i*N+j*N+k][0] += sum(interacting_spins)
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.0032166}
#island_id: 2
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on site's proximity to the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    if site_nbr[2] == 0:
      total_spin[1] += 1
    elif site_nbr[2] == N-1:
      total_spin[1] -= 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.006916599999999999}
#island_id: 2
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    priorities[i][0] = -total_spin[0]
    if (site_nbr[0] == 0 or site_nbr[0] == N-1) and (site_nbr[1] == 0 or site_nbr[1] == N-1):
      priorities[i][1] += total_spin[0]
    elif site_nbr[0] < N//2:
      priorities[i][1] -= total_spin[0]
    else:
      priorities[i][1] += total_spin[0]
  
  return(priorities)




#score: {'data3D.txt': -0.0045194}
#island_id: 2
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] += total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0010214}
#island_id: 2
#version_generated: 3
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0025294}
#island_id: 2
#version_generated: 3
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': 0.002103000000000001}
#island_id: 2
#version_generated: 3
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    # Sum the magnetism and count the number of positive interactions
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0029049999999999996}
#island_id: 2
#version_generated: 3
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] -= total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        priorities[i][0] -= total_spin[0] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] = -total_spin[1] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    
    return(priorities)




#score: {'data3D.txt': -0.011572999999999998}
#island_id: 2
#version_generated: 3
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.011540600000000002}
#island_id: 2
#version_generated: 3
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr[0]]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.011540600000000002}
#island_id: 2
#version_generated: 3
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr[0]]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.011540600000000002}
#island_id: 2
#version_generated: 3
#generate time22:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr[0]]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)




#score: {'data3D.txt': -0.0026482}
#island_id: 2
#version_generated: 3
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    return(priorities)




#score: {'data3D.txt': -0.0025245999999999997}
#island_id: 2
#version_generated: 3
#generate time22:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = 0
    total_spin_1 = 0
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 -= 1
      else:
        total_spin_0 -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    return(priorities)




#score: {'data3D.txt': -0.0038766}
#island_id: 1
#version_generated: 2
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0026414}
#island_id: 0
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0026414}
#island_id: 0
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.00036900000000000046}
#island_id: 0
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.10552060000000031}
#island_id: 0
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N**3):
    if h[i//N**(2)][(i//N)%N][(i%N)] > 0:
      priorities[i][0] = -total_spin[i//N**(2)][(i//N)%N][(i%N)][0]
      priorities[i][1] -= total_spin[i//N**(2)][(i//N)%N][(i%N)][1]
    else:
      priorities[i][0] = total_spin[i//N**(2)][(i//N)%N][(i%N)][0]
      priorities[i][1] = -total_spin[i//N**(2)][(i//N)%N][(i%N)][1]

  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(J[:, i, j, k])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0047826000000000006}
#island_id: 0
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.0029154000000000003}
#island_id: 0
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = np.zeros(2)
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if h[i][j][k] > 0:
            priority_total[0] += 1 + total_spin
            priority_total[1] -= 1 - total_spin
          else:
            priority_total[0] -= 1 + total_spin
            priority_total[1] = -1 + total_spin
        priorities[i*N+j*N+k][0] = priority_total[0]
        priorities[i*N+j*N+k][1] = priority_total[1]
  return(priorities)




#score: {'data3D.txt': -0.007495}
#island_id: 0
#version_generated: 3
#generate time22:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(6): 
          if J[l,i,j,k] > 0:  
            total_spin += 1 
          else:   
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][0] = -2*(N**3-total_spin-1)*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': 0.021155399999999998}
#island_id: 0
#version_generated: 3
#generate time22:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0008845999999999997}
#island_id: 0
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.004627}
#island_id: 0
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism at site_nbr
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0011634000000000006}
#island_id: 0
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k]) + np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k]) - np.sum(J[:,site,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,i,site_nbr,k]) + np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,i,site_nbr,k]) - np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0058362}
#island_id: 2
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0.0] * 2
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
      else:
        total_spin[0] -= 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.004251400000000001}
#island_id: 0
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in range(3):
          for y in range(3):
            site_nbr = (i + ((x-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_spin += J[(((x+y-k)//2)%6), i, j, k]
            else:
              total_spin -= J[(((x+y-k)//2)%6), i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0028014}
#island_id: 0
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in [-1,0,1]:
          for y in [-1,0,1]:
            for z in [-1,0,1]:
              site = (i + x) % N
              if site == i:
                continue
              if h[site][j][k] > 0:
                total_spin += J[(((x+y+z-3)//2)%6), i, j, k]
              else:
                total_spin -= J[(((x+y+z-3)//2)%6), i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0058418}
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1
        
  # Calculate priority for each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
        
  return(priorities)




#score: {'data3D.txt': -0.0048318}
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    total_spin_h = sum(J[k, (i % N + ((i//N-1)%2 - 1)) % N, i//N%N, i%N%N] * h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][i%N%N] for k in range(6) if abs(h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, (i % N + ((i//N-1)%2 - 1)) % N, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
  
  return priorities




#score: {'data3D.txt': -0.0027749999999999993}
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_h = sum(J[k, site_nbr, i//N%N, j%N] * h[site_nbr][j%N][k%N] for k in range(6) if abs(h[site_nbr][j%N][k%N]) > 0)
        total_spin_j = sum(J[k, site_nbr, i//N%N, j%N] for k in range(6))
        
        if h[i//N%N][j%N][k%N] > 0:
          priorities[i*N+j+N+k][0] += total_spin_h + total_spin_j
          priorities[i*N+j+N+k][1] -= total_spin_h + total_spin_j
        else:
          priorities[i*N+j+N+k][0] -= total_spin_h + total_spin_j
          priorities[i*N+j+N+k][1] += total_spin_h + total_spin_j
        
  return priorities




#score: {'data3D.txt': -0.0048318}
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_h = sum(J[k, site_nbr, i//N%N, i%N%N] * h[site_nbr][i//N%N][i%N%N] for k in range(6) if abs(h[site_nbr][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
    
  return priorities




#score: {'data3D.txt': -0.0048318}
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_h = sum(J[k, site_nbr, i//N%N, i%N%N] * h[site_nbr][i//N%N][i%N%N] for k in range(6) if abs(h[site_nbr][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
    
  return priorities




#score: {'data3D.txt': 0.021155399999999998}
#island_id: 0
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin * 2
      priorities[i][0] += total_spin * 2
    else:
      priorities[i][1] = total_spin * 2
      priorities[i][0] -= total_spin * 2
    
  return(priorities)




#score: {'data3D.txt': -0.000551}
#island_id: 0
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    priority_total = np.zeros(2)
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        priority_total[1] -= J[x,site_nbr,i // N % N,i % N]
        priority_total[0] += J[x,site_nbr,i // N % N,i % N]
      else:
        priority_total[1] += J[x,site_nbr,i // N % N,i % N]
        priority_total[0] -= J[x,site_nbr,i // N % N,i % N]
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin + priority_total[0]
      priorities[i][0] = total_spin + priority_total[1]
    else:
      priorities[i][1] = total_spin + priority_total[0]
      priorities[i][0] = -total_spin + priority_total[1]
  
  return(priorities)




#score: {'data3D.txt': 0.021155399999999998}
#island_id: 0
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.021155399999999998}
#island_id: 0
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin * (h[site_nbr][i // N % N][i % N])
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin * (h[site_nbr][i // N % N][i % N])
  
  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 1
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.007197000000000001}
#island_id: 0
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N//N][i%N//N][i%N%N] + h[site_nbr][i//N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[i//N//N][i%N//N][i%N%N] > 0:
        total_spin += J[k, i//N//N, i%N//N, i%N%N]
      else:
        total_spin -= J[k, i//N//N, i%N//N, i%N%N]

    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i//N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i//N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i//N//N, i%N%N]

    # Update priorities based on total spin and magnetism
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.0021298000000000003}
#island_id: 0
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      if k < 3:
        site = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        site = (i % N + ((k-4)%2 - 1)) % N
        total_spin -= J[k-3, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.00015339999999999977}
#island_id: 0
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.00015339999999999977}
#island_id: 0
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': -0.002923400000000001}
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0032166}
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
      elif h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.006549800000000001}
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    priorities[i][0] = -total_spin[0]
    if i < N or i >= N**3-N or (i % N) < N//3:
      priorities[i][1] += total_spin[0]
    elif i > N*N*(N-1):
      priorities[i][1] -= total_spin[0]
  
  return(priorities)




#score: {'data3D.txt': -0.0042650000000000006}
#island_id: 0
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])
  return(priorities)




#score: {'data3D.txt': -0.0068062}
#island_id: 0
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] -= total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] += total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = total_spin[i][j][k][1]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] -= 2*np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] = -2*np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] = -2*np.sum(J[:, i, j, k])

  return(priorities)




#score: {'data3D.txt': 0.0080298}
#island_id: 0
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in [i-1, i, i+1]:
          if 0 <= l < N:
            total_spin += h[l][j][k]
        for m in [j-1, j, j+1]:
          if 0 <= m < N:
            total_spin += h[i][m][k]
        for n in [k-1, k, k+1]:
          if 0 <= n < N:
            total_spin += h[i][j][n]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2
        else:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 2
  return(priorities)




#score: {'data3D.txt': -0.0086806}
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((k-1)%2 - 1)) % N])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0029426000000000005}
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if any(h[site][j][k] > 0 for site in site_nbrs):
          total_spin = sum(h[site][j][k] for site in site_nbrs)
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + (2*total_spin - N)
        else:
          total_spin = sum(h[site][j][k] for site in site_nbrs)
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - (2*total_spin - N)
  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.008369800000000002}
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0031122000000000007}
#island_id: 2
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate total spin
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism and interactions
    if total_spin[0] > total_spin[1]:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    elif total_spin[0] < total_spin[1]:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.007532199999999999}
#island_id: 2
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate the priority based on magnetism and interactions
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if total_spin[0] > 0 and total_spin[1] < 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    elif total_spin[0] > 0 and total_spin[1] >= 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    elif total_spin[0] <= 0 and total_spin[1] < 0:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.004233400000000001}
#island_id: 2
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    # Sum the magnetism and count the number of positive interactions
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if np.sum(total_spin) > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': 0.0018498000000000006}
#island_id: 2
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': -0.0060886}
#island_id: 2
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
    
  return(priorities)




#score: {'data3D.txt': -0.004397}
#island_id: 2
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Calculate priority based on site interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
  
  for i in range(N**3):
    total_spin = [0, 0]
    
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    
  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 1
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.005186200000000001}
#island_id: 1
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 1
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k-1)%2
    for i in range(N):
      for j in range(N):
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for k in range(N):
    site_nbr = (k-1)%2
    for i in range(N):
      for j in range(N):
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0026558000000000003}
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = 0
    total_spin_1 = 0
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 -= 1
      else:
        total_spin_0 -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    return(priorities)




#score: {'data3D.txt': -0.0025245999999999997}
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = 0
    total_spin_1 = 0
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 -= 1
      else:
        total_spin_0 -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    return(priorities)




#score: {'data3D.txt': -0.0023618}
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] * (J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0) for j in range(6))
    total_spin_1 = len([j for j in range(6) if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0])
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += 1
        total_spin_1 -= 1
      else:
        total_spin_0 -= 1
        total_spin_1 += 1
    
    priorities[i] = [-total_spin_0, -total_spin_1]
  
  return(priorities)




#score: {'data3D.txt': -0.007283799999999999}
#island_id: 2
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    total = [0, 0]
    
    for j in range(6):
      site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
      
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total[1] -= 1
      else:
        total[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total[1] += 1
    
    for j in range(2):
      priorities[i][j] = -total[j]
  
  return(priorities)




#score: {'data3D.txt': -0.0036874}
#island_id: 2
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)




#score: {'data3D.txt': 0.0018498000000000006}
#island_id: 2
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if site_nbr[0] == (i//N)%N and i < N:
      total_spin[1] += 1
    if site_nbr[1] == (i%N//N)%N and i % N < N//3:
      total_spin[1] += 1
    if site_nbr[2] == (i%N)%N and i >= N*N*(N-1):
      total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    
  return(priorities)




#score: {'data3D.txt': -0.003581}
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k]>0:
            total_spin += -J[l,i,j,k]
          else:
            total_spin -= -J[l,i,j,k]
        priorities[i*N+j*k][0] += total_spin
        priorities[i*N+j*k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.005186200000000001}
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[0,i,j,k]
          priorities[i*N+j*k][1] -= J[0,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[0,i,j,k]
          priorities[i*N+j*k][1] += J[0,i,j,k]

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[1,i,j,k]
          priorities[i*N+j*k][1] -= J[1,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[1,i,j,k]
          priorities[i*N+j*k][1] += J[1,i,j,k]

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[2,i,j,k]
          priorities[i*N+j*k][1] -= J[2,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[2,i,j,k]
          priorities[i*N+j*k][1] += J[2,i,j,k]

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[3,i,j,k]
          priorities[i*N+j*k][1] -= J[3,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[3,i,j,k]
          priorities[i*N+j*k][1] += J[3,i,j,k]

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[4,i,j,k]
          priorities[i*N+j*k][1] -= J[4,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[4,i,j,k]
          priorities[i*N+j*k][1] += J[4,i,j,k]

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[5,i,j,k]
          priorities[i*N+j*k][1] -= J[5,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[5,i,j,k]
          priorities[i*N+j*k][1] += J[5,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.005186200000000001}
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0008126}
#island_id: 0
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N-1):
    for j in range(1,N-1):
      for k in range(1,N-1):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 4*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 4*np.sum(J[:,i,j,k])
        
  for i in range(N-1,N):
    for j in range(1,N-1):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][j][0] + h[site_nbr][j][0]
      
      if total_spin > 0:
        priorities[i*N+j][0] += 4*np.sum(J[:,i,j,0])
        priorities[i*N+j][1] -= 4*np.sum(J[:,i,j,0])
      elif total_spin < 0:
        priorities[i*N+j][0] -= 4*np.sum(J[:,i,j,0])
        priorities[i*N+j][1] += 4*np.sum(J[:,i,j,0])
        
  return(priorities)




#score: {'data3D.txt': -0.0082638}
#island_id: 0
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        
        total_spin = sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N+j*N+k][0] -= sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
        
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    total_spin = h[site_nbr][N//2][N//2]
    
    if total_spin > 0:
      priorities[i*N+N//2+N//2][0] += sum(J[:,i,N//2,N//2])
      priorities[i*N+N//2+N//2][1] -= 2
    elif total_spin < 0:
      priorities[i*N+N//2+N//2][0] -= sum(J[:,i,N//2,N//2])
      priorities[i*N+N//2+N//2][1] += 2
  
  return(priorities)




#score: {'data3D.txt': 0.0018498000000000006}
#island_id: 2
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if site_nbr[0] == (i//N)%N and i < N:
      total_spin[1] += 1
    if site_nbr[1] == (i%N//N)%N and i % N < N//3:
      total_spin[1] += 1
    if site_nbr[2] == (i%N)%N and i >= N*N*(N-1):
      total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#island_id: 2
#version_generated: 3
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]
    
    if sum(total_spin) > 0:
      priorities[i][0] = -sum(total_spin)
      priorities[i][1] = max(0, sum(total_spin))
    elif sum(total_spin) < 0:
      priorities[i][0] = -max(0, -sum(total_spin))
      priorities[i][1] = -sum(total_spin)
    else:
      priorities[i][0] = 0
      priorities[i][1] = 0
  
  return(priorities)




#score: {'data3D.txt': -0.0066262}
#island_id: 2
#version_generated: 3
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]

    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]

    if site_nbr[1] == 0 or site_nbr[1] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[1] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)




#score: {'data3D.txt': -0.0044142}
#island_id: 2
#version_generated: 3
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    interacting_spins = []
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0005685999999999995}
#island_id: 2
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_spin = [h[site_nbr[0]][site_nbr[1]][site_nbr[2]], 0]
    for k in range(3):
      site_nbr = (i // N % N, (i % N // N) % N, ((k-1)%2 - 1) % N)
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        site_spin[1] += 1
      else:
        site_spin[1] -= 1
    
    priorities[i][0] = -total_spin[0] + site_spin[0]
    priorities[i][1] = total_spin[1] + site_spin[1]
  return(priorities)




#score: {'data3D.txt': -0.0038734}
#island_id: 2
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for k in range(3):
      site = (i // N % N, i % N // N % N, (i % N // N % N + ((k-1)%2 - 1)) % N)
      if h[site[0]][site[1]][site[2]] > 0:
        total_spin[0] += 1
      else:
        total_spin[0] -= 1
    priorities[i][0] = -total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    priorities[i][1] = -total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
  return(priorities)




#score: {'data3D.txt': -0.0040073999999999995}
#island_id: 2
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    if site_nbr[2] == 0:
      priorities[i][1] += 1
    elif site_nbr[2] == N-1:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.011613400000000003}
#island_id: 3
#version_generated: 2
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j*N+k][0] -= J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j*N+k][1] += 1
          else:
            priorities[i*N+j*N+k][0] += J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.006154199999999999}
#island_id: 2
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0] + sum([J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] * h[s][t][u] for j, (s, t, u) in enumerate([(site_nbr[0], site_nbr[1], site_nbr[2])] * 6)])
    priorities[i][1] = -total_spin[1] - sum([J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] * h[s][t][u] for j, (s, t, u) in enumerate([(site_nbr[0], site_nbr[1], site_nbr[2])] * 6)])
  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  # get the neighboring sites
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.005186200000000001}
#island_id: 1
#version_generated: 3
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.36082339999999974}
#island_id: 2
#version_generated: 2
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        if h[i][j][k] > 0:
          spin_energy += 1
        else:
          spin_energy -= 1
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += J[l, i, j, k]
          else:
            spin_energy -= J[l, i, j, k]
        priorities[i*N*N + j*N + k][1] = -spin_energy
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate interacting spins
  interacting_spins_x = np.roll(h, -1, axis=2)
  interacting_spins_y = np.roll(h, 1, axis=2)
  interacting_spins_z = np.roll(h, -1, axis=1) + np.roll(h, 1, axis=1)

  for k in range(N):
    for i in range(N):
      for j in range(N):
        site_nbr_x = (i + (k-1)%2 - 1) % N
        site_nbr_y = (j + (k-1)%2 - 1) % N
        
        total_spin = h[site_nbr_x][j] + h[i][site_nbr_y]
        
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += -J[0, i, j, k]
          priorities[i*N+j*k][1] -= J[0, i, j, k]
        else:
          priorities[i*N+j*k][0] -= J[0, i, j, k]
          priorities[i*N+j*k][1] += J[0, i, j, k]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[0,i,j,k]
          priorities[i*N+j*k][1] -= J[0,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[0,i,j,k]
          priorities[i*N+j*k][1] += J[0,i,j,k]

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      
      if J[1,i,j,0] > 0:
        priorities[i*N+j][0] += -J[1,i,j,0]
        priorities[i*N+j][1] -= J[1,i,j,0]
      else:
        priorities[i*N+j][0] -= J[1,i,j,0]
        priorities[i*N+j][1] += J[1,i,j,0]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[2,i,j,0] > 0:
        priorities[i*N+j][0] += -J[2,i,j,0]
        priorities[i*N+j][1] -= J[2,i,j,0]
      else:
        priorities[i*N+j][0] -= J[2,i,j,0]
        priorities[i*N+j][1] += J[2,i,j,0]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
   site_nbr = (k-1)%2
   for i in range(N):
    for j in range(N):
     total_spin = h[site_nbr][j]
     if J[0,i,j,k] > 0:
      priorities[i*N+j*k][0] += -J[0,i,j,k]
      priorities[i*N+j*k][1] -= J[0,i,j,k]
     else:
      priorities[i*N+j*k][0] -= J[0,i,j,k]
      priorities[i*N+j*k][1] += J[0,i,j,k]

     site_nbr = (j-1)%2
     total_spin += h[site_nbr][i]
     if J[3,i,j,k] > 0:
      priorities[i*N+j*k][0] += -J[3,i,j,k]
      priorities[i*N+j*k][1] -= J[3,i,j,k]
     else:
      priorities[i*N+j*k][0] -= J[3,i,j,k]
      priorities[i*N+j*k][1] += J[3,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.003149}
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    for i in range(N):
      for j in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0020134000000000007}
#island_id: 1
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        total_spin = sum(h[site_nbr][k%N] for site_nbr in site_nbrs)
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0024914000000000004}
#island_id: 1
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.34337860000000014}
#island_id: 2
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_parity = [0] * (N ** 3)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if h[i][j][k] > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += J[l, i, j, k]
          else:
            spin_energy -= J[l, i, j, k]

        priorities[i*N*N + j*N + k][1] = -spin_energy
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities




#score: {'data3D.txt': 0.0063658000000000005}
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site][j][k] for site in [i, site_nbr])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 2*total_spin*np.sum(J[:, i, j, k]) + np.sum(J[:, site_nbr, j, k])
          priorities[i*N+j*N+k][1] -= total_spin - np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 2*total_spin*np.sum(J[:, i, j, k]) + np.sum(J[:, site_nbr, j, k])
          priorities[i*N+j*N+k][1] += total_spin - np.sum(J[:, i, j, k])

  return(priorities)




#score: {'data3D.txt': -0.0037854}
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(3)])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          else:
            priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
  
  return(priorities)




#score: {'data3D.txt': 0.004187399999999999}
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 2
        else:
          total_spin -= 2

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.004187399999999999}
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 2
        else:
          total_spin -= 2

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0038746}
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priority_total = np.zeros(2)
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priority_total[0] += 1 + total_spin
            priority_total[1] -= 1 - total_spin
          else:
            priority_total[0] -= 1 + total_spin
            priority_total[1] = -1 + total_spin
        priorities[i*N+j*N+k][0] = priority_total[0]
        priorities[i*N+j*N+k][1] = priority_total[1]
  return(priorities)




#score: {'data3D.txt': -0.0095762}
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for site in [(i + ((x-1)%2 - 1)) % N for x in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0095762}
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(3))
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0095762}
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(3))
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.001711}
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((x-1)%2 - 1)) % N for x in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin
        priorities[i*N+j*N+k][1] = np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0030166000000000004}
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        if h[i][j][k] > 0:
          total_spin += 2*np.sum(J[:,i,j,k])
        else:
          total_spin -= 2*np.sum(J[:,i,j,k])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N+j*N+k][0] = total_spin
        priorities[i*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.0029398}
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
            else:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
            else:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.34337860000000014}
#island_id: 2
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_parity = [0] * (N ** 3)
  spin_energy = np.zeros((N**3))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if h[i][j][k] > 0:
          total_parity[i*N*N + j*N + k] += 1
          spin_energy[i*N*N + j*N + k] -= 2
        else:
          total_parity[i*N*N + j*N + k] -= 1
          spin_energy[i*N*N + j*N + k] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy_sum = 0
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy_sum += J[l, i, j, k]
          else:
            spin_energy_sum -= J[l, i, j, k]

        priorities[i*N*N + j*N + k][1] = -spin_energy_sum
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.36082339999999974}
#island_id: 2
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        if h[i][j][k] > 0:
          spin_energy += 1
        else:
          spin_energy -= 1
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += J[l, i, j, k]
          else:
            spin_energy -= J[l, i, j, k]
        priorities[i*N*N + j*N + k][1] = -spin_energy
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities




#score: {'data3D.txt': 0.17194819999999983}
#island_id: 3
#version_generated: 2
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#island_id: 3
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        site_spin = int(np.sign(total_spin))
        priorities[i*N*N + j*N + k][0] = -site_spin
        priorities[i*N*N + j*N + k][1] = 1-site_spin
  return(priorities)




#score: {'data3D.txt': -0.0331746}
#island_id: 3
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in [0, 1, 2]:
          site_nbr2 = (site_nbr + ((d-1)%2 - 1)) % N
          if J[d, i, j, k] > 0:
            total_spin += h[site_nbr2][j][k]
          else:
            total_spin -= h[site_nbr2][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.0228414}
#island_id: 3
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.17216099999999981}
#island_id: 3
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.003581}
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': 0.0023381999999999995}
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  return(priorities)




#score: {'data3D.txt': -0.34337860000000014}
#island_id: 2
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_parity = [0] * (N ** 3)
  spin_energy = np.zeros((N**3))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if h[i][j][k] > 0:
          total_parity[i*N*N + j*N + k] += 1
          spin_energy[i*N*N + j*N + k] -= 2
        else:
          total_parity[i*N*N + j*N + k] -= 1
          spin_energy[i*N*N + j*N + k] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy_sum = 0
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy_sum += J[l, i, j, k]
          else:
            spin_energy_sum -= J[l, i, j, k]

        priorities[i*N*N + j*N + k][1] = -spin_energy_sum
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.34234539999999963}
#island_id: 2
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += interacting_spin
          else:
            spin_energy -= interacting_spin
        
        priorities[i*N*N + j*N + k][1] = -spin_energy
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': 0.004627}
#island_id: 0
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism at site_nbr
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 6.259999999999988e-05}
#island_id: 0
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = sum(h[site][i//N%N][i%N] for site in [(i + ((k-1)%2 - 1)) % N for k in range(6)])
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(3):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     if h[site_nbr][i//N%N][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] += np.sum(J[:,site_nbr,i//N%N,i%N])
     else:
       priorities[i][0] += np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] -= np.sum(J[:,site_nbr,i//N%N,i%N])
  
  return(priorities)




#score: {'data3D.txt': -0.0022458}
#island_id: 0
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          else:
            priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.0022854}
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.003581}
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': 0.008475}
#island_id: 0
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, i, (i+1)%N, (j-1)%N, j, (j+1)%N, (k-1)%N, k, (k+1)%N]
        site_nbrs = [site for site in site_nbrs if 0 <= site < N]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= total_spin - 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.005700200000000001}
#island_id: 0
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i-1)%N + (j-1)%N + (k-1)%N, 
               (i+1)%N + (j-1)%N + (k-1)%N, 
               (i-1)%N + (j+1)%N + (k-1)%N, 
               (i+1)%N + (j-1)%N + (k+1)%N, 
               (i-1)%N + (j+1)%N + (k+1)%N, 
               (i+1)%N + (j+1)%N + (k+1)%N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr//N][site_nbr%N][site_nbr//N%N]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] += 2
        else:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] -= 2
  return(priorities)




#score: {'data3D.txt': 0.0018774000000000009}
#island_id: 1
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  for k in range(N):
    site_nbr = (k + ((i-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
    if J[3,k,j,k]>0:
      priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
    else:
      priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)




#score: {'data3D.txt': -0.0041198}
#island_id: 1
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0025982}
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        J_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] = -J_sum
          priorities[i*N*j+N+k][1] = 2*J_sum
        else:
          priorities[i*N*j+N+k][0] = J_sum
          priorities[i*N*j+N+k][1] = -2*J_sum
  return(priorities)




#score: {'data3D.txt': -0.016896599999999998}
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          spin1 = -1
          spin2 = 1
        else:
          spin1 = 1
          spin2 = -1
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N+j*N+k][0] += 1
            priorities[i*N+j*N+k][1] -= 1
          else:
            priorities[i*N+j*N+k][0] -= 1
            priorities[i*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.0001433999999999993}
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interaction_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += total_spin*interaction_sum
          priorities[i*N*j+N+k][1] -= interaction_sum
        else:
          priorities[i*N*j+N+k][0] -= total_spin*interaction_sum
          priorities[i*N*j+N+k][1] = -interaction_sum
  return(priorities)




#score: {'data3D.txt': -0.21840260000000028}
#island_id: 2
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        parity = h[i][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if parity * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N + j*N + k][1] = -total_spin
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.3377885999999997}
#island_id: 2
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': 0.20275100000000018}
#island_id: 2
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 - total_spin
  
  return priorities




#score: {'data3D.txt': -0.32961419999999975}
#island_id: 2
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
  
  return priorities




#score: {'data3D.txt': -0.03404699999999998}
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities




#score: {'data3D.txt': -0.14424340000000008}
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin
          priorities[i*N*N + j*N + k][1] = 1 + total_spin
  return priorities




#score: {'data3D.txt': -0.1533362000000002}
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l][site_nbr][j][k] * h[site_nbr][l][k] for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
  
  return priorities




#score: {'data3D.txt': -0.14424340000000008}
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
  return priorities




#score: {'data3D.txt': -0.1067058000000001}
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [h[i][j][k], 2 + total_spin - (total_spin > 0)]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities




#score: {'data3D.txt': -0.14424340000000008}
#island_id: 2
#version_generated: 3
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin - np.sum(np.abs(h[site_nbr, j, k]))
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin + np.sum(np.abs(h[site_nbr, j, k]))
          priorities[i*N*N + j*N + k][1] = 1 + total_spin
  return priorities




#score: {'data3D.txt': -0.0036070000000000004}
#island_id: 1
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            total_spin += J[l,i,j,k]
            priorities[i*N+j*k][0] -= J[l,i,j,k]
            priorities[i*N+j*k][1] += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
            priorities[i*N+j*k][0] += J[l,i,j,k]
            priorities[i*N+j*k][1] -= J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': 0.0015706000000000001}
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

    for k in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,k,j,k]>0:
        priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
      else:
        priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

    for i in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][k]
      if J[5,i,k,0]>0:
        priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
      else:
        priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  # get the neighboring sites
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.22463819999999998}
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N ** 3)]
  total_spin = np.zeros((N, N, N, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]  # get the neighboring sites
        total_spin[i][j][k][0] += h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -J[0, i, j, k]
          total_spin[i][j][k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][1] -= -J[0, i, j, k]
          total_spin[i][j][k][1] += 1

  return priorities




#score: {'data3D.txt': -0.004420599999999999}
#island_id: 0
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] * (h[site_nbr][i//N%N][i%N%N] == h[i//N%N][i%N%N][i%N%N]) for k in range(6))
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': -0.0051994}
#island_id: 0
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate nearest neighbor interactions
  interacting_spins = []
  for i in range(6):
    interacting_spin = np.copy(h)
    if i < 3:
      interacting_spin[:, :, :-1] = h[:, :, 1:]
    else:
      interacting_spin[:, :-1, :] = h[:, 1:, :]
    interacting_spins.append(interacting_spin)

  # Calculate priorities for each site
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Calculate the total magnetism at this site
    for k in range(6):
      if interacting_spins[k][site_nbr, i//N%N, i%N//N] == h[site_nbr, i//N%N, i%N%N]:
        total_spin += J[k, site_nbr, i//N%N, i%N%N]
    
    # Calculate the priority for each spin
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0009382000000000005}
#island_id: 0
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = sum(J[k, site_nbr, i//N%N, i%N%N] for k in [0, 4])
    total_spin_down = sum(-J[k, site_nbr, i//N%N, i%N%N] for k in [1, 2, 3, 5])

    if h[site_nbr][i//N%N][i%N%N] > 0:
      priorities[i][0] += total_spin_up - total_spin_down
      priorities[i][1] -= total_spin_up + total_spin_down
    else:
      priorities[i][0] -= total_spin_up + total_spin_down
      priorities[i][1] += total_spin_up - total_spin_down

  return(priorities)




#score: {'data3D.txt': 0.0003821999999999997}
#island_id: 0
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [h[(site_nbr+k)%N][i//N%N][i%N%N] if k < 3 else h[(site_nbr+(k-3)%6)%N][i//N%N][i%N%N] for k in range(6)]
    total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] * interacting_spins[k] for k in range(6))
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data3D.txt': 0.005190199999999999}
#island_id: 3
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if h[tuple(np.mod([site_nbr_nbr[0], site_nbr_nbr[1], site_nbr_nbr[2]], N))]:
            total_spin += J[d, i, j, k] * h[tuple(np.mod([site_nbr_nbr[0], site_nbr_nbr[1], site_nbr_nbr[2]], N))]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.18088540000000022}
#island_id: 3
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        if np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0)) > 0:
          priorities[i*N*N + j*N + k][0] = total_spin + 1
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin - 1
          priorities[i*N*N + j*N + k][1] = total_spin + 1
  return(priorities)




#score: {'data3D.txt': 0.029998600000000052}
#island_id: 3
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_nbr = [site_nbr]
        for d in [0, 1]:
          site_nbr_nbr.append((i + ((d-1)%3 - 1)) % N)
        for nbr in set(site_nbr_nbr):
          total_spin += h[nbr][j][k] * (h[nbr][j][k] > 0) - (h[nbr][j][k] < 0)
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.011892199999999999}
#island_id: 0
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 4
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 4
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.0140674}
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 4 + total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 4 - total_spin
          priorities[i*N+j*N+k][1] = 2*np.sum(J[:,i,j,k])
  return(priorities)




#score: {'data3D.txt': -0.006528199999999999}
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 3 + total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 3 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.0023990000000000005}
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        interaction_term = np.sum(J[:, i, j, k])

        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] -= total_spin - interaction_term
          priorities[i*N+j*N+k][1] += total_spin + interaction_term
        else:
          priorities[i*N+j*N+k][0] += total_spin + interaction_term
          priorities[i*N+j*N+k][1] -= total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': 0.0043682}
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  # Perform a quicksort on the priority list to reduce computation time
  for i in range(N**3):
    if priorities[i, 0] < priorities[i, 1]:
      priorities[[i, N**3-1-i], :]=priorities[[N**3-1-i, i], :]

  return(priorities)




#score: {'data3D.txt': -0.0017221999999999995}
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          for y in range(3):
            site_x = (i + ((x-1)%2 - 1)) % N
            site_y = (j + ((y-1)%2 - 1)) % N
            total_spin += np.sum(J[:,site_x,site_y,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.0002510000000000008}
#island_id: 0
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Add interactions with next-nearest neighbors (if they exist)
        for x in range(3):
          site = ((i+x)%N + ((k-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.23482820000000001}
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': 0.0013662000000000001}
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        for _ in range(8): 
          if np.random.rand() < 0.5:
            priorities[i*N**2 + j*N + k][0] = -total_spin
            priorities[i*N**2 + j*N + k][1] = total_spin
          else:
            priorities[i*N**2 + j*N + k][0] = total_spin
            priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': 0.14579980000000017}
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities




#score: {'data3D.txt': -0.003352200000000001}
#island_id: 0
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])
        
        # Calculate priority based on total spin and magnetism
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  # Normalize the priority values for each site
  max_val = np.max(priorities, axis=0)
  min_val = np.min(priorities, axis=0)
  
  priorities[:, 0] = (priorities[:, 0] - min_val[0]) / (max_val[0] - min_val[0])
  priorities[:, 1] = (priorities[:, 1] - min_val[1]) / (max_val[1] - min_val[1])
  
  return(priorities)




#score: {'data3D.txt': -0.007593}
#island_id: 0
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Sort sites by priority in descending order
  for i in range(N**3):
    for j in range(2):
      if priorities[i][j] > 0:
        priorities[i][1-j] = -priorities[i][j]
  
  return(priorities)




#score: {'data3D.txt': -0.003230600000000001}
#island_id: 0
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0100506}
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbr = ((i % N) + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i % N, (i // N), site_nbr] > 0:
      priorities[i][0] += -J[0, i % N, (i // N), site_nbr]
    else:
      priorities[i][1] -= -J[0, i % N, (i // N), site_nbr]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  # get the neighboring sites
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0012554}
#island_id: 0
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interaction_sum = 0
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
            interaction_sum -= J[x, i, j, k]
          else:
            total_spin -= 1
            interaction_sum += J[x, i, j, k]
        priorities[i*N*j+N+k][0] = -total_spin*interaction_sum
        priorities[i*N*j+N+k][1] = interaction_sum
  return(priorities)




#score: {'data3D.txt': 0.0002409999999999997}
#island_id: 0
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interaction_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*total_spin*interaction_sum
          priorities[i*N*j+N+k][1] -= interaction_sum
        else:
          priorities[i*N*j+N+k][0] -= 4*total_spin*interaction_sum
          priorities[i*N*j+N+k][1] = -interaction_sum
  return(priorities)




#score: {'data3D.txt': 0.0001433999999999993}
#island_id: 0
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interaction_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += total_spin*interaction_sum
          priorities[i*N*j+N+k][1] -= interaction_sum
        else:
          priorities[i*N*j+N+k][0] -= total_spin*interaction_sum
          priorities[i*N*j+N+k][1] = -interaction_sum
  return(priorities)




#score: {'data3D.txt': 0.20275100000000018}
#island_id: 2
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 - total_spin
        
  return priorities




#score: {'data3D.txt': 0.17953780000000016}
#island_id: 2
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l, site in enumerate(((i + ((l-1)%2 - 1)) % N for l in range(6)))) for _ in range(N))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l, site in enumerate(((i + ((l-1)%2 - 1)) % N for l in range(6)))) for _ in range(N))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 * total_spin
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -1
        
  return priorities




#score: {'data3D.txt': -0.05237220000000001}
#island_id: 2
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for l, site_nbr in enumerate(site_nbrs):
          interacting_spin = J[l][i][j][k] * h[site_nbr][j][k]
          if interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j]), 2 + total_spin - (total_spin > 0)]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities




#score: {'data3D.txt': -0.1067058000000001}
#island_id: 2
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [h[i][j][k], 2 + total_spin - (total_spin > 0)]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities




#score: {'data3D.txt': -0.061783400000000016}
#island_id: 2
#version_generated: 3
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j][:]), 
                  -2 if total_spin < 0 else 2]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities




#score: {'data3D.txt': 0.16770260000000006}
#island_id: 3
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_nbr = [(site_nbr, d) for d in [0, 1]]
        for nbr in set(site_nbr_nbr):
          total_spin += h[nbr[0]][j][k] * (h[nbr[0]][j][k] > 0) - (h[nbr[0]][j][k] < 0)
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(3):
    interacting_spins = np.roll(h, 1, axis=i)
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]  
        total_spin = h[site_nbrs[0]][j][k]
        for l in range(6):
          if J[l,i,j,k]>0:
            total_spin += interacting_spins[(l-1)%3][j][k]
          else:
            total_spin -= interacting_spins[(l-1)%3][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= -total_spin
          priorities[i * N * N + j * N + k][0] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0013157999999999998}
#island_id: 1
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k]>0:
              priorities[i*N*N+k+j][0] += -J[l,i,j,k]
            else:
              priorities[i*N*N+k+j][1] -= -J[l,i,j,k]
        else:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k]>0:
              priorities[i*N*N+k+j][1] += -J[l,i,j,k]
            else:
              priorities[i*N*N+k+j][0] -= -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': 0.0021298000000000003}
#island_id: 0
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      if k < 3:
        site = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        site = (i % N + ((k-4)%2 - 1)) % N
        total_spin -= J[k-3, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.0021298000000000003}
#island_id: 0
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      if k < 3:
        site = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        site = (i % N + ((k-4)%2 - 1)) % N
        total_spin -= J[k-3, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.0019578}
#island_id: 0
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 2*np.sum(J[:, site_nbr, i%N//N, i%N%N])
    else:
      total_spin -= 2*np.sum(J[:, site_nbr, i%N//N, i%N%N])
    priorities[i][1] = -total_spin
    priorities[i][0] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.00044419999999999947}
#island_id: 0
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      
      if h[site][i%N//N][i%N%N] > 0:
        if k < 3:
          total_spin += J[k, site, i%N//N, i%N%N]
        else:
          total_spin -= J[k-3, site, i%N//N, i%N%N]
      else:
        if k < 3:
          total_spin -= J[k, site, i%N//N, i%N%N]
        else:
          total_spin += J[k-3, site, i%N//N, i%N%N]
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.33250379999999974}
#island_id: 1
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for m in range(6):
          if h[site_nbr][j][k] == J[m, i, j, k]:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00031420000000000026}
#island_id: 1
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.1717913999999998}
#island_id: 2
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + ((k-1)%2 - 1)) % N) * N*N + j*N + k
        parity = h[i][j][k]
        if parity > 0:
          total_parity[site_nbr] += 1
          priorities[site_nbr][1] -= 1
        else:
          total_parity[site_nbr] -= 1
          priorities[site_nbr][1] += 1

  for i in range(N):
    for j in range(N):
      site_energy = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        if h[i][j][k] * J[k, i, j, k] > 0:
          site_energy += J[k, i, j, k]
        else:
          site_energy -= J[k, i, j, k]

      priorities[site_nbr][1] = -site_energy
      total_parity[site_nbr] += h[i][j][k]
      if total_parity[site_nbr] > 0:
        priorities[site_nbr][0] += 2
        priorities[site_nbr][1] -= 1
      else:
        priorities[site_nbr][0] -= 1
        priorities[site_nbr][1] += 2

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.1701173999999998}
#island_id: 3
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.1701173999999998}
#island_id: 3
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': 0.039783800000000015}
#island_id: 3
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = -np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0026701999999999993}
#island_id: 3
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if np.sum(h[site_nbr][j]) > 0:
          priorities[i*N*N + j*N + k] = [-np.sum(h[site_nbr][j]), np.sum(h[site_nbr][j])]
        else:
          priorities[i*N*N + j*N + k] = [np.sum(h[site_nbr][j]), -np.sum(h[site_nbr][j])]
  return(priorities)




#score: {'data3D.txt': 0.028877800000000002}
#island_id: 3
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0018890000000000003}
#island_id: 0
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][site][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Add interactions with diagonally adjacent sites
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][site] > 0:
            total_spin += np.sum(J[:,i,j,site])
          else:
            total_spin -= np.sum(J[:,i,j,site])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0019206000000000006}
#island_id: 0
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if interacting_spins[x][site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.03404699999999998}
#island_id: 2
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[s][j][k] for s in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities




#score: {'data3D.txt': 0.4288834000000002}
#island_id: 2
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l][i][j][k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': -0.23482820000000001}
#island_id: 2
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': 0.15721100000000024}
#island_id: 3
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.0020009999999999997}
#island_id: 0
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N))
  for i in range(N**3):
    site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
    interacting_spin = sum(h[site][i//N%N][i%N] for site in site_nbrs)
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += interacting_spin
      priorities[i][1] -= 2 + np.sum(J[:,i//N%N,i%N,0])
    else:
      priorities[i][0] -= interacting_spin
      priorities[i][1] += 2 - np.sum(J[:,i//N%N,i%N,0])

  return(priorities)




#score: {'data3D.txt': -0.004812599999999999}
#island_id: 0
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2

  # calculate the priority for each site based on its magnetism and interactions
  for i in range(N**3):
    total_spin = sum(h[site][i//N%N][i%N] for site in [(i + ((k-1)%2 - 1)) % N for k in range(6)])
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(3):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     if h[site_nbr][i//N%N][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] += np.sum(J[:,site_nbr,i//N%N,i%N])
     else:
       priorities[i][0] += np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] -= np.sum(J[:,site_nbr,i//N%N,i%N])

  return(priorities)




#score: {'data3D.txt': 0.4288834000000002}
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum(J[:,i,j,k]) - 1
          priorities[i*N**2 + j*N + k][1] -= np.sum(J[:,i,j,k]) + 1
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum(J[:,i,j,k]) - 1
          priorities[i*N**2 + j*N + k][1] = -np.sum(J[:,i,j,k]) + 1
  return priorities




#score: {'data3D.txt': -0.3383158000000002}
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': 0.057733400000000004}
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities




#score: {'data3D.txt': -0.3928838}
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities




#score: {'data3D.txt': -0.228707}
#island_id: 2
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        site_parity = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(site_parity) > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in site_parity if x > 0])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in site_parity if x < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in site_parity if x > 0])
          priorities[i*N**2 + j*N + k][1] += len([x for x in site_parity if x < 0])
  return priorities




#score: {'data3D.txt': 0.3425773999999996}
#island_id: 0
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs.append((i + ((k-1)%2 - 1)) % N)
  
  site_nbr_map = {site:i for i,site in enumerate(site_nbrs)}
  site_nbr_inv = {i:site for i,site in enumerate(site_nbrs)}

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N**3):
    site = (i // N**(2), i % N**(2) // N, i % N)
    if h[site[0]][site[1]][site[2]] > 0:
      priorities[i][0] = -total_spin[site[0]][site[1]][site[2]][0]
      priorities[i][1] -= total_spin[site[0]][site[1]][site[2]][1]
    else:
      priorities[i][0] = total_spin[site[0]][site[1]][site[2]][0]
      priorities[i][1] = -total_spin[site[0]][site[1]][site[2]][1]

  return(priorities)




#score: {'data3D.txt': 0.011032599999999998}
#island_id: 0
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N**3):
    if h[(i//N)**(2)%N][(i//N)%N][(i%N)] > 0:
      priorities[i][0] = -total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][0]
      priorities[i][1] -= total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][1]
    else:
      priorities[i][0] = total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][0]
      priorities[i][1] = -total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][1]

  return(priorities)




#score: {'data3D.txt': -0.0004950000000000001}
#island_id: 0
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.3424029999999996}
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': 0.012453}
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          if J[l, i, site_nbr, k] * h[i][j][k] > 0:
            total_spin[1] -= J[l, i, site_nbr, k]
          else:
            total_spin[1] += J[l, i, site_nbr, k]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.15837580000000004}
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[0][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l+1][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': -0.295207}
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(6):
          site = (i + ((l-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities




#score: {'data3D.txt': -0.0075998}
#island_id: 0
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((x-1)%2 - 1)) % N for x in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if total_spin > 0:
          priorities[i*N+j*N+k][0] = np.sum(J[:,i,j,k]) + len([x for x in site_nbrs if h[x][j][k] > 0])
          priorities[i*N+j*N+k][1] = -2*len([x for x in site_nbrs if h[x][j][k] > 0])
        elif total_spin < 0:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k]) - len([x for x in site_nbrs if h[x][j][k] < 0])
          priorities[i*N+j*N+k][1] = 2*len([x for x in site_nbrs if h[x][j][k] < 0])
  return(priorities)




#score: {'data3D.txt': -0.0046366}
#island_id: 0
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = 2*total_spin
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][1] += J[x,i,j,k]
          else:
            priorities[i*N+j*N+k][1] -= J[x,i,j,k]
  return(priorities)




#score: {'data3D.txt': 0.009815399999999998}
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.004954200000000001}
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for y in range(3):
          site = (i + ((y-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  # Calculate the priority for each site based on interactions with its nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])

  return(priorities)




#score: {'data3D.txt': 0.004627}
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and magnetism
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for y in range(3):
          site = (i + ((y-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.19256180000000006}
#island_id: 1
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        
        if h[i][j][k] > 0:
          site_nbrs += [j, i, (j+1)%N, (i+1)%N, (j+i-1)%N]
        else:
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, j, i, (j+1)%N, (i+1)%N, (j+i-1)%N]
        
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k] if h[i][j][k] == J[0, i, j, k] else -h[site_nbr][j][k]
        
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0020134000000000007}
#island_id: 1
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        total_spin = sum(h[site_nbr][k%N] for site_nbr in site_nbrs)
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.032626199999999994}
#island_id: 1
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          for m in site_nbrs:
            if J[0, i, j, k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        else:
          for m in site_nbrs:
            if J[0, i, j, k] < 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': 0.034185400000000005}
#island_id: 1
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          
        if J[k, i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0035905999999999993}
#island_id: 1
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k] > 0:
              priorities[i*N*N+k+j][0] += -J[l,i,j,k]
              for m in range(6):
                site_nbrs_2 = [(site_nbrs[0] + (m % 2)) % N, (site_nbrs[1] + ((m//2)%2 - 1)) % N, (site_nbrs[2] + ((m//4)%2 - 1)) % N]
                if J[m,i,j,k] > 0:
                  priorities[i*N*N+k+j][0] += -J[m,i,j,k]
                else:
                  priorities[i*N*N+k+j][1] -= -J[m,i,j,k]
            else:
              priorities[i*N*N+k+j][1] += J[l,i,j,k]
        else:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k] > 0:
              priorities[i*N*N+k+j][1] += -J[l,i,j,k]
              for m in range(6):
                site_nbrs_2 = [(site_nbrs[0] + (m % 2)) % N, (site_nbrs[1] + ((m//2)%2 - 1)) % N, (site_nbrs[2] + ((m//4)%2 - 1)) % N]
                if J[m,i,j,k] > 0:
                  priorities[i*N*N+k+j][1] += -J[m,i,j,k]
                else:
                  priorities[i*N*N+k+j][0] -= -J[m,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0028738000000000006}
#island_id: 1
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = 0
        for l in range(6):
          site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
          total_spin += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
          
          if J[l,i,j,k]>0:
            priorities[i*N*N+k+j][0] += -J[l,i,j,k]*total_spin
          else:
            priorities[i*N*N+k+j][1] -= -J[l,i,j,k]*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0026686000000000006}
#island_id: 0
#version_generated: 3
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N**3):
    total_spin = h[i//N//N][i%N//N][i%N%N]
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add interactions with nearest neighbors
    total_spin += np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    for x in range(3):
      for y in range(3):
        site = (i % N + ((y-1)%2 - 1)) % N
        if h[site][i//N//N][i%N%N] > 0:
          total_spin += np.sum(J[:, site, i//N//N, i%N%N])
        else:
          total_spin -= np.sum(J[:, site, i//N//N, i%N%N])

    # Update priorities based on total spin and magnetism
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] += total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.00015339999999999977}
#island_id: 0
#version_generated: 3
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = np.sum(J[:,site_nbr,i//N//N,i%N%N], axis=0)
    
    if h[site_nbr][i//N//N][i%N%N] > 0:
      priorities[i][0] += h[site_nbr][i//N//N][i%N%N] + np.sum(interacting_spins)
      priorities[i][1] -= h[site_nbr][i//N//N][i%N%N] - np.sum(interacting_spins)
    else:
      priorities[i][0] -= h[site_nbr][i//N//N][i%N%N] + np.sum(interacting_spins)
      priorities[i][1] += h[site_nbr][i//N//N][i%N%N] - np.sum(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.00015339999999999977}
#island_id: 0
#version_generated: 3
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0264526}
#island_id: 3
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr_nbr][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.15721100000000024}
#island_id: 3
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  total_magnetism = np.sum(h, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin = 1
        else:
          total_spin = -1
        
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03029540000000005}
#island_id: 3
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.10349660000000006}
#island_id: 3
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d,i,j,k]*h[site_nbr_nbr][j][k]
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.07231620000000001}
#island_id: 2
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2, 3]:
          if l == 1:
            site_nbr = (i + ((l-1)%2 - 1)) % N
          elif l == 2:
            site_nbr = (j + ((l-1)%2 - 1)) % N
          else:
            site_nbr = (k + ((l-1)%2 - 1)) % N
          
          total_spin[0] += h[site_nbr][i%N][j%N]
          interacting_spin = J[l, i%N, j%N, k%N]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': 0.013477}
#island_id: 2
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4, 5]:
          site_nbr = (i + ((l-2)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': 0.0016389999999999998}
#island_id: 2
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for l in [3, 4]:
          site_nbr = (i + ((l-3)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.18907620000000003}
#island_id: 2
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        priorities[i*N*N + j*N + k][0] = site_parity + total_spin[0]
        priorities[i*N*N + j*N + k][1] = -site_parity - total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.16461060000000002}
#island_id: 3
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = -np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
        else:
          priorities[i*N*N + j*N + k][0] = total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.15673940000000033}
#island_id: 3
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.25791540000000057}
#island_id: 3
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j][k] * h[i][j][k])
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[i][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.15673940000000033}
#island_id: 3
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.0092466}
#island_id: 3
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += np.sum(J[d, :, :, :] * h[site_nbr_nbr])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.16666860000000003}
#island_id: 3
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = -np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
            if h[i][j][k] > 0:
              priorities[i*N*N + j*N + k][0] -= total_spin
              priorities[i*N*N + j*N + k][1] = -priorities[i*N*N + j*N + k][0]
            else:
              priorities[i*N*N + j*N + k][0] = -priorities[i*N*N + j*N + k][0]
              priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.047046199999999955}
#island_id: 3
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = -np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
            if h[i][j][k] > 0:
              priorities[i*N*N + j*N + k][0] = -total_spin
              priorities[i*N*N + j*N + k][1] = total_spin
            else:
              priorities[i*N*N + j*N + k][0] = total_spin
              priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.0008377999999999999}
#island_id: 1
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
        for l in range(3):
          site_nbrs_site = [(site_nbrs[0] + ((l-1)%2 - 1)) % N, (j + (l-1)%2 - 1) % N, (k + (l-1)%2 - 1) % N]
          total_spin += h[site_nbrs_site[0]][site_nbrs_site[1]][site_nbrs_site[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.00031420000000000026}
#island_id: 1
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.00011540000000000028}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1+1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.0023381999999999995}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  return(priorities)




#score: {'data3D.txt': 0.0023381999999999995}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    total_spin = 0
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  return(priorities)




#score: {'data3D.txt': 0.032626199999999994}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = 0
        if h[i][j][k] > 0:
          for m in site_nbrs:
            if J[0, i, j, k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        else:
          for m in site_nbrs:
            if J[0, i, j, k] < 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = 0
        if h[i][j][k] > 0:
          for m in site_nbrs:
            total_spin += 1
        else:
          for m in site_nbrs:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': 0.05503500000000005}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + (l-1)%2 - 1) % N for l in [0,1,2]]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if J[0, i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': 0.032626199999999994}
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          for m in site_nbrs:
            if J[0, i, j, k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        else:
          for m in site_nbrs:
            if J[0, i, j, k] < 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': 0.0006721999999999999}
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.0264526}
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr_nbr][j][k] > 0:
            priorities[i*N*N + j*N + k][0] -= J[d, i, j, k]
            priorities[i*N*N + j*N + k][1] += J[d, i, j, k]
          else:
            priorities[i*N*N + j*N + k][0] += J[d, i, j, k]
            priorities[i*N*N + j*N + k][1] -= J[d, i, j, k]
  return(priorities)




#score: {'data3D.txt': 0.0240058}
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr][j][k]
        
        if np.sum(h[i][j][k]) > 0:
          priorities[i*N*N + j*N + k][0] = total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': 6.77999999999993e-05}
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += total_spin[i][j][k][0]
          total_spin[i][j][k][1] -= total_spin[i][j][k][1]
        else:
          total_spin[i][j][k][0] -= total_spin[i][j][k][0]
          total_spin[i][j][k][1] += total_spin[i][j][k][1]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]

  return(priorities)




#score: {'data3D.txt': -0.0011002000000000006}
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0] + total_spin[i][j][k][1]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][0] - total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0] + total_spin[i][j][k][1]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][0] - total_spin[i][j][k][1]

  return(priorities)




#score: {'data3D.txt': -0.013106200000000002}
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + np.sum(J[:,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1 + total_spin
          priorities[i*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.10061580000000006}
#island_id: 2
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0,0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if np.sum(h[i][j]) > 0:
          priorities[i*N*N + j*N + k][0] += 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] -= 2 * (np.sum(np.abs(h[i][j])) - total_spin[1])
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] += 2 * (np.sum(np.abs(h[i][j])) - total_spin[1])
  
  return priorities




#score: {'data3D.txt': 0.0071334}
#island_id: 2
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = 2 + np.sum(total_spin)
          priorities[i*N*N + j*N + k][1] = -np.sum(total_spin) - 2
        else:
          priorities[i*N*N + j*N + k][0] = -2 - np.sum(total_spin)
          priorities[i*N*N + j*N + k][1] = 2 + np.sum(total_spin)
  return priorities




#score: {'data3D.txt': -0.33910299999999965}
#island_id: 2
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 2 - total_spin[0] - np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 + total_spin[1] + np.sum(np.abs(h[i][j]))
  
  return priorities




#score: {'data3D.txt': -0.0037186}
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0032878000000000004}
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[:, i, j, k].sum() > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.13098620000000008}
#island_id: 2
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        parity = h[i][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if parity * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + np.sum(np.abs(h[i]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + np.sum(np.abs(h[i]))
        
  return priorities




#score: {'data3D.txt': 0.20013500000000023}
#island_id: 2
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = site_parity * (total_spin[0] - total_spin[1])
        priorities[i*N*N + j*N + k][1] = site_parity * (total_spin[0] + total_spin[1])
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.2499474}
#island_id: 2
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin + h[site_nbr][j][k]
        priorities[i*N**2 + j*N + k][1] = -total_spin + h[site_nbr][j][k]
  return priorities




#score: {'data3D.txt': -0.3884378}
#island_id: 2
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[0][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l+1][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities




#score: {'data3D.txt': -0.1960806000000003}
#island_id: 3
#version_generated: 2
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.1421818000000002}
#island_id: 2
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 1, 2]]
        total_spin = [0, 0]
        
        for site_nbr in site_nbrs:
          interacting_spins = J[:, i, site_nbr, k]
          
          if h[site_nbr][j][k] > 0:
            total_spin[0] += np.sum(interacting_spins)
            total_spin[1] -= np.sum(interacting_spins)
          else:
            total_spin[0] -= np.sum(interacting_spins)
            total_spin[1] += np.sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = 1 + total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.034866600000000005}
#island_id: 2
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0,0]
        
        # Calculate the magnetism at each site
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        # Calculate the priority based on the magnetism and interactions
        if np.sum(h[i]) > 0:
          priorities[i*N*N + j*N + k][0] = 2 * (np.sum(np.abs(h[i])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = -2 * (np.sum(np.abs(h[i])) - total_spin[1])
        else:
          priorities[i*N*N + j*N + k][0] = -2 * (np.sum(np.abs(h[i])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = 2 * (np.sum(np.abs(h[i])) - total_spin[1])
  
  return priorities




#score: {'data3D.txt': -0.0020134000000000007}
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0024914000000000004}
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0020134000000000007}
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0024914000000000004}
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.3429965999999996}
#island_id: 2
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  for i in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[i][site][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  priorities[i*N**2 + j*N + k][0] = -total_spin
  priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities




#score: {'data3D.txt': -0.1960806000000003}
#island_id: 2
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if h[site_nbr][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 2
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0023822}
#island_id: 1
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.0038766}
#island_id: 1
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          for l in range(6):
            if J[l,i,j,k]>0:
              priorities[i*N+j*k][0] += -J[l,i,j,k]
            else:
              priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.031546999999999985}
#island_id: 2
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin * total_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin * total_spin
  
  return priorities




#score: {'data3D.txt': -0.32961419999999975}
#island_id: 2
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        # Add more spin configurations here...
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 3
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 3
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.17194819999999983}
#island_id: 3
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.1709601999999998}
#island_id: 3
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_val = site_nbr(i, j, k)
        total_spin[i*N*N+j*N+k][0] += h[site_nbr_val][j][k]
        if h[site_nbr_val][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 3
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return priorities




#score: {'data3D.txt': -0.0008205999999999998}
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [(i+1)%N, (i-1+N)%N]:
          interacting_spin = J[0, i, l, k] * (h[l][j][k] if l != i else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for m in [(j+1)%N, (j-1+N)%N]:
          interacting_spin = J[1, i, j, m] * (h[i][m][k] if m != j else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for n in [(k+1)%N, (k-1+N)%N]:
          interacting_spin = J[2, i, j, k] * (h[i][j][n] if n != k else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': 0.0106726}
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  return priorities




#score: {'data3D.txt': 0.0016389999999999998}
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for l in [3, 4]:
          site_nbr = (i + ((l-3)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities




#score: {'data3D.txt': -0.1709601999999998}
#island_id: 3
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = lambda i, j, k: (i + ((k-1)%2 - 1)) % N

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin[i*N*N+j*N+k][0] += h[site_nbr(i,j,k)][j][k]
        if h[site_nbr(i,j,k)][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0020986}
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for j in range(N):
      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[i,k,j,k]>0:
          priorities[k*N+j][0] += 1
          priorities[k*N+j][1] -= 1
        else:
          priorities[k*N+j][0] -= 1
          priorities[k*N+j][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.0016629999999999995}
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[3,k,j,k]>0:
          priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
        else:
          priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)




#score: {'data3D.txt': -0.22557780000000002}
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[site_nbr2][k]
        if J[0, i, j, k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.000942600000000001}
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for k in range(N):
      for j in range(N):
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr][k]
        if J[i,k,j,0]>0:
          priorities[k*N+j][0] += J[i,k,j,0]-J[i,k,j,1]
        else:
          priorities[k*N+j][1] -= J[i,k,j,0]+J[i,k,j,1]

  for i in range(N):
    for k in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i,k,k]>0:
        priorities[i*N+k][0] += J[3,i,k,k]-J[4,i,k,k]
      else:
        priorities[i*N+k][1] -= J[3,i,k,k]+J[4,i,k,k]

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)




#score: {'data3D.txt': -0.0020126000000000002}
#island_id: 1
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(interacting_spins[0,i,j,k]) + h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0093394}
#island_id: 1
#version_generated: 3
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbr = ((i % N) + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i % N, (i // N), site_nbr] > 0:
      priorities[i][0] += -J[0, i % N, (i // N), site_nbr]
    else:
      priorities[i][1] -= -J[0, i % N, (i // N), site_nbr]

  for k in range(3):
    for i in range(N**2):
      site = ((i % N) + ((i//N-1)%2 - 1)) % N
      total_spin = h[site][i % N]
      if J[k, i % N, (i // N), site] > 0:
        priorities[i][0] += -J[k, i % N, (i // N), site]
      else:
        priorities[i][1] -= -J[k, i % N, (i // N), site]

  return(priorities)




#score: {'data3D.txt': -0.0040102}
#island_id: 1
#version_generated: 3
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)
    for j in range(N):
      for k in range(N):
        site_nbr = ((j + ((k-1)%2 - 1)) % N)
        total_spin = h[site_nbr][k]
        if J[i, j, k, site_nbr] > 0:
          priorities[j*N*N + k][0] += -J[i, j, k, site_nbr]
        else:
          priorities[j*N*N + k][1] -= -J[i, j, k, site_nbr]
  return(priorities)




#score: {'data3D.txt': -0.0100506}
#island_id: 1
#version_generated: 3
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N]
    total_spin = h[site_nbrs[0]][i % N]
    if J[0, i % N, (i // N), site_nbrs[0]] > 0:
      for m in site_nbrs:
        priorities[i][0] += -J[0, i % N, (i // N), m]
    else:
      for m in site_nbrs:
        priorities[i][1] -= -J[0, i % N, (i // N), m]

  return(priorities)




#score: {'data3D.txt': 0.0014605999999999998}
#island_id: 2
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Count the number of neighboring sites with positive magnetism
        count_pos = 0
        for l in range(6):
          interacting_site = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_site > 0:
            count_pos += 1
          
        # Calculate the priority based on the total spin and magnetism
        priority_total = [2*count_pos - np.sum(h[i][j][:]), 
                  -2 if count_pos < N**3/2 else 2]
        
        priorities[i*N*N + j*N + k] = priority_total
        
  return priorities




#score: {'data3D.txt': -0.061783400000000016}
#island_id: 2
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j][:]), 
                 -2 if total_spin < 0 else 2]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities




#score: {'data3D.txt': -0.11006180000000024}
#island_id: 2
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = 0
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            site_energy += J[l, i, j, k]
            total_spin += 1
          else:
            site_energy -= J[l, i, j, k]
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -site_energy
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 2
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for s in site_nbrs:
          if h[s][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities




