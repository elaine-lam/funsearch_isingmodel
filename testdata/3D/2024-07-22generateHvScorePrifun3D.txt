#score: {'data3D.txt': -0.4916790000000001}
#island_id: None
#version_generated: None
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.12118580000000022}
#island_id: 0
#version_generated: 3
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
        priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) - 2 * abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) + 2 * abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.24847140000000023}
#island_id: 0
#version_generated: 3
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.28277820000000037}
#island_id: 0
#version_generated: 3
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.2659938000000003}
#island_id: 0
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + sum(1 for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.06766020000000005}
#island_id: 0
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          spin_up_coeff = np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_up_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          spin_down_coeff = -np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) + spin_down_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.2798706000000003}
#island_id: 0
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for d in [0,1,2])
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
      else:
        priorities[i*N*N+j*N+k][0] -= total_spin - np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2659938000000003}
#island_id: 0
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + sum(1 for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.038685399999999766}
#island_id: 3
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)]) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)]) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)




#score: {'data3D.txt': 0.3367122000000001}
#island_id: 3
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = np.sum([1 if val < 0 else -1 for val in interacting_spins]) + np.sum([1 if val > 0 else -1 for val in J[:,i,j,k]])
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = np.sum([1 if val > 0 else -1 for val in interacting_spins]) + np.sum([1 if val < 0 else -1 for val in J[:,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)




#score: {'data3D.txt': 0.11532020000000037}
#island_id: 3
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)]) - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
 
  return(priorities)




#score: {'data3D.txt': -0.0038497999999996743}
#island_id: 3
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)]) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)]) - sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)




#score: {'data3D.txt': -0.34018380000000026}
#island_id: 1
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        interacting_spins = []
        for s in site_nbrs:
          interacting_spins.append(sum(J[d,s,j,k] for d in [0,1,2]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)




#score: {'data3D.txt': 0.06995659999999979}
#island_id: 1
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
          for d in [0,1,2]:
            if J[d,i,j,k] != 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
          for d in [0,1,2]:
            if J[d,i,j,k] != 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] = -J[d,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.36067340000000014}
#island_id: 1
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * priority_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * priority_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#island_id: 1
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 1 + abs(total_spin)
          priority_magnetic = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_magnetic
        else:
          priority_total = -1 - abs(total_spin)
          priority_magnetic = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] += priority_magnetic

  return(priorities)




#score: {'data3D.txt': -0.3873794}
#island_id: 2
#version_generated: 3
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': 0.38705020000000007}
#island_id: 2
#version_generated: 3
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 2*total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.29645659999999996}
#island_id: 0
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          spin_product = np.prod([val >= 0 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(spin_product, 0) * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          spin_product = np.prod([val <= 0 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(spin_product, 0) * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.39180420000000005}
#island_id: 0
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priority_coeff = np.tanh((total_spin + site_energy) / (1 - abs(total_spin)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_coeff = np.tanh((total_spin + site_energy) / (1 - abs(total_spin)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.3967918000000001}
#island_id: 0
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          energy_diff = abs(site_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(site_energy, 0) * (energy_diff < N/4)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          energy_diff = abs(site_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(site_energy, 0) * (energy_diff < N/4)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.18447059999999998}
#island_id: 3
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] -= 2 * hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] += 2 * hamming_distance
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0126614}
#island_id: 3
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][j,k] for k in range(N))
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:][:,0] += 1
        priorities[i*N*N+j*N:][:,1] -= 1
      else:
        priorities[i*N*N+j*N:][:,0] -= 1
        priorities[i*N*N+j*N:][:,1] += 1
  return(priorities)




#score: {'data3D.txt': -0.13056580000000012}
#island_id: 3
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.14389500000000005}
#island_id: 0
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += priority_coeff * max(spin_energy, 0) + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= priority_coeff * max(spin_energy, 0) + site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.3341678}
#island_id: 0
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.28451299999999996}
#island_id: 0
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance

        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin

  return(priorities)




#score: {'data3D.txt': -0.31217219999999996}
#island_id: 0
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val > 0])
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4341130000000001}
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4341130000000001}
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.42011820000000005}
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_bias = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + spin_bias + magnetism_coeff
        else:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_bias = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - spin_bias - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.36698540000000035}
#island_id: 3
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) < 0))
          interaction_coeff = sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + interaction_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) > 0))
          interaction_coeff = sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - interaction_coeff

  return(priorities)




#score: {'data3D.txt': -0.0025042}
#island_id: 3
#version_generated: 3
#generate time09:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + (abs(total_spin) / sum(abs(val) for val in interacting_spins))
          priorities[i*N*N+j*N+k][1] = priority_total - (abs(total_spin) / sum(abs(val) for val in interacting_spins))
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + (abs(total_spin) / sum(abs(val) for val in interacting_spins))
          priorities[i*N*N+j*N+k][1] = -priority_total - (abs(total_spin) / sum(abs(val) for val in interacting_spins))
  return(priorities)




#score: {'data3D.txt': -0.42693060000000005}
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
          
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
          
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] = 1 - total_spin
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] += abs(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] = -priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total
          
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          
          priorities[i*N*N+j*N+k][0] = -priority_total - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -priority_total
        
  return(priorities)




#score: {'data3D.txt': 0.019557399999999697}
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * total_spin
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total - magnetism_coeff
        else:
          priority_total = 2 * total_spin
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -priority_total + magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.43816460000000007}
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
          
          # calculate hamming distance and magnetism coefficient
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # adjust priorities based on the sign of the spin and the hamming distance
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # adjust priority based on the site's magnetism
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
          
          # calculate hamming distance and magnetism coefficient
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # adjust priorities based on the sign of the spin and the hamming distance
          if h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # adjust priority based on the site's magnetism
          if h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] += abs(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
          
  return priorities




#score: {'data3D.txt': -0.0890326}
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          if total_spin >= 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0948294}
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                             J[3,(i-1)%N,j,k] if i > 0 else 0, J[4,i,(j-1)%N,k] if j > 0 else 0, 
                             J[5,(i+1)%N,(j+1)%N,k] if i < N and j < N else 0]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0942282}
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.32541820000000016}
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return priorities




#score: {'data3D.txt': -0.411985}
#island_id: 3
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.411985}
#island_id: 3
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.45060140000000015}
#island_id: 3
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin + magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.18164060000000015}
#island_id: 0
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
        priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.1566630000000002}
#island_id: 0
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.25491380000000036}
#island_id: 0
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_coeff = 1 - abs(total_spin) / N**3
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += priority_coeff + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_coeff = 1 - abs(total_spin) / N**3
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.37583140000000015}
#island_id: 1
#version_generated: 3
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,i,(k+1)%N,k], J[4,(i+N)%N,(j+N)%N,(k+N)%N], 
                   J[5,(i+N)%N,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.39312779999999997}
#island_id: 1
#version_generated: 3
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.39312779999999997}
#island_id: 1
#version_generated: 3
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.17362100000000016}
#island_id: 3
#version_generated: 3
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0 and interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0 and interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

  return(priorities)




#score: {'data3D.txt': 0.3268277999999998}
#island_id: 3
#version_generated: 3
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

        # New term: prioritize spins in the same direction as neighbors
        for d in range(6):
          if J[d,i,j,k] > 0 and h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
          elif J[d,i,j,k] < 0 and h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif J[d,i,j,k] > 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d,i,j,k] < 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += 1

  return priorities




#score: {'data3D.txt': 0.067721}
#island_id: 3
#version_generated: 3
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        interacting_spins.sort()
        if h[i][j][k] > 0:
          if sum(1 for val in interacting_spins if val < 0) % 3 == 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif sum(1 for val in interacting_spins if val > 0) % 2 == 1:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if sum(1 for val in interacting_spins if val > 0) % 3 == 0:
            priorities[i*N*N+j*N+k][1] -= 2
          elif sum(1 for val in interacting_spins if val < 0) % 2 == 1:
            priorities[i*N*N+j*N+k][0] += 1

  return(priorities)




#score: {'data3D.txt': -0.45535660000000017}
#island_id: 1
#version_generated: 3
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin + sum([J[3+d,i,j,k] for d in range(3)])
          priorities[i*N*N+j*N+k][0] += abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -total_spin - sum([J[3+d,i,j,k] for d in range(3)])
          priorities[i*N*N+j*N+k][0] -= abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': 0.3762718000000001}
#island_id: 1
#version_generated: 3
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin - magnetism_coeff
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.07298980000000001}
#island_id: 1
#version_generated: 3
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] += abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          priorities[i*N*N+j*N+k][0] -= abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
        for d in range(3,6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.3153766}
#island_id: 1
#version_generated: 3
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] += abs(priority_total) + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          priorities[i*N*N+j*N+k][0] = -abs(priority_total) + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
  return(priorities)




#score: {'data3D.txt': 0.1124894}
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priority_total = abs(total_spin)
        for d in range(6):
          if J[d,i,j,k] < 0:
            priority_total += 1
          else:
            priority_total -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -priority_total - total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
  return(priorities)




#score: {'data3D.txt': 0.34213619999999956}
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)




#score: {'data3D.txt': 0.3702962000000001}
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.15442059999999985}
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.abs(total_spin) + 1 if total_spin > 0 else -np.abs(total_spin) - 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = np.abs(total_spin) if total_spin < 0 else -np.abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.06445020000000008}
#island_id: 0
#version_generated: 3
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance - spin_energy
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + spin_energy
        site_nbr_spin = h[site_nbr][j][k]
        if site_nbr_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 2 * site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 0
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = np.count_nonzero(np.array(interacting_spins) != h[i][j][k])
        magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0 and val*h[i][j][k] < 0]) / max(len(interacting_spins), 1))
        priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0 and val*h[i][j][k] > 0) - hamming_distance
        spin_energy = -sum(val for val in interacting_spins if val > 0 and val*h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance - spin_energy
  return(priorities)




#score: {'data3D.txt': -0.023678999999999995}
#island_id: 0
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance - spin_energy
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + spin_energy
  return(priorities)




#score: {'data3D.txt': -0.08982340000000001}
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * abs(sum(val for val in interacting_spins if val < 0)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= interaction_term - 2*total_spin
        else:
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * abs(sum(val for val in interacting_spins if val > 0)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = interaction_term - 2*total_spin
  return(priorities)




#score: {'data3D.txt': 0.04313820000000011}
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + interaction_term + np.exp(-abs(total_spin))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - interaction_term - np.exp(-abs(total_spin))
  return(priorities)




#score: {'data3D.txt': -0.4662194}
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_sum = sum(val for val in interacting_spins if val < 0) + total_spin
          spin_diff = abs(spin_sum)
          priorities[i*N*N+j*N+k][0] += np.exp(-spin_diff) * (1 - spin_sum / N**3)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          spin_sum = sum(val for val in interacting_spins if val > 0) + total_spin
          spin_diff = abs(spin_sum)
          priorities[i*N*N+j*N+k][0] -= np.exp(-spin_diff) * (1 - spin_sum / N**3)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': 0.08064580000000005}
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + interaction_term
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': 0.04198580000000001}
#island_id: 0
#version_generated: 3
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0246998}
#island_id: 0
#version_generated: 3
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2*total_spin + priority_coeff)
          priorities[i*N*N+j*N+k][1] -= 2*hamming_distance - total_spin - priority_coeff
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (2*total_spin + priority_coeff)
          priorities[i*N*N+j*N+k][1] = -2*hamming_distance + total_spin + priority_coeff
  return(priorities)




#score: {'data3D.txt': -0.1476402}
#island_id: 0
#version_generated: 3
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.23723820000000007}
#island_id: 0
#version_generated: 3
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2523834000000002}
#island_id: 0
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2067290000000001}
#island_id: 0
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2664798000000003}
#island_id: 0
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - (np.sum(interacting_spins, axis=0).sum() / 6)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - (np.sum(interacting_spins, axis=0).sum() / 6)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2664638000000003}
#island_id: 0
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) + \
                    np.sum(np.abs(interacting_spins) / np.sum(np.abs(J[0, i, j, :])) * \
                       np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) + \
                    np.sum(np.abs(interacting_spins) / np.sum(np.abs(J[0, i, j, :])) * \
                       np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.34344579999999963}
#island_id: 1
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.2291338000000001}
#island_id: 1
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2291338000000001}
#island_id: 1
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.27548220000000034}
#island_id: 1
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += priority_coeff_x + priority_coeff_y + priority_coeff_z + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= priority_coeff_x + priority_coeff_y + priority_coeff_z + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#island_id: 1
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority_total = abs(total_spin)
          priority_magnetic = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_total + magnetism_coeff*priority_magnetic
          priorities[i*N*N+j*N+k][1] -= priority_magnetic
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority_total = -abs(total_spin)
          priority_magnetic = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_total + magnetism_coeff*priority_magnetic
          priorities[i*N*N+j*N+k][1] += priority_magnetic
  return(priorities)




#score: {'data3D.txt': -0.3412677999999996}
#island_id: 1
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], 
                   J[2,i,(j+1)%N,k], J[3,(i+N//2)%N,j,(k+1)%N], 
                   J[4,(i-N//2)%N,j,k], J[5,(i+1)%N,(j-1)%N,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(np.abs(interacting_spins))
          priority_magnetic = np.exp(-np.sum(np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += priority_total + total_spin * 2
          priorities[i*N*N+j*N+k][1] -= priority_magnetic - total_spin
        else:
          priority_total = -np.sum(np.abs(interacting_spins))
          priority_magnetic = np.exp(np.sum(np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= priority_total + total_spin * 2
          priorities[i*N*N+j*N+k][1] += priority_magnetic - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#island_id: 1
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(np.abs(J[:,i,j,k]))
          priority_magnetic = np.exp(-np.mean([abs(s) for s in interacting_spins]))
          priorities[i*N*N+j*N+k][0] += priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priority_total = -1 * np.sum(np.abs(J[:,i,j,k]))
          priority_magnetic = np.exp(np.mean([abs(s) for s in interacting_spins]))
          priorities[i*N*N+j*N+k][0] -= priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)




#score: {'data3D.txt': -0.37582140000000025}
#island_id: 1
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * (np.mean(interacting_spins) < 0)
          priority_magnetic = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          priority_total = -abs(total_spin) * (np.mean(interacting_spins) > 0)
          priority_magnetic = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] = -2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.05514500000000001}
#island_id: 0
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          if priority_coeff > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          if priority_coeff > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = 1 - total_spin - hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.28017940000000024}
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

        # New addition: take into account the site's own magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_priority = abs(total_spin) * (magnetism_coeff + hamming_distance)
          priorities[i*N*N+j*N+k][0] += spin_priority
          priorities[i*N*N+j*N+k][1] -= spin_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_priority = abs(total_spin) * (magnetism_coeff + hamming_distance)
          priorities[i*N*N+j*N+k][0] -= spin_priority
          priorities[i*N*N+j*N+k][1] = -spin_priority

  return(priorities)




#score: {'data3D.txt': -0.17820820000000026}
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.18447059999999998}
#island_id: 3
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] -= 2 * hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] += 2 * hamming_distance
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': 0.32788539999999977}
#island_id: 3
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] -= 2 * hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] += 2 * hamming_distance
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k]) * (hamming_distance < 0.5)
          else:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k]) * (hamming_distance < 0.5)
  return(priorities)




#score: {'data3D.txt': -0.18447059999999998}
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] -= 2 * hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] += 2 * hamming_distance
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.18447059999999998}
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] -= 2 * hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= 2 * hamming_distance
            priorities[i*N*N+j*N+k][1] += 2 * hamming_distance
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.11998099999999985}
#island_id: 0
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_up_parity = total_spin + 1
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_up_parity > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - spin_up_parity
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_down_parity = total_spin - 1
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_down_parity > 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -1 + spin_down_parity
  return(priorities)




#score: {'data3D.txt': -0.15799140000000017}
#island_id: 0
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] += total_spin + 2 * priority_coeff
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin
        else:
          priority_coeff = np.sum(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] -= total_spin + 2 * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.11998099999999985}
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_up_parity = total_spin + 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_up_parity > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - spin_up_parity
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_down_parity = total_spin - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_down_parity > 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -1 + spin_down_parity
  return(priorities)




#score: {'data3D.txt': -0.4221818}
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_up_parity = total_spin + 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_up_parity > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - spin_up_parity
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_down_parity = total_spin - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_down_parity > 0)
          priorities[i*N*N+j*N+k][1] = -1 + spin_down_parity
  return(priorities)




#score: {'data3D.txt': -0.32541820000000016}
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return priorities




#score: {'data3D.txt': -0.32541820000000016}
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return priorities




#score: {'data3D.txt': -0.32541820000000016}
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
  return priorities




#score: {'data3D.txt': -0.1387594}
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff - total_spin - 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 1 + 2*total_spin + sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
  return priorities




#score: {'data3D.txt': -0.36309820000000004}
#island_id: 1
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] += -1 + total_spin
        if i < N//2:
          if k % 2 == 0 and j < N//2:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#island_id: 1
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j].sum()
      site_nbr = (i + ((j-1)%N - N//2)) % N
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N+site_nbr][0] += abs(total_spin)
        priorities[i*N*N+j*N+site_nbr][1] -= total_spin
      else:
        priorities[i*N*N+j*N+site_nbr][0] -= abs(total_spin)
        priorities[i*N*N+j*N+site_nbr][1] = total_spin
  return(priorities)




#score: {'data3D.txt': 0.0589178}
#island_id: 1
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] += 1 - total_spin
  return(priorities)




#score: {'data3D.txt': 0.1658198}
#island_id: 0
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff + hamming_distance)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin - hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff + hamming_distance)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin - hamming_distance)
  return(priorities)




#score: {'data3D.txt': -0.002450600000000018}
#island_id: 0
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - 3 * hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - 3 * hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - 2 * sum(1 for val in interacting_spins if val > 0)
        if site_nbr != i:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.23168540000000007}
#island_id: 1
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_x = sum(J[0,i,j,k] for d in [0,1])
        total_spin_y = sum(J[3,i,j,k] for d in [3,4])
        total_spin_z = sum(J[5,i,j,k] for d in [5,2])
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] -= total_spin_x + total_spin_y + total_spin_z - 2
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y - total_spin_z + 2
  return(priorities)




#score: {'data3D.txt': -0.27548220000000034}
#island_id: 1
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin
          priorities[i*N*N+j*N+k][1] = -3 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.27548220000000034}
#island_id: 1
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)) + np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)) + np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)) + np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)) + np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.2656402000000003}
#island_id: 1
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priority_coeff_total = np.exp(-np.abs(total_spin_x + total_spin_y + total_spin_z) * (priority_coeff_x + priority_coeff_y + priority_coeff_z))
          priorities[i*N*N+j*N+k][0] += priority_coeff_total
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priority_coeff_total = np.exp(np.abs(total_spin_x + total_spin_y + total_spin_z) * (priority_coeff_x + priority_coeff_y + priority_coeff_z))
          priorities[i*N*N+j*N+k][0] -= priority_coeff_total
          priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#island_id: None
#version_generated: None
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.207447}
#standard deviation: 0.04523750557888886
#island_id: 0
#version_generated: 3
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(energy_diff < N/4, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(energy_diff < N/4, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.09311459999999999}
#standard deviation: 0.0456762505777346
#island_id: 0
#version_generated: 3
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          energy_diff = abs(site_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(site_energy, 0) * (energy_diff < N/4)
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          energy_diff = abs(site_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(site_energy, 0) * (energy_diff < N/4)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.002664999999999991}
#standard deviation: 0.04464682177938313
#island_id: 0
#version_generated: 3
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.25875660000000006}
#standard deviation: 0.04484441901106535
#island_id: 0
#version_generated: 3
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          energy_diff = abs(spin_energy - total_spin)
          priority_coeff = max(0, (total_spin + spin_energy) / 2) * magnetism_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff * max(energy_diff < N/4, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          energy_diff = abs(spin_energy + total_spin)
          priority_coeff = max(0, (total_spin - spin_energy) / 2) * magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff * max(energy_diff < N/4, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_diff = abs(sum(val for val in interacting_spins if val < 0) - total_spin)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(energy_diff < N/4, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_diff = abs(sum(val for val in interacting_spins if val > 0) - total_spin)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(energy_diff < N/4, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.45895460000000005}
#standard deviation: 0.040311299394090484
#island_id: 0
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_diff = np.abs(total_spin) - 1
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-energy_diff)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance + total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_diff = np.abs(total_spin) + 1
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-energy_diff)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance - total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.207447}
#standard deviation: 0.04523750557888886
#island_id: 0
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(energy_diff < N/4, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(energy_diff < N/4, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.190507}
#standard deviation: 0.04646465184417075
#island_id: 0
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(energy_diff < N/4, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          spin_energy = sum(val for val in interacting_spins if val > 0)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          energy_diff = abs(spin_energy - 2*total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(energy_diff < N/4, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += 1 + total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] += 1 - total_spin

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_total = total_spin + np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][0] += 1 + priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - priority_total
        else:
          priority_total = -total_spin - np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= 1 + priority_total
          priorities[i*N*N+j*N+k][1] += 1 - priority_total

  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.04627020000000001}
#standard deviation: 0.04524153569409421
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = magnetism_coeff + total_spin + abs(sum(val for val in interacting_spins if val > 0)) - len([val for val in interacting_spins if val < 0])
          priority_down = -1 + 2*total_spin - sum(val for val in interacting_spins if val < 0) - sum(val for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -magnetism_coeff - total_spin + abs(sum(val for val in interacting_spins if val < 0)) - len([val for val in interacting_spins if val > 0])
          priority_down = -1 - 2*total_spin + sum(val for val in interacting_spins if val > 0) + sum(val for val in interacting_spins if val < 0)
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)




#score: {'data3D.txt': -0.5147146}
#standard deviation: 0.04057596365879682
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_neighbors_2 = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff_2 = np.exp(-abs(total_spin) * (len([val for val in site_neighbors_2 if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff_2
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors_2 if val < 0)

  return(priorities)




#score: {'data3D.txt': 0.14820060000000002}
#standard deviation: 0.04350663627126327
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = magnetism_coeff + total_spin + abs(sum(val for val in interacting_spins if val > 0)) - len([val for val in interacting_spins if val < 0])
          priority_down = -1 + 2*total_spin - sum(val for val in interacting_spins if val < 0) - sum(val for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -magnetism_coeff - total_spin + abs(sum(val for val in interacting_spins if val < 0)) - len([val for val in interacting_spins if val > 0])
          priority_down = -1 - 2*total_spin + sum(val for val in interacting_spins if val > 0) + sum(val for val in interacting_spins if val < 0)
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += priority_up + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] += priority_down - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.22839780000000037}
#standard deviation: 0.04496567174145183
#island_id: 1
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin - np.mean(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -total_spin + np.mean(interacting_spins)
  return(priorities)




#score: {'data3D.txt': 0.16827019999999987}
#standard deviation: 0.04716776941895813
#island_id: 1
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * np.exp(-np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= total_spin - 1 + np.count_nonzero(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * np.exp(-np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -total_spin + 1 - np.count_nonzero(interacting_spins)

  return(priorities)




#score: {'data3D.txt': 0.1839626}
#standard deviation: 0.04653361624933098
#island_id: 1
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * priority_coeff + 2 * np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * priority_coeff - 2 * np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -total_spin + 1
  return(priorities)




#score: {'data3D.txt': -0.5213745999999999}
#standard deviation: 0.039560239064495045
#island_id: 2
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.23355700000000013}
#standard deviation: 0.05552813945199317
#island_id: 3
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.exp(-abs(total_spin))
        else:
          priority_total = abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 3
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = abs(total_spin) * magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -abs(total_spin) * magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += priority_total
        priorities[i*N*N+j*N+k][1] -= 2 * total_spin - 2 * priority_total

  return(priorities)




#score: {'data3D.txt': -0.4545854000000001}
#standard deviation: 0.046711930669155605
#island_id: 3
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4018386}
#standard deviation: 0.04726056950609038
#island_id: 3
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val < 0])), 1))
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + priority_total
        else:
          priority_total = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val > 0])), 1))
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - priority_total

  return(priorities)




#score: {'data3D.txt': 0.1785258}
#standard deviation: 0.04404464978132985
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin)) * (total_spin + sum(1 for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin)) * (-total_spin + sum(1 for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.2736050000000002}
#standard deviation: 0.048667938676299
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff) * max(hamming_distance, 0)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin + hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff) * max(hamming_distance, 0)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin + hamming_distance)
  return(priorities)




#score: {'data3D.txt': -0.33343060000000024}
#standard deviation: 0.046397852360211676
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin + hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin + hamming_distance)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_coeff * np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= priority_coeff * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -priority_coeff * np.count_nonzero(np.array(interacting_spins) < 0)
  return(priorities)




#score: {'data3D.txt': -0.1931006000000001}
#standard deviation: 0.046712648390344995
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin + hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin + hamming_distance)
  return(priorities)




#score: {'data3D.txt': 0.3870422000000001}
#standard deviation: 0.04249799264859459
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin - magnetism_coeff
        
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.16870259999999998}
#standard deviation: 0.04345498904889978
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin - magnetism_coeff
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.2176334}
#standard deviation: 0.05079041606878211
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin - magnetism_coeff

        if total_spin > 0:
          for d in range(3):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += 2
              priorities[i*N*N+j*N+k][1] -= 1
        else:
          for d in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= 2
              priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_diff = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] += spin_diff + total_spin
          priorities[i*N*N+j*N+k][1] -= spin_diff - total_spin
        else:
          spin_diff = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= spin_diff + total_spin
          priorities[i*N*N+j*N+k][1] = -spin_diff - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          total_priority = 2*magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          total_priority = -2*magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': 0.2505002}
#standard deviation: 0.04202776605959446
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': 0.2505002}
#standard deviation: 0.04202776605959446
#island_id: 1
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': -0.0258178}
#standard deviation: 0.04608975811565949
#island_id: 3
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
            priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
            priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          if hamming_distance < 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
            priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
            priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)

  return(priorities)




#score: {'data3D.txt': -0.10499340000000001}
#standard deviation: 0.044143203287029364
#island_id: 3
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priority_config = [magnetism_coeff * site_magnetism + 2, -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priority_config = [-magnetism_coeff * site_magnetism + 2, -2 - magnetism_coeff * (abs(total_spin) - site_magnetism)]

        # Consider mirrored spins
        for config in [[-val for val in config] for config in [priority_config, list(reversed(priority_config))]]:
          if config[0] > config[1]:
            priorities[i*N*N+j*N+k][0] += config[0]
            priorities[i*N*N+j*N+k][1] -= config[1]
          else:
            priorities[i*N*N+j*N+k][0] -= config[0]
            priorities[i*N*N+j*N+k][1] = -config[1]

  return(priorities)




#score: {'data3D.txt': 0.18196060000000028}
#standard deviation: 0.046368553219180784
#island_id: 3
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priority_config = [magnetism_coeff * site_magnetism + 2, -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priority_config = [-magnetism_coeff * site_magnetism + 2, -2 - magnetism_coeff * (abs(total_spin) - site_magnetism)]

        # Consider mirrored spins
        for config in [[-val for val in config] for config in [priority_config, list(reversed(priority_config))]]:
          if config[0] > config[1]:
            priorities[i*N*N+j*N+k][0] += config[0]
            priorities[i*N*N+j*N+k][1] -= config[1]
          else:
            priorities[i*N*N+j*N+k][0] -= config[0]
            priorities[i*N*N+j*N+k][1] = -config[1]

        # Consider frustrated spins
        for d in range(6):
          if J[d,i,j,k] < 0 and h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
          elif J[d,i,j,k] > 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0015161999999999994}
#standard deviation: 0.04870529640152085
#island_id: 3
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priority_config = [magnetism_coeff * site_magnetism + 2, -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priority_config = [-magnetism_coeff * site_magnetism + 2, -2 - magnetism_coeff * (abs(total_spin) - site_magnetism)]

        # Consider mirrored spins
        for config in [[-val for val in config] for config in [priority_config, list(reversed(priority_config))]]:
          if config[0] > config[1]:
            priorities[i*N*N+j*N+k][0] += config[0]
            priorities[i*N*N+j*N+k][1] -= config[1]
          else:
            priorities[i*N*N+j*N+k][0] -= config[0]
            priorities[i*N*N+j*N+k][1] = -config[1]

        # Consider site interactions
        for d in range(6):
          if J[d,i,j,k] < 0:
            priority_total = abs(total_spin) * 2 + 3
          else:
            priority_total = abs(total_spin) * 2 - 1

          priorities[i*N*N+j*N+k][0] += (-priority_total + total_spin)
          priorities[i*N*N+j*N+k][1] -= (-priority_total - total_spin)

  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 1
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 1
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 1
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.19616860000000028}
#standard deviation: 0.046195440619610936
#island_id: 1
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority = total_spin + magnetism_coeff + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority = -total_spin - magnetism_coeff - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] = priority
        priorities[i*N*N+j*N+k][1] = -2*priority

  return(priorities)




#score: {'data3D.txt': 0.4718002}
#standard deviation: 0.04303473991974391
#island_id: 1
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority_coeff = total_spin + magnetism_coeff + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += 2*priority_coeff
          priorities[i*N*N+j*N+k][1] -= 3*priority_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority_coeff = -total_spin - magnetism_coeff - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= 2*priority_coeff
          priorities[i*N*N+j*N+k][1] += 3*priority_coeff
  return(priorities)




#score: {'data3D.txt': -0.26438380000000006}
#standard deviation: 0.04408560238399834
#island_id: 1
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
  return(priorities)




#score: {'data3D.txt': -0.34335779999999966}
#standard deviation: 0.04505113737920497
#island_id: 1
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[2,i,j,k], J[3,(i+1)%N,j,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.34344579999999963}
#standard deviation: 0.044674295320239796
#island_id: 1
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.5008490000000002}
#standard deviation: 0.0420183079026274
#island_id: 1
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5008490000000002}
#standard deviation: 0.0420183079026274
#island_id: 1
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0544702}
#standard deviation: 0.04566518490009648
#island_id: 0
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.10340819999999999}
#standard deviation: 0.04389165356602551
#island_id: 0
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.2275422000000001}
#standard deviation: 0.047042742895796366
#island_id: 0
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.4078266}
#standard deviation: 0.041060209113447044
#island_id: 0
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + hamming_distance) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + hamming_distance) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.34832220000000025}
#standard deviation: 0.04562281520423745
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.3330878}
#standard deviation: 0.0425873052817386
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.3330878}
#standard deviation: 0.0425873052817386
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.00658499999999999}
#standard deviation: 0.047931913116419624
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
        for d in range(3):
          if i!=N-1 and J[d,i,j,k]*h[(i+1)%N,j,k]: 
            total_spin += 1
          if j!=N-1 and J[0,i,(j+1)%N,k]*h[i,N-1,k]: 
            total_spin -= 1
        priorities[i*N*N+j*N+k][0] += abs(total_spin)
        priorities[i*N*N+j*N+k][1] -= abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.030954599999999773}
#standard deviation: 0.0468193880656294
#island_id: 2
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_sum = sum(val for val in interacting_spins if val < 0) + total_spin
          spin_diff = abs(spin_sum)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + spin_diff
  return(priorities)




#score: {'data3D.txt': -0.2169469999999999}
#standard deviation: 0.04429559742231727
#island_id: 2
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          magnetism_coeff = np.exp(-total_spin_magnitude * (abs(sum(val for val in interacting_spins if val < 0)) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - total_spin + spin_diff)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          magnetism_coeff = np.exp(-total_spin_magnitude * (abs(sum(val for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (-1 + total_spin + spin_diff)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.0024918000000000006}
#standard deviation: 0.047006918775431346
#island_id: 2
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + spin_diff

        return(priorities)




#score: {'data3D.txt': -0.19616860000000028}
#standard deviation: 0.046195440619610936
#island_id: 1
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority = total_spin + magnetism_coeff + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority = -total_spin - magnetism_coeff - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] = priority
        priorities[i*N*N+j*N+k][1] = -2*priority

  return(priorities)




#score: {'data3D.txt': -0.19327100000000025}
#standard deviation: 0.046212893860912894
#island_id: 1
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority = total_spin + magnetism_coeff + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority = -total_spin - magnetism_coeff - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] = priority
        priorities[i*N*N+j*N+k][1] = -2*priority

  return(priorities)




#score: {'data3D.txt': -0.40871300000000005}
#standard deviation: 0.04083427470887661
#island_id: 1
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*magnetism_coeff + hamming_distance / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - 2*magnetism_coeff - hamming_distance / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.26371980000000006}
#standard deviation: 0.04791522021195354
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority = total_spin + magnetism_coeff + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) + abs(sum(J[2,i,j,k] for j in range(N)))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority = -total_spin - magnetism_coeff - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + abs(sum(J[2,i,j,k] for j in range(N)))
        priorities[i*N*N+j*N+k][0] = priority
        priorities[i*N*N+j*N+k][1] = -2*priority

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.20751820000000024}
#standard deviation: 0.04465128160265951
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        site_nbr_magnetism = h[site_nbr, j, k]
        if site_nbr_magnetism > 0:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_priority_coeff
        else:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= site_priority_coeff
  return(priorities)




#score: {'data3D.txt': -0.22829580000000027}
#standard deviation: 0.04432190409222059
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.20751820000000024}
#standard deviation: 0.04465128160265951
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        site_nbr_magnetism = h[site_nbr, j, k]
        if site_nbr_magnetism > 0:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_priority_coeff
        else:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= site_priority_coeff
  return(priorities)




#score: {'data3D.txt': -0.20751820000000024}
#standard deviation: 0.04465128160265951
#island_id: 0
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        site_nbr_magnetism = h[site_nbr, j, k]
        if site_nbr_magnetism > 0:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_priority_coeff
        else:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= site_priority_coeff
  return(priorities)




#score: {'data3D.txt': 0.088103}
#standard deviation: 0.04160427563364131
#island_id: 3
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0 and interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0 and interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

        # Additional term to improve the algorithm (based on the idea that if there are more than one neighboring spins aligned in the same direction, it is better to align with them):
        adjacent_spins = [J[d,i,(j+1)%N,k] for d in range(6)] + [J[d,i,(j-1)%N,k] for d in range(6)]
        if h[i][j][k] > 0:
          aligned_spins = sum([val > 0 for val in adjacent_spins])
          priorities[i*N*N+j*N+k][0] += aligned_spins
        else:
          aligned_spins = sum([val < 0 for val in adjacent_spins])
          priorities[i*N*N+j*N+k][1] -= aligned_spins

  return(priorities)




#score: {'data3D.txt': -0.17362100000000016}
#standard deviation: 0.04594112753296332
#island_id: 3
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0 and interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0 and interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

        # Further improvement:
        if h[i][j][k] > 0:
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= 2
          elif all(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][1] += 2
        else:
          if all(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][1] -= 2
          elif all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.2153486000000002}
#standard deviation: 0.04474278621230466
#island_id: 3
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0 and interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0 and interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

        # Additional term to improve the algorithm (new):
        if h[i][j][k] > 0:
          for d in range(6):
            if J[d, i, j, k] < 0 and np.all(J[:(d+1), i, j, k] < 0):
              priorities[i*N*N+j*N+k][0] += 2
              break
            elif J[d, i, j, k] > 0 and np.all(J[:d, i, j, k] > 0):
              priorities[i*N*N+j*N+k][1] -= 2
              break

  return(priorities)




#score: {'data3D.txt': 0.16638380000000036}
#standard deviation: 0.047678307201074153
#island_id: 3
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0 and interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0 and interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][1] += 2
          elif interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

        # Additional term to improve the algorithm:
        if h[i][j][k] > 0:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][1] += 2
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': 0.034488200000000004}
#standard deviation: 0.0464332400415909
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = 1 + total_spin
  return(priorities)




#score: {'data3D.txt': 0.19311260000000002}
#standard deviation: 0.0481234329743837
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins_sum = sum(val for val in interacting_spins if val < 0)
          spin_diff = abs(total_spin) - sum(abs(val) for val in interacting_spins)
          magnetism_coeff = np.exp(-abs(total_spin) * (interacting_spins_sum / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2 - total_spin + spin_diff)
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(val for val in interacting_spins if val < 0)
        else:
          interacting_spins_sum = sum(val for val in interacting_spins if val > 0)
          spin_diff = -abs(total_spin) - sum(abs(val) for val in interacting_spins)
          magnetism_coeff = np.exp(-abs(total_spin) * (interacting_spins_sum / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (-2 + total_spin + spin_diff)
          priorities[i*N*N+j*N+k][1] = -2*total_spin + sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': 0.10886180000000002}
#standard deviation: 0.05152875993811611
#island_id: 2
#version_generated: 3
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin + sum(abs(val) for val in interacting_spins if val < 0)
        else:
          priority_total = np.sum(interacting_spins) - total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -2 * total_spin + sum(abs(val) for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.23548419999999998}
#standard deviation: 0.048761891578977944
#island_id: 2
#version_generated: 3
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism

  return(priorities)




#score: {'data3D.txt': -0.2352962}
#standard deviation: 0.049896340402478416
#island_id: 2
#version_generated: 3
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) + total_spin_magnitude / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) + total_spin_magnitude / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.1957498}
#standard deviation: 0.04908269022741113
#island_id: 2
#version_generated: 3
#generate time11:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': 0.13278020000000026}
#standard deviation: 0.04848240472542592
#island_id: 2
#version_generated: 3
#generate time11:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (abs(total_spin) + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (abs(total_spin) + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism

  return(priorities)




#score: {'data3D.txt': -0.23168540000000007}
#standard deviation: 0.04615280042250958
#island_id: 1
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_x = sum(J[0,i,j,k] for d in [0,1])
        total_spin_y = sum(J[3,i,j,k] for d in [3,4])
        total_spin_z = sum(J[5,i,j,k] for d in [5,2])
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] -= total_spin_x + total_spin_y + total_spin_z - 2
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y - total_spin_z + 2
  return(priorities)




#score: {'data3D.txt': -0.03162060000000007}
#standard deviation: 0.049652069600772945
#island_id: 1
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.1597606}
#standard deviation: 0.043108487419996545
#island_id: 1
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] -= total_spin_x + total_spin_y + total_spin_z - 2
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y - total_spin_z + 2
  return(priorities)




#score: {'data3D.txt': -0.27143860000000003}
#standard deviation: 0.05203629800475818
#island_id: 3
#version_generated: 3
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 3)
          priorities[i*N*N+j*N+k][1] = (priority_total / 3)
        else:
          priority_total = np.sum([j for j in interacting_spins if j < 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 2)
          priorities[i*N*N+j*N+k][1] = (priority_total / 2)
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * priority_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)

  return(priorities)




#score: {'data3D.txt': -0.25069299999999994}
#standard deviation: 0.04447643365873663
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.07019819999999999}
#standard deviation: 0.04593927510050632
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.31415819999999994}
#standard deviation: 0.04396305417916276
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': 0.4288834000000002}
#standard deviation: 0.042879366185147844
#island_id: 3
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + total_spin
          priorities[i*N*N+j*N+k][1] -= np.sum(interacting_spins) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + total_spin
          priorities[i*N*N+j*N+k][1] = -np.sum(interacting_spins) - total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= np.count_nonzero([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) - abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -np.count_nonzero([val for val in interacting_spins if val > 0]) + total_spin
  return(priorities)




#score: {'data3D.txt': -0.10762100000000006}
#standard deviation: 0.051813874580077496
#island_id: 3
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  for i in range(N):
    for j in range(N):
      if h[i, j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.173995}
#standard deviation: 0.04895637338488218
#island_id: 2
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) * (hamming_distance > 0.5)

  return(priorities)




#score: {'data3D.txt': -0.1522426}
#standard deviation: 0.049709194172104613
#island_id: 2
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.1522426}
#standard deviation: 0.049709194172104613
#island_id: 2
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.1522426}
#standard deviation: 0.049709194172104613
#island_id: 2
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetization = sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0]) + site_magnetization
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) - site_magnetization
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetization = sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0]) - site_magnetization
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) + site_magnetization

  return(priorities)




#score: {'data3D.txt': -0.37363659999999993}
#standard deviation: 0.04197760046072191
#island_id: 2
#version_generated: 3
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional consideration of the 6 neighboring sites along each axis
        for l in range(3):
          site_nbr_6 = (i + ((k-1)%2 - 1)) % N
          interacting_spins_6 = [J[d][site_nbr_6][j][k] for d in range(6)]
          total_spin_6 = sum(J[d][site_nbr_6][j][k] for d in range(3)) + h[site_nbr_6][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_6

  return(priorities)




#score: {'data3D.txt': -0.4353262}
#standard deviation: 0.041170362562892256
#island_id: 2
#version_generated: 3
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(3,6):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.27698979999999995}
#standard deviation: 0.053020582569036336
#island_id: 2
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          neighboring_site = J[d][i][j][k]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (neighboring_site < 0))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (neighboring_site > 0))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.44988819999999996}
#standard deviation: 0.04182918144979651
#island_id: 2
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.20271140000000007}
#standard deviation: 0.04736004845901237
#island_id: 3
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_up_coeff = np.sum([spin < 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += spin_up_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_down_coeff = np.sum([spin > 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= spin_down_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.15678780000000006}
#standard deviation: 0.04507336565156856
#island_id: 3
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_up_coeff = np.sum([spin < 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_up_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_down_coeff = np.sum([spin > 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_down_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.332537}
#standard deviation: 0.044455907942589586
#island_id: 3
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        spin_up_coeff = sum(spin < 0 for spin in interacting_spins)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_up_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.2690594000000001}
#standard deviation: 0.05537596041280007
#island_id: 3
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_up_coeff = np.sum([spin < 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_up_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_down_coeff = np.sum([spin > 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_down_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.10735259999999999}
#standard deviation: 0.044110601370192175
#island_id: 0
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          
          # Calculate the total priority coefficient
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          
          # Calculate the total priority coefficient
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  
  return(priorities)




#score: {'data3D.txt': -0.0610126}
#standard deviation: 0.05477418553698448
#island_id: 0
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = (total_spin * sum(1 for val in interacting_spins if val > 0) + 
                    abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(val for val in interacting_spins if val > 0)
        else:
          priority_coeff = -(total_spin * sum(1 for val in interacting_spins if val < 0) + 
                    abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin - sum(val for val in interacting_spins if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.0942282}
#standard deviation: 0.0465222205484648
#island_id: 0
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0942282}
#standard deviation: 0.0465222205484648
#island_id: 0
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)




#score: {'data3D.txt': 0.31317620000000024}
#standard deviation: 0.05148098399953132
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          
          total_spin_weight = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val < 0])), 1))
          priorities[i*N*N+j*N+k][0] += total_spin_weight * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_weight
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          
          total_spin_weight = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val > 0])), 1))
          priorities[i*N*N+j*N+k][0] -= total_spin_weight * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin_weight
  
  return(priorities)




#score: {'data3D.txt': 0.3556026000000002}
#standard deviation: 0.04926095038912668
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val < 0])), 1))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + hamming_distance * (abs(total_spin) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val > 0])), 1))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + hamming_distance * (abs(total_spin) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.411985}
#standard deviation: 0.039166755992805946
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val < 0])), 1))
          magnetism_coeff = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + priority_total + magnetism_coeff
        else:
          priority_total = np.exp(-abs(total_spin) / max(abs(sum([val for val in interacting_spins if val > 0])), 1))
          magnetism_coeff = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - priority_total - magnetism_coeff

  return(priorities)




#score: {'data3D.txt': 0.31317620000000024}
#standard deviation: 0.05148098399953132
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.1929694}
#standard deviation: 0.04591063214158569
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin += np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin * magnetism_coeff + (abs(total_spin) * (1-magnetism_coeff))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin -= np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = -(abs(total_spin) * (1-magnetism_coeff)) + total_spin

  return(priorities)




#score: {'data3D.txt': -0.1929694}
#standard deviation: 0.04591063214158569
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin += np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin -= np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
 
  return(priorities)




#score: {'data3D.txt': 0.0453662}
#standard deviation: 0.046209194080399196
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
  return(priorities)




#score: {'data3D.txt': 0.0453662}
#standard deviation: 0.046209194080399196
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total

  return(priorities)




#score: {'data3D.txt': -0.0243098}
#standard deviation: 0.04821113547677549
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin - len([val for val in interacting_spins if val < 0]) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = total_spin + len([val for val in interacting_spins if val > 0]) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total

  return(priorities)




#score: {'data3D.txt': 0.0453662}
#standard deviation: 0.046209194080399196
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total

  return(priorities)




#score: {'data3D.txt': -0.27095620000000004}
#standard deviation: 0.048525033967633656
#island_id: 2
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

  # new code here
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N].sum()
    if total_spin > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.28857380000000016}
#standard deviation: 0.04322832212288606
#island_id: 0
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # Additional logic to improve the priority function
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * abs(total_spin)
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.2523834000000002}
#standard deviation: 0.04358739088819151
#island_id: 0
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - abs(total_spin) * np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.25147660000000027}
#standard deviation: 0.04382431211599334
#island_id: 0
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + np.exp(-np.abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) + np.exp(-np.abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.46536540000000004}
#standard deviation: 0.03941726681087871
#island_id: 0
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - np.sum(np.abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - np.sum(np.abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.24744300000000008}
#standard deviation: 0.04390230188725872
#island_id: 0
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.24744300000000008}
#standard deviation: 0.04390230188725872
#island_id: 0
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.006173000000000277}
#standard deviation: 0.04805628648782593
#island_id: 0
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) > 0.5))
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.25427900000000025}
#standard deviation: 0.04483554883125666
#island_id: 0
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)




#score: {'data3D.txt': -0.34205060000000004}
#standard deviation: 0.04966114255270412
#island_id: 0
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - np.sum(np.abs(J[:,i,j,k]))
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - np.sum(np.abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # Add interactions with neighboring sites
        for d in [0,1,2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          interacting_spins.append(J[d,i,j,k])
          total_spin += J[d,i,j,k]
        if h[i][j][k] > 0:
          priority_coeff += total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff -= total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.31363739999999984}
#standard deviation: 0.04556072169358162
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                             J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                             J[0,(i+1)%N,(j+1)%N,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.39059300000000013}
#standard deviation: 0.04532076423671605
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - abs(sum(J[2,i,j,k] for i in range(N)))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - abs(sum(J[2,i,j,k] for i in range(N)))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.005258200000000059}
#standard deviation: 0.045505729889322735
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + hamming_distance
        site_spin = h[i][j][k]
        if J[0,i,j,k] > 0:
          interacting_spins.append(J[0,i,j,k])
        else:
          interacting_spins.insert(0, J[0,i,j,k])
        interacting_spins.sort()
        hamming_distance = sum(1 for val in interacting_spins if val < 0)
        priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
        priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
        priorities[i*N*N+j*N+k][1] = -1 + total_spin + hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.2353082000000001}
#standard deviation: 0.046685851526559956
#island_id: 1
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        for d in range(3,6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.30708539999999995}
#standard deviation: 0.047304427983435114
#island_id: 1
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] += abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          priorities[i*N*N+j*N+k][0] -= abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
        for d in range(6):
          if J[d,i,j,k] > 0:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += 2
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= 2
              priorities[i*N*N+j*N+k][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.5169162000000002}
#standard deviation: 0.04223585464460261
#island_id: 1
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - priority_total
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - priority_total
        
  return(priorities)




#score: {'data3D.txt': -0.3153782000000002}
#standard deviation: 0.04730377960332557
#island_id: 1
#version_generated: 3
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          for d in range(6):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(priority_total)
              priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          for d in range(6):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(priority_total)
              priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.04627020000000001}
#standard deviation: 0.04524153569409421
#island_id: 2
#version_generated: 3
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = magnetism_coeff + total_spin + abs(sum(val for val in interacting_spins if val > 0)) - len([val for val in interacting_spins if val < 0])
          priority_down = -1 + 2*total_spin - sum(val for val in interacting_spins if val < 0) - sum(val for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -magnetism_coeff - total_spin + abs(sum(val for val in interacting_spins if val < 0)) - len([val for val in interacting_spins if val > 0])
          priority_down = -1 - 2*total_spin + sum(val for val in interacting_spins if val > 0) + sum(val for val in interacting_spins if val < 0)
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': 0.006605399999999999}
#standard deviation: 0.04627444403599032
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i+1)%N - 1)) % N
        total_spin_x = sum(J[0,i,j,k] for d in [0,1])
        total_spin_y = sum(J[3,i,j,k] for d in [3,4])
        total_spin_z = sum(J[5,i,j,k] for d in [5,2])
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          site_magnetism_x = (h[site_nbr_x][j][k] > 0)
          site_magnetism_y = (h[i][site_nbr_y][k] > 0)
          site_magnetism_z = (h[i][j][site_nbr_z] > 0)
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          if site_magnetism_x and site_magnetism_y and site_magnetism_z:
            priorities[i*N*N+j*N+k][1] -= total_spin_x + total_spin_y + total_spin_z - 2
          elif not (site_magnetism_x or site_magnetism_y or site_magnetism_z):
            priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y - total_spin_z + 2
          else:
            priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
            if site_magnetism_x and site_magnetism_y and not site_magnetism_z:
              priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y + 2
            elif not (site_magnetism_x or site_magnetism_y) and site_magnetism_z:
              priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_z + 2
            else:
              priorities[i*N*N+j*N+k][1] = -total_spin_y - total_spin_z + 2
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          site_magnetism_x = (h[site_nbr_x][j][k] > 0)
          site_magnetism_y = (h[i][site_nbr_y][k] > 0)
          site_magnetism_z = (h[i][j][site_nbr_z] > 0)
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
          if site_magnetism_x and site_magnetism_y and site_magnetism_z:
            priorities[i*N*N+j*N+k][1] = total_spin_x + total_spin_y + total_spin_z - 2
          elif not (site_magnetism_x or site_magnetism_y or site_magnetism_z):
            priorities[i*N*N+j*N+k][1] = total_spin_x + total_spin_y + total_spin_z - 2
          else:
            priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3
            if site_magnetism_x and site_magnetism_y and not site_magnetism_z:
              priorities[i*N*N+j*N+k][1] = total_spin_x + total_spin_y - 2
            elif not (site_magnetism_x or site_magnetism_y) and site_magnetism_z:
              priorities[i*N*N+j*N+k][1] = total_spin_x + total_spin_z - 2
            else:
              priorities[i*N*N+j*N+k][1] = total_spin_y + total_spin_z - 2
  return(priorities)




#score: {'data3D.txt': -0.31415819999999994}
#standard deviation: 0.04396305417916276
#island_id: 2
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.40338019999999997}
#standard deviation: 0.04096994176173552
#island_id: 2
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = 0.8 + 0.2 * (abs(total_spin) + sum(val for val in interacting_spins if val != 0)) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = 0.8 + 0.2 * (abs(total_spin) + sum(val for val in interacting_spins if val != 0)) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)




#score: {'data3D.txt': -0.31415819999999994}
#standard deviation: 0.04396305417916276
#island_id: 2
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': 0.08447779999999977}
#standard deviation: 0.04194095834813506
#island_id: 3
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) + 1
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) + 1
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.48181699999999994}
#standard deviation: 0.04309001451612659
#island_id: 2
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': 0.3839966}
#standard deviation: 0.04436116081033048
#island_id: 2
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_sum = magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_sum
          priorities[i*N*N+j*N+k][1] -= priority_sum
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_sum = magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_sum
          priorities[i*N*N+j*N+k][1] = -priority_sum

  return(priorities)




#score: {'data3D.txt': -0.36385619999999996}
#standard deviation: 0.04454718758305624
#island_id: 2
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(h[i][j][k]) > 0.5:
          if np.sum(interacting_spins) > 0:
            priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5081270000000001}
#standard deviation: 0.04254251321913176
#island_id: 2
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3136978}
#standard deviation: 0.042404558188477805
#island_id: 1
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          for d in range(6):
            site = [i, j, k]
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          for d in range(6):
            site = [i, j, k]
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)




#score: {'data3D.txt': -0.39918339999999997}
#standard deviation: 0.04198057841955015
#island_id: 2
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional consideration of the 6 neighboring sites along each axis
        for l in range(3):
          site_nbr_6 = (i + ((k-1)%2 - 1)) % N
          interacting_spins_6 = [J[d][site_nbr_6][j][k] for d in range(6)]
          total_spin_6 = sum(J[d][site_nbr_6][j][k] for d in range(3)) + h[site_nbr_6][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_6

        # Consider the impact of neighboring sites on magnetism
        for d in range(3):
          site_neighbors_magnetism = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism = sum(val < 0 for val in site_neighbors_magnetism) / max(len(site_neighbors_magnetism), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (neighbor_magnetism > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors_magnetism if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.37363659999999993}
#standard deviation: 0.04197760046072191
#island_id: 2
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional consideration of the 6 neighboring sites along each axis
        for l in range(3):
          site_nbr_6 = (i + ((k-1)%2 - 1)) % N
          interacting_spins_6 = [J[d][site_nbr_6][j][k] for d in range(6)]
          total_spin_6 = sum(J[d][site_nbr_6][j][k] for d in range(3)) + h[site_nbr_6][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_6

  return(priorities)




#score: {'data3D.txt': -0.37363659999999993}
#standard deviation: 0.04197760046072191
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional consideration of the 6 neighboring sites along each axis
        for l in range(3):
          site_nbr_6 = (i + ((k-1)%2 - 1)) % N
          interacting_spins_6 = [J[d][site_nbr_6][j][k] for d in range(6)]
          total_spin_6 = sum(J[d][site_nbr_6][j][k] for d in range(3)) + h[site_nbr_6][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_6

  return(priorities)




#score: {'data3D.txt': -0.3912922000000002}
#standard deviation: 0.044169693899324236
#island_id: 1
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.1475502}
#standard deviation: 0.049394646268193884
#island_id: 1
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin + np.sum(interacting_spins)
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] += abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = -total_spin + np.sum(interacting_spins)
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          priorities[i*N*N+j*N+k][0] -= abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)




#score: {'data3D.txt': -0.09214860000000004}
#standard deviation: 0.04729225346756063
#island_id: 1
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 + total_spin
          if abs(total_spin) > N:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 - total_spin
          if abs(total_spin) > N:
            priorities[i*N*N+j*N+k][1] = 2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': -0.035446600000000064}
#standard deviation: 0.0496458637596326
#island_id: 1
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  for i in range(N):
    for j in range(N):
      if h[0][j][k] > 0:
        priorities[j*N+k][0] += 1
        priorities[j*N+k][1] -= 1
      else:
        priorities[j*N+k][0] -= 1
        priorities[j*N+k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.03162060000000007}
#standard deviation: 0.049652069600772945
#island_id: 1
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) + np.std(interacting_spins_x)))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) + np.std(interacting_spins_y)))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) + np.std(interacting_spins_z)))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) + np.std(interacting_spins_x)))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) + np.std(interacting_spins_y)))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) + np.std(interacting_spins_z)))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.03162060000000007}
#standard deviation: 0.049652069600772945
#island_id: 1
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x, total_spin_y, total_spin_z = sum(interacting_spins_x), sum(interacting_spins_y), sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x, priority_coeff_y, priority_coeff_z = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)), np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)), np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = (total_spin_x + total_spin_y + total_spin_z) / 3
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff_x, priority_coeff_y, priority_coeff_z = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)), np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)), np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = (total_spin_x + total_spin_y + total_spin_z) / 3
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) / 3 - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.34344579999999963}
#standard deviation: 0.044674295320239796
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[3, i, j, k], J[3, i, (j+1)%N, k]]
        interacting_spins_z = [J[4, i, j, k], J[5, (i+1)%N, j, k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z
  return(priorities)




#score: {'data3D.txt': 0.06192580000000001}
#standard deviation: 0.054129998100498775
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(J[[0,3], i:i+2, j:j+1, k]) - np.sum(J[[4,5], i, j, :]) + 1
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(J[[0,3], i:i+2, j:j+1, k]) - np.sum(J[[4,5], i, j, :]) - 1
          priorities[i*N*N+j*N+k][1] = -total_spin - 1
  return(priorities)




#score: {'data3D.txt': -0.34346299999999963}
#standard deviation: 0.044636194181403945
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

  for i in range(N):
    site_nbr = (i + ((0-1)%2 - 1)) % N
    if h[site_nbr][j][k] > 0:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1
    else:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.34344579999999963}
#standard deviation: 0.044674295320239796
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
          
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.173995}
#standard deviation: 0.04895637338488218
#island_id: 2
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) * (hamming_distance > 0.5)

  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 2
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_diff = sum(val for val in interacting_spins if val < 0) - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + spin_diff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_diff = sum(val for val in interacting_spins if val > 0) - total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + spin_diff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - spin_diff
  return(priorities)




#score: {'data3D.txt': -0.173995}
#standard deviation: 0.04895637338488218
#island_id: 2
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) * (hamming_distance > 0.5)

  return(priorities)




#score: {'data3D.txt': -0.5048918000000001}
#standard deviation: 0.04208250197837577
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.2823798000000001}
#standard deviation: 0.0462883574126367
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.5178130000000001}
#standard deviation: 0.042415129741638184
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5178130000000001}
#standard deviation: 0.042415129741638184
#island_id: 3
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Calculate the priority based on the current spin
        if priorities[i*N*N+j*N+k][0] > priorities[i*N*N+j*N+k][1]:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        elif priorities[i*N*N+j*N+k][0] < priorities[i*N*N+j*N+k][1]:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 3
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.35333860000000034}
#standard deviation: 0.04664549485255784
#island_id: 3
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': 0.08447779999999977}
#standard deviation: 0.04194095834813506
#island_id: 3
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) + 1
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) + 1
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.2505002}
#standard deviation: 0.04202776605959446
#island_id: 1
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          long_range_coeff = np.sum(np.abs(J[3:,:,:,k]))
          priorities[i*N*N+j*N+k][0] += total_priority + long_range_coeff
          priorities[i*N*N+j*N+k][1] -= total_priority - long_range_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          long_range_coeff = np.sum(np.abs(J[3:,:,:,k]))
          priorities[i*N*N+j*N+k][0] -= total_priority + long_range_coeff
          priorities[i*N*N+j*N+k][1] = -total_priority - long_range_coeff

  return(priorities)




#score: {'data3D.txt': 0.2505002}
#standard deviation: 0.04202776605959446
#island_id: 1
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': 0.3743050000000003}
#standard deviation: 0.044358611959798726
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,(i+N//2)%N,j,(k+1)%N], J[4,(i-N//2)%N,j,k], J[5,(i+1)%N,(j-1)%N,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-np.sum(np.abs(interacting_spins)))
          total_priority = 2*magnetism_coeff + total_spin + np.sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          magnetism_coeff = np.exp(np.sum(np.abs(interacting_spins)))
          total_priority = -2*magnetism_coeff + total_spin - np.sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] += total_priority
  return(priorities)




#score: {'data3D.txt': 0.2505002}
#standard deviation: 0.04202776605959446
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': -0.2823798000000001}
#standard deviation: 0.0462883574126367
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.28327900000000017}
#standard deviation: 0.047322579378136165
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += 3*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= 3*total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.29879740000000005}
#standard deviation: 0.0459264432896779
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.2512086000000001}
#standard deviation: 0.04566737879537209
#island_id: 2
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val < 0]) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val > 0]) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism

  return(priorities)




#score: {'data3D.txt': -0.2512086000000001}
#standard deviation: 0.04566737879537209
#island_id: 2
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val < 0]) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val > 0]) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.12345460000000019}
#standard deviation: 0.04670787105874128
#island_id: 2
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - abs(neighbor_magnetism) - len([val for val in interacting_spins if val < 0]) * total_spin
            priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val < 0]) * total_spin
            priorities[i*N*N+j*N+k][1] -= -2*total_spin + sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val > 0]) * total_spin
            priorities[i*N*N+j*N+k][1] = 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin - abs(neighbor_magnetism) - len([val for val in interacting_spins if val > 0]) * total_spin
            priorities[i*N*N+j*N+k][1] = -2*total_spin + sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.5046602000000001}
#standard deviation: 0.04275373499426688
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,i,j,(k+1)%N], J[4,(i+1)%N,j,(k+1)%N], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': 0.14464940000000007}
#standard deviation: 0.04832685712561909
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  total_spin = np.zeros((N, N, N))  # Total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(6):
          total_spin[i,j,k] += J[d,i,j,k]*interacting_spins[d,i,j,k]
        
  site_nbr = np.zeros((N, N, N), dtype=int)  # Site number along each axis
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr[i,(j+1)%N,k] = (i + ((k-1)%2 - 1)) % N
        site_nbr[i,j,(k+1)%N] = (i + ((j-1)%2 - 1)) % N
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[site_nbr[i,j,k]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin[i,j,k]
          priorities[i*N*N+j*N+k][1] -= -2*h[site_nbr[i,j,k]][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin[i,j,k]
          priorities[i*N*N+j*N+k][1] = 2*h[site_nbr[i,j,k]][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.35333860000000034}
#standard deviation: 0.04664549485255784
#island_id: 3
#version_generated: 3
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.35333860000000034}
#standard deviation: 0.04664549485255784
#island_id: 3
#version_generated: 3
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0)) * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0)) * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35333860000000034}
#standard deviation: 0.04664549485255784
#island_id: 3
#version_generated: 3
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.35333860000000034}
#standard deviation: 0.04664549485255784
#island_id: 3
#version_generated: 3
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.3412933999999997}
#standard deviation: 0.04484590545902713
#island_id: 1
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

        for d in [0, 1, 2]:
          interacting_spins_d = [J[d,i,j,k], J[d,(i+1)%N,j,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_x) * np.mean(interacting_spins_d))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_x) * np.mean(interacting_spins_d))
            priorities[i*N*N+j*N+k][1] = -1 - total_spin_x

  return(priorities)




#score: {'data3D.txt': -0.3432573999999996}
#standard deviation: 0.04498803602336958
#island_id: 1
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

        for d in [0, 1, 2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.2941434}
#standard deviation: 0.04568938122189882
#island_id: 1
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.4627038}
#standard deviation: 0.041404650772105304
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins) + abs(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins) - abs(h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4210050000000003}
#standard deviation: 0.047795235065851496
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val > 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_ones + priority_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val < 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - priority_ones + priority_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4584886}
#standard deviation: 0.04452403160137231
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][site_nbr][k] > 0:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
      else:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.20198899999999997}
#standard deviation: 0.047313592116853695
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        priority_coeff = np.exp(-total_spin)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff + total_spin) * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff + total_spin) * priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5081062000000001}
#standard deviation: 0.042360788018638185
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4399790000000001}
#standard deviation: 0.04209447658541439
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.30104300000000006}
#standard deviation: 0.04912754778126015
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + 1)
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)




#score: {'data3D.txt': 0.08064580000000005}
#standard deviation: 0.048482364859400176
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + interaction_term
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': -0.2947066}
#standard deviation: 0.04015149158424877
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          neighbors_magnetism = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + interaction_term - neighbors_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - interaction_term + neighbors_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          neighbors_magnetism = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + interaction_term - neighbors_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin - interaction_term + neighbors_magnetism

  return(priorities)




#score: {'data3D.txt': -0.4011766}
#standard deviation: 0.042422211781565564
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(val for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + interaction_term
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(val for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': 0.06655420000000001}
#standard deviation: 0.048208822661002626
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([x * y for x, y in zip(interacting_spins, [1, -1, 1])])
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([x * y for x, y in zip(interacting_spins, [-1, 1, 1])])
          priorities[i*N*N+j*N+k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.0375686}
#standard deviation: 0.05195030331037539
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + 2*total_spin
          priorities[i*N*N+j*N+k][1] = -1 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + total_spin**2
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + total_spin**2
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.3167381999999999}
#standard deviation: 0.04462948600152146
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.15363539999999984}
#standard deviation: 0.0485717183846732
#island_id: 1
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * 0.5)
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in [0, 3]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.1438610000000001}
#standard deviation: 0.057428501625934845
#island_id: 1
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  # Add a global term to the priority function based on the magnetism at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(h[i][j][k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = np.exp(abs(h[i][j][k]))

  return(priorities)




#score: {'data3D.txt': -0.18118499999999993}
#standard deviation: 0.04734832177596161
#island_id: 1
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin_coeff - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*total_spin_coeff + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin_coeff - magnetism_coeff

        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3136978}
#standard deviation: 0.042404558188477805
#island_id: 1
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          for d in range(6):
            site = [i, j, k]
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          for d in range(6):
            site = [i, j, k]
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)




#score: {'data3D.txt': 0.2527282}
#standard deviation: 0.04537872546425252
#island_id: 1
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
        
        for d in range(6):
          site = [i, j, k]
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_nbrs.sort()
        for s in site_nbrs:
          if h[s//N][s%N][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -total_spin + 1
        
  return(priorities)




#score: {'data3D.txt': -0.5046602000000001}
#standard deviation: 0.04275373499426688
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,i,j,(k+1)%N], J[4,(i+1)%N,j,(k+1)%N], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.48646140000000004}
#standard deviation: 0.04214764370685508
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,i,j,(k+1)%N], J[4,(i+1)%N,j,(k+1)%N], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr2 = ((i + j + k) % N)
        if h[site_nbr2][j][k] > 0:
          magnetism_coeff2 = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff2 * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff2 = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff2 * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.5046602000000001}
#standard deviation: 0.04275373499426688
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,i,j,(k+1)%N], J[4,(i+1)%N,j,(k+1)%N], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.32399419999999995}
#standard deviation: 0.04289271367446923
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,i,j,(k+1)%N], J[4,(i+1)%N,j,(k+1)%N], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Improved priority calculation
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(J[:,i,j,k]) / np.sum(abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][1] -= np.sum(J[:,i,j,k]) / np.sum(abs(J[:,i,j,k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(J[:,i,j,k]) / np.sum(abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][1] = -1 + np.sum(J[:,i,j,k]) / np.sum(abs(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': 0.014654999999999906}
#standard deviation: 0.044331150842268914
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin**2 + np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin**2 + np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -1 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2823798000000001}
#standard deviation: 0.0462883574126367
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1
  return(priorities)




#score: {'data3D.txt': 0.11423099999999992}
#standard deviation: 0.044837185003075306
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1
        
        # Calculate the priority for neighboring sites
        if i < N-1:
          priorities[(i+1)*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[(i+1)*N*N+j*N+k][1] -= 2 - 2*total_spin
        if j < N-1:
          priorities[i*N*N+(j+1)*N+k][0] += np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+(j+1)*N+k][1] -= 2 - 2*total_spin
        if k < N-1:
          priorities[i*N*N+j*N+(k+1)%N][0] += np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+(k+1)%N][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.464735}
#standard deviation: 0.04329027298366228
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr].sum() > 0:
      priorities[i*N+i][0] += 1 + np.sum(h[i])
      priorities[i*N+i][1] -= 1 - np.sum(h[i])
    else:
      priorities[i*N+i][0] -= 1 + np.sum(h[i])
      priorities[i*N+i][1] = -1 + np.sum(h[i])
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr].sum() > 0:
        priorities[i*N+j][0] += 1 + np.sum(h[:,j])
        priorities[i*N+j][1] -= 1 - np.sum(h[:,j])
      else:
        priorities[i*N+j][0] -= 1 + np.sum(h[:,j])
        priorities[i*N+j][1] = -1 + np.sum(h[:,j])
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i-1)%2 - 1)) % N
      if h[site_nbr].sum() > 0:
        priorities[i*N+j][0] += 1 + np.sum(h[i,:])
        priorities[i*N+j][1] -= 1 - np.sum(h[i,:])
      else:
        priorities[i*N+j][0] -= 1 + np.sum(h[i,:])
        priorities[i*N+j][1] = -1 + np.sum(h[i,:])
  
  return priorities




#score: {'data3D.txt': -0.4996082}
#standard deviation: 0.042901029040805075
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr].sum() > 0:
      priorities[i*N+i][0] += 1 + total_spin.sum()
      priorities[i*N+i][1] -= 1 - total_spin.sum()
    else:
      priorities[i*N+i][0] -= 1 + total_spin.sum()
      priorities[i*N+i][1] = -1 + total_spin.sum()

  site_nbr = (i + ((k-1)%2 - 1)) % N
  for j in range(N):
    if h[site_nbr][j].sum() > 0:
      priorities[i*N+j][0] += 1 + total_spin.sum()
      priorities[i*N+j][1] -= 1 - total_spin.sum()
    else:
      priorities[i*N+j][0] -= 1 + total_spin.sum()
      priorities[i*N+j][1] = -1 + total_spin.sum()

  for k in range(N):
    if h[i][k].sum() > 0:
      priorities[i*N+k][0] += 1 + total_spin.sum()
      priorities[i*N+k][1] -= 1 - total_spin.sum()
    else:
      priorities[i*N+k][0] -= 1 + total_spin.sum()
      priorities[i*N+k][1] = -1 + total_spin.sum()

  return(priorities)




#score: {'data3D.txt': -0.2466641999999999}
#standard deviation: 0.04758063385832517
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1 + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])

  return(priorities)




#score: {'data3D.txt': -0.30916299999999997}
#standard deviation: 0.04608637663127792
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.09463020000000005}
#standard deviation: 0.04697349814480502
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          spin_flip_energy = sum([J[d,site_nbr,j,k] for d in [0,1,2]]) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_flip_energy
          priorities[i*N*N+j*N+k][1] -= 1 - 2*spin_flip_energy
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          spin_flip_energy = sum([J[d,site_nbr,j,k] for d in [0,1,2]]) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_flip_energy
          priorities[i*N*N+j*N+k][1] = -2*spin_flip_energy + 1

  return(priorities)




#score: {'data3D.txt': -0.1293594000000001}
#standard deviation: 0.04693815155755498
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.33053740000000004}
#standard deviation: 0.04464125940472558
#island_id: 2
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.33053740000000004}
#standard deviation: 0.04464125940472558
#island_id: 2
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.42228819999999995}
#standard deviation: 0.04328936429147465
#island_id: 2
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          magnetization_coeff = 1 - np.abs(total_spin) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * magnetization_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          magnetization_coeff = 1 - np.abs(total_spin) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * magnetization_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          spin_priority = magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][0] += spin_priority
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          spin_priority = magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][0] -= spin_priority
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.26438380000000006}
#standard deviation: 0.04408560238399834
#island_id: 1
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
  return(priorities)




#score: {'data3D.txt': -0.19553780000000023}
#standard deviation: 0.04746631575296318
#island_id: 1
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          if total_spin_x > 0:
            priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
          elif total_spin_x < 0:
            priorities[i*N*N+j*N+k][1] += 2 * (1 - np.exp(abs(total_spin_x)) * priority_coeff_x)
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          if total_spin_x > 0:
            priorities[i*N*N+j*N+k][1] += 2 * (1 - np.exp(abs(total_spin_x)) * priority_coeff_x)
          elif total_spin_x < 0:
            priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
  return(priorities)




#score: {'data3D.txt': -0.34918140000000014}
#standard deviation: 0.0429787437466476
#island_id: 1
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          if abs(total_spin_x) > 1 and np.random.rand() < 0.5:
            priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
          else:
            priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          if abs(total_spin_x) > 1 and np.random.rand() < 0.5:
            priorities[i*N*N+j*N+k][1] = -2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
          else:
            priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z
  return(priorities)




#score: {'data3D.txt': -0.18051460000000025}
#standard deviation: 0.04571127417650924
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priority_coeff_total = np.exp((total_spin_x + total_spin_y + total_spin_z) / 3)
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z + priority_coeff_total) * abs(total_spin_x + total_spin_y + total_spin_z)
          priorities[i*N*N+j*N+k][1] -= 2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0))
          priority_coeff_y = np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0))
          priority_coeff_z = np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) * abs(total_spin_x + total_spin_y + total_spin_z)
          priorities[i*N*N+j*N+k][1] = -2 * (1 + np.exp(-abs(total_spin_x)) * priority_coeff_x)
  return(priorities)




#score: {'data3D.txt': -0.43203980000000025}
#standard deviation: 0.04262637089830659
#island_id: 3
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] * interacting_spins[d] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spin_count = sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0)) * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          interacting_spin_count = sum(1 for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0)) * (interacting_spin_count + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.1293594000000001}
#standard deviation: 0.04693815155755498
#island_id: 0
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.09559980000000003}
#standard deviation: 0.046067659371407194
#island_id: 0
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_spin_sum = sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] += (total_spin + interacting_spin_sum)**2 / (N**3)
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_spin_sum = sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] -= (total_spin + interacting_spin_sum)**2 / (N**3)
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.12652860000000024}
#standard deviation: 0.04804584874929363
#island_id: 0
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin
          # Add the spin of the adjacent sites to the priority
          for site in [(i-1)%N, (i+1)%N]:
            if h[site][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
              priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.448409}
#standard deviation: 0.03919647789023906
#island_id: 1
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + 2) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin - 2) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.4527778}
#standard deviation: 0.03909373079101047
#island_id: 1
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)*hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)*hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add more complex priority calculation here...

  return(priorities)




#score: {'data3D.txt': -0.418979}
#standard deviation: 0.03965627010952997
#island_id: 1
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)




#score: {'data3D.txt': -0.385041}
#standard deviation: 0.043056975729839644
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate hamming distance between each spin and its neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate magnetism coefficient based on the site interactions
        magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
        
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Assign priority based on the site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
        
        # Calculate neighbor magnetism coefficient based on the site interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.0363978}
#standard deviation: 0.05154705612505917
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

        site_neighbors = []
        for d in range(3):
          site_neighbors.append(J[d,i,(j+1)%N,k]) if (i,j) != ((i+1)%N,(j+1)%N) else site_neighbors.append(J[d,(i+1)%N,j,k])
          site_neighbors.append(J[d,(i+1)%N,j,k]) if (i,j) != ((i+1)%N,(j+1)%N) else site_neighbors.append(J[d,i,(j+1)%N,k])

        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.36710899999999996}
#standard deviation: 0.04379272449848262
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
          
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in site_neighbors if val < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 3
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0] += 1
      priorities[i][1] -= 1
      
    elif priorities[i][0] < priorities[i][1]:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0005326000000000002}
#standard deviation: 0.04915374387816252
#island_id: 3
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Check if there are any neighboring sites with the same spin
        for d in [0, 1, 2]:
          for x in range(N):
            for y in range(N):
              if (d == 0 and k < N-1) or (d == 1 and j < N-1) or (d == 2 and i < N-1):
                if h[x][y][k+1-d] > 0:
                  priorities[i*N*N+j*N+k][0] += 1
                  priorities[i*N*N+j*N+k][1] -= 1
                else:
                  priorities[i*N*N+j*N+k][0] -= 1
                  priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5178130000000001}
#standard deviation: 0.042415129741638184
#island_id: 3
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49775620000000015}
#standard deviation: 0.04197113343191961
#island_id: 3
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.40316820000000003}
#standard deviation: 0.044498308156153535
#island_id: 3
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_magnetisms = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          total_interacting_magnetism = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          if np.mean(interacting_magnetisms) > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_interacting_magnetism) * (np.mean(interacting_magnetisms) > 0))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_interacting_magnetism) * (np.mean(interacting_magnetisms) < 0))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_magnetisms = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          total_interacting_magnetism = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          if np.mean(interacting_magnetisms) > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_interacting_magnetism) * (np.mean(interacting_magnetisms) > 0))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_interacting_magnetism) * (np.mean(interacting_magnetisms) < 0))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5034078}
#standard deviation: 0.04271706519834901
#island_id: 3
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      if h[i][j].sum() > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data3D.txt': -0.18938620000000034}
#standard deviation: 0.049972499732953125
#island_id: 3
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          spin_priority = np.exp(-magnetism_coeff)
          priorities[i*N*N+j*N+k][0] += spin_priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          spin_priority = np.exp(magnetism_coeff)
          priorities[i*N*N+j*N+k][0] -= spin_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.035425000000000054}
#standard deviation: 0.043619720941335705
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = -sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.16441619999999993}
#standard deviation: 0.044485681489216285
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] > 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + site_nbr_energy
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] < 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) - site_nbr_energy

  return(priorities)




#score: {'data3D.txt': -0.027892599999999993}
#standard deviation: 0.04719118842792583
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) / max(len(interacting_spins), 1))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] > 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] += site_nbr_energy
          priorities[i*N*N+j*N+k][1] -= -site_nbr_energy
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) / max(len(interacting_spins), 1))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] < 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] -= site_nbr_energy
          priorities[i*N*N+j*N+k][1] = -site_nbr_energy

  return(priorities)




#score: {'data3D.txt': -0.19975900000000002}
#standard deviation: 0.04559866093428622
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          site_energy = h[i][j][k] + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + site_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          site_energy = -h[i][j][k] + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + site_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.2783542000000001}
#standard deviation: 0.046501503872025465
#island_id: 0
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          total_spin_coeff = 5*total_spin**2
          site_nbr_coeff = 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_coeff + site_nbr_coeff)
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          total_spin_coeff = 5*total_spin**2
          site_nbr_coeff = -2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_coeff + site_nbr_coeff)
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1 + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])

  return(priorities)




#score: {'data3D.txt': -0.32249379999999983}
#standard deviation: 0.04494369234453261
#island_id: 0
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          priorities[i*N*N+j*N+k][0] += np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0)) for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0)) for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1 + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          priorities[i*N*N+j*N+k][0] -= np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0)) for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][1] += np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0)) for s in [(i-1)%N, i, (i+1)%N]])

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          for s in range(N):
            if s == i:
              continue
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0))
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1 + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          for s in range(N):
            if s == i:
              continue
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0))
            priorities[i*N*N+j*N+k][1] += np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0))

  return(priorities)




#score: {'data3D.txt': -0.28300339999999996}
#standard deviation: 0.04642904466430469
#island_id: 0
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] -= 1 - 4*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          priorities[i*N*N+j*N+k][0] += np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0)) for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0)) for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][1] = -4*total_spin + 1 + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
          # Add a term to take into account the magnetism of neighboring sites
          priorities[i*N*N+j*N+k][0] -= np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0)) for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][1] += np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0)) for s in [(i-1)%N, i, (i+1)%N]])

        # Add a term to take into account the magnetism of sites diagonally adjacent
        priorities[i*N*N+j*N+k][0] += np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] > 0)) for s in [(i-1)%N, i, (i+1)%N]])
        priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(h[s][j][k]) * (h[s][j][k] < 0)) for s in [(i-1)%N, i, (i+1)%N]])

  return(priorities)




#score: {'data3D.txt': -0.4498858000000001}
#standard deviation: 0.042421989090093364
#island_id: 0
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.12283140000000001}
#standard deviation: 0.045156668765975204
#island_id: 0
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_total = total_spin + np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total + 4*total_spin
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_total = total_spin - np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])**2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total + 4*total_spin
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin + 2*np.sum([J[d,site_nbr,j,k] for d in [0,1,2]])

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5334966}
#standard deviation: 0.040646426515008674
#island_id: 3
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism at the current site
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0502474}
#standard deviation: 0.04510763342539708
#island_id: 3
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin

        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] = -priority_down
  return(priorities)




#score: {'data3D.txt': -0.3590662}
#standard deviation: 0.04229561085455559
#island_id: 0
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.4913162000000001}
#standard deviation: 0.04195318221017329
#island_id: 0
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4283082}
#standard deviation: 0.04703187358334771
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization of the neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetization = sum(J[d,site_nbr,sitenbr_k,0] for (sitenbr, sitenbr_k) in [(i,(j+1)%N), ((i+1)%N, j)])
          priorities[i*N*N+j*N+k][0] += neighbor_magnetization
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetization

  return(priorities)




#score: {'data3D.txt': -0.4975998}
#standard deviation: 0.04096607523256286
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a new term to the priority function
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / len(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / len(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5268022000000001}
#standard deviation: 0.04162452492413577
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional term to favor the direction of the magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= np.abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] += np.abs(total_spin)

  return(priorities)




#score: {'data3D.txt': 0.23822579999999988}
#standard deviation: 0.045685125964147255
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] -= priority_down
  return(priorities)




#score: {'data3D.txt': -0.09826980000000012}
#standard deviation: 0.04857249888527459
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = 0
        for d in range(6):  # consider all 6 neighbors
          site_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
        magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.06537180000000001}
#standard deviation: 0.04760084079887665
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] = -priority_down

  # Add a term to account for the interaction with the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_1 = (i + ((k-1)%2 - 1)) % N
        site_nbr_2 = (j + ((i-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(J[:,site_nbr_1,j,k], axis=0) + np.sum(J[:,i,site_nbr_2,k], axis=0)
          priorities[i*N*N+j*N+k][1] -= np.sum(J[:,site_nbr_1,j,k], axis=0) + np.sum(J[:,i,site_nbr_2,k], axis=0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(J[:,site_nbr_1,j,k], axis=0) + np.sum(J[:,i,site_nbr_2,k], axis=0)
          priorities[i*N*N+j*N+k][1] = -np.sum(J[:,site_nbr_1,j,k], axis=0) - np.sum(J[:,i,site_nbr_2,k], axis=0)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += (priority_up + 3 - 2*total_spin)
          priorities[i*N*N+j*N+k][1] -= (priority_down - 3 + 2*total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= (priority_up + 3 - 2*total_spin)
          priorities[i*N*N+j*N+k][1] = -priority_down - 3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.27548220000000034}
#standard deviation: 0.046667470503124524
#island_id: 1
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)) + np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)) + np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x)) + np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y)) + np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.21968940000000015}
#standard deviation: 0.04581926720976668
#island_id: 1
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,(j+1)%N,k,k]]
        interacting_spins_z = [J[5,i,j,k], J[2,(k+1)%N,i,j]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) < 0)) + np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) < 0)) + np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) < 0))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 3 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff = np.exp(-abs(total_spin_x) * (np.mean(interacting_spins_x) > 0)) + np.exp(-abs(total_spin_y) * (np.mean(interacting_spins_y) > 0)) + np.exp(-abs(total_spin_z) * (np.mean(interacting_spins_z) > 0))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -3 + total_spin_x + total_spin_y + total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.43548620000000005}
#standard deviation: 0.041882352961121944
#island_id: 0
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]) + sum(J[d,i,(j-1)%N,k] for d in [0,1,2]) + sum(J[d,i,N-1,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]) + sum(J[d,i,(j-1)%N,k] for d in [0,1,2]) + sum(J[d,i,N-1,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4913162000000001}
#standard deviation: 0.04195318221017329
#island_id: 0
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priority_sum = sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + priority_sum
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priority_sum = sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + priority_sum
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4913162000000001}
#standard deviation: 0.04195318221017329
#island_id: 0
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4913162000000001}
#standard deviation: 0.04195318221017329
#island_id: 0
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N])
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

  return(priorities)




#score: {'data3D.txt': -0.3518318}
#standard deviation: 0.04209296174849188
#island_id: 0
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.3590662}
#standard deviation: 0.04229561085455559
#island_id: 0
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.24166580000000024}
#standard deviation: 0.04697864823896063
#island_id: 1
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        interacting_spins = []
        for s in site_nbrs:
          interacting_spins.append(sum(J[d,s,j,k] for d in [0,1,2]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.44649220000000023}
#standard deviation: 0.044402028097374105
#island_id: 1
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,i,(k+1)%N,k], J[4,(i+N)%N,(j+N)%N,(k+N)%N], 
                   J[5,(i+N)%N,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - 2
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 2 - total_spin

  return(priorities)




#score: {'data3D.txt': -0.34018380000000026}
#standard deviation: 0.04452842078448324
#island_id: 1
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        interacting_spins = []
        for s in site_nbrs:
          interacting_spins.append(sum(J[d,s,j,k] for d in [0,1,2]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)




#score: {'data3D.txt': -0.3423738000000002}
#standard deviation: 0.04329815046350132
#island_id: 1
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        interacting_spins = []
        for s in site_nbrs:
          interacting_spins.append(sum(J[d,s,j,k] for d in [0,1,2]))
        total_magnetism = sum(h[s][j][k] for s in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins)) + total_magnetism
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins)) - total_magnetism
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)




#score: {'data3D.txt': 0.035425000000000054}
#standard deviation: 0.043619720941335705
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = -sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.12038339999999988}
#standard deviation: 0.04555215213840067
#island_id: 2
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = -sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          neighbor_energy = -sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + neighbor_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.3590662}
#standard deviation: 0.04229561085455559
#island_id: 0
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.3590662}
#standard deviation: 0.04229561085455559
#island_id: 0
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priority_sum = magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][0] += priority_sum
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priority_sum = magnetism_coeff + interacting_momentum + 0.5*local_energy
          priorities[i*N*N+j*N+k][0] -= priority_sum
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.36832220000000004}
#standard deviation: 0.04375164805078776
#island_id: 0
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.451685}
#standard deviation: 0.04063562101161984
#island_id: 2
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(total_spin)
          spin_sum = sum(1 if val > 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (spin_sum + total_spin)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-2 + 2*total_spin + spin_sum)
        else:
          priority_coeff = np.exp(-total_spin)
          spin_sum = sum(1 if val > 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (spin_sum + total_spin)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-2 + 2*total_spin + spin_sum)
  return(priorities)




#score: {'data3D.txt': -0.4943238}
#standard deviation: 0.04326549749581068
#island_id: 2
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.43548620000000005}
#standard deviation: 0.041882352961121944
#island_id: 0
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]) + sum(J[d,i,(j-1)%N,k] for d in [0,1,2]) + sum(J[d,i,N-1,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]) + sum(J[d,i,(j-1)%N,k] for d in [0,1,2]) + sum(J[d,i,N-1,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': 0.23822579999999988}
#standard deviation: 0.045685125964147255
#island_id: 0
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += 4 * (priority_up > 0) + (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 4 * (priority_down < 0) + (total_spin < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= 4 * (priority_up < 0) + (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = -4 * (priority_down > 0) + (total_spin < 0)
  return(priorities)




#score: {'data3D.txt': -0.07254460000000003}
#standard deviation: 0.047454186863120945
#island_id: 0
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = magnetism_coeff + total_spin + interacting_momentum + sum(J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]) + sum(J[d,i,(j-1)%N,k] for d in [0,1,2]) + sum(J[d,i,N-1,k] for d in [0,1,2])
          priority_down = -magnetism_coeff - total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += (priority_up + priority_down) / 2
          priorities[i*N*N+j*N+k][1] -= (priority_up - priority_down) / 2
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -magnetism_coeff + total_spin + interacting_momentum
          priority_down = magnetism_coeff + total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= (priority_up + priority_down) / 2
          priorities[i*N*N+j*N+k][1] = -(priority_up - priority_down) / 2
  return(priorities)




#score: {'data3D.txt': 0.23822579999999988}
#standard deviation: 0.045685125964147255
#island_id: 0
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = total_spin + interacting_momentum
          priority_down = -total_spin - interacting_momentum
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          priority_up = -total_spin - interacting_momentum
          priority_down = total_spin + interacting_momentum
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] = -priority_down
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = magnetism_coeff + total_spin + total_magnetism
          priority_down = -magnetism_coeff - total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = -magnetism_coeff - total_spin + total_magnetism
          priority_down = magnetism_coeff + total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = magnetism_coeff + total_spin + total_magnetism
          priority_down = -magnetism_coeff - total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = -magnetism_coeff - total_spin + total_magnetism
          priority_down = magnetism_coeff + total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = magnetism_coeff + total_spin + total_magnetism
          priority_down = -magnetism_coeff - total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = -magnetism_coeff - total_spin + total_magnetism
          priority_down = magnetism_coeff + total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)




#score: {'data3D.txt': 0.35092460000000014}
#standard deviation: 0.04932873518386621
#island_id: 2
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = magnetism_coeff + total_spin + total_magnetism
          priority_down = -magnetism_coeff - total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= 2 * priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = -magnetism_coeff - total_spin + total_magnetism
          priority_down = magnetism_coeff + total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += 2 * priority_down

  return(priorities)




#score: {'data3D.txt': -0.5279385999999999}
#standard deviation: 0.040361891309005825
#island_id: 3
#version_generated: 3
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

        # Add a new term based on the number of neighbors with the same spin
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][0] += np.log(num_neighbors + 1)
          priorities[i*N*N+j*N+k][1] -= np.log(num_neighbors + 1)
        else:
          num_neighbors = len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][0] -= np.log(num_neighbors + 1)
          priorities[i*N*N+j*N+k][1] += np.log(num_neighbors + 1)

  return(priorities)




#score: {'data3D.txt': -0.5169498000000001}
#standard deviation: 0.040239374746136404
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        magnetization = np.sum([h[i][j][k] for i in range(N) for j in range(N)])
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3 + magnetization / (N**2))
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3 + magnetization / (N**2))

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

  return(priorities)




#score: {'data3D.txt': 0.39192740000000037}
#standard deviation: 0.04522983229285732
#island_id: 1
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          total_priority = magnetism_coeff * sum(1 if J[d,i,j,k] > 0 else -1 for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          total_priority = -magnetism_coeff * sum(1 if J[d,i,j,k] < 0 else -1 for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)




#score: {'data3D.txt': 0.44966380000000017}
#standard deviation: 0.04216105180803724
#island_id: 1
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_priority = np.sum([magnetism_coeff*(total_spin+2), magnetism_coeff*(total_spin-2)])
          priorities[i*N*N+j*N+k][0] += interacting_priority
          priorities[i*N*N+j*N+k][1] -= interacting_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_priority = np.sum([magnetism_coeff*(total_spin-2), magnetism_coeff*(total_spin+2)])
          priorities[i*N*N+j*N+k][0] -= interacting_priority
          priorities[i*N*N+j*N+k][1] = -interacting_priority

  return(priorities)




#score: {'data3D.txt': -0.3199109999999999}
#standard deviation: 0.045474798724128504
#island_id: 1
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

        for site_nbr in [(i + ((k-1)%2 - 1)) % N]:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.12690020000000024}
#standard deviation: 0.05110782797145659
#island_id: 1
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[4,i,(j+1)%N,k]]
        interacting_spins_z = [J[2,i,j,k], J[5,(i+N)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 4*total_spin
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          total_spin = total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + 2*total_spin
          priorities[i*N*N+j*N+k][1] = -2 - 4*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][j][k] > 0:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1
    else:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

        site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  for i in range(N):
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if h[site_nbr][j][k] > 0:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1
    else:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.34346299999999963}
#standard deviation: 0.044636194181403945
#island_id: 1
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[5,(i+1)%N,j,k]]
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] += (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
        else:
          priority_coeff_x = np.exp(-abs(total_spin_x) * np.mean(interacting_spins_x))
          priority_coeff_y = np.exp(-abs(total_spin_y) * np.mean(interacting_spins_y))
          priority_coeff_z = np.exp(-abs(total_spin_z) * np.mean(interacting_spins_z))
          priorities[i*N*N+j*N+k][0] -= (priority_coeff_x + priority_coeff_y + priority_coeff_z) + total_spin_x + total_spin_y + total_spin_z
          priorities[i*N*N+j*N+k][1] = -1 - total_spin_x - total_spin_y - total_spin_z

  for i in range(N):
    site_nbr = (i + ((0-1)%2 - 1)) % N
    if h[site_nbr][j][k] > 0:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1
    else:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': 0.4688062000000001}
#standard deviation: 0.04388677524676426
#island_id: 2
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in site_neighbors) > sum(val > 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin + sum(val for val in site_neighbors if val > 0)
          
  return(priorities)




#score: {'data3D.txt': -0.2649310000000001}
#standard deviation: 0.04839617421863013
#island_id: 1
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i-1)%2 - 1)) % N
        
        total_spin_x = h[site_nbr_x][j].sum()
        total_spin_y = h[i][site_nbr_y].sum()
        total_spin_z = h[i][j].sum()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
          priorities[i*N*N+j*N+k][1] -= total_spin_x + total_spin_y + total_spin_z
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
          priorities[i*N*N+j*N+k][1] = -total_spin_x - total_spin_y - total_spin_z
          
  return(priorities)




#score: {'data3D.txt': -0.109335}
#standard deviation: 0.046908071533585775
#island_id: 2
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.502333}
#standard deviation: 0.042124901317391834
#island_id: 2
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
        neighbor_magnetism = sum(abs(J[d][i][site_nbr][k]) for d in range(3)) / max(len([J[d][i][site_nbr][k] for d in range(3)]), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism + neighbor_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism + neighbor_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4146482}
#standard deviation: 0.043025524944618636
#island_id: 2
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors_2 = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k], J[d][i,(j+1)%N,k]]
          neighbor_magnetism_coeff_2 = np.exp(-abs(total_spin) * (len([val for val in site_neighbors_2 if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff_2
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors_2 if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.1807793999999999}
#standard deviation: 0.04423679210385852
#island_id: 2
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin))
        total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.5112298}
#standard deviation: 0.04252065512148184
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance * (h[i][j][k] < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.31415819999999994}
#standard deviation: 0.04396305417916276
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.5228658}
#standard deviation: 0.039928781979419306
#island_id: 3
#version_generated: 3
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a new term based on the number of neighbors with the same spin
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][0] += np.log(num_neighbors + 1) * (np.tanh(total_spin / N**3))
          priorities[i*N*N+j*N+k][1] -= np.log(num_neighbors + 1) * (np.tanh(total_spin / N**3))
        else:
          num_neighbors = len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][0] -= np.log(num_neighbors + 1) * (np.tanh(total_spin / N**3))
          priorities[i*N*N+j*N+k][1] += np.log(num_neighbors + 1) * (np.tanh(total_spin / N**3))

  return(priorities)




#score: {'data3D.txt': -0.5152578000000001}
#standard deviation: 0.040536807708057135
#island_id: 3
#version_generated: 3
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a new term based on the number of neighbors with the same spin
        num_neighbors = len([val for val in interacting_spins if val == J[0,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.log(num_neighbors + 1)
        priorities[i*N*N+j*N+k][1] -= np.log(num_neighbors + 1)

  return(priorities)




#score: {'data3D.txt': -0.5279385999999999}
#standard deviation: 0.040361891309005825
#island_id: 3
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

        # Add a new term based on the number of neighbors with the same spin
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][0] += np.log(num_neighbors + 1)
          priorities[i*N*N+j*N+k][1] -= np.log(num_neighbors + 1)
        else:
          num_neighbors = len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][0] -= np.log(num_neighbors + 1)
          priorities[i*N*N+j*N+k][1] += np.log(num_neighbors + 1)

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 3
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

  return(priorities)




#score: {'data3D.txt': -0.5008438}
#standard deviation: 0.04072191893268293
#island_id: 3
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
         site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
         neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
         priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
         priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetization
        priorities[i*N*N+j*N+k][0] += np.tanh(total_spin / N**3)
        priorities[i*N*N+j*N+k][1] -= np.tanh(total_spin / N**3)

  return(priorities)




#score: {'data3D.txt': -0.410775}
#standard deviation: 0.04610460947671068
#island_id: 3
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.3518318}
#standard deviation: 0.04209296174849188
#island_id: 0
#version_generated: 3
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  
  return(priorities)




#score: {'data3D.txt': -0.3518318}
#standard deviation: 0.04209296174849188
#island_id: 0
#version_generated: 3
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 0.8 + interacting_momentum * 0.6 + 0.4*local_energy
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4338558}
#standard deviation: 0.04235116393158516
#island_id: 0
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum - 0.5*local_energy + interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum - 0.5*local_energy + interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.36832220000000004}
#standard deviation: 0.04375164805078776
#island_id: 0
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': 0.33656900000000006}
#standard deviation: 0.049283519750521074
#island_id: 0
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        total_spin_sum = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_sum = sum(h[s][j][k] for s in [(i-1)%N, i, (i+1)%N])
        priorities[i*N*N+j*N+k][0] += 3*total_spin_sum - 4*site_nbr_sum
        priorities[i*N*N+j*N+k][1] -= total_spin_sum - site_nbr_sum
  return(priorities)




#score: {'data3D.txt': -0.36832220000000004}
#standard deviation: 0.04375164805078776
#island_id: 0
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          interacting_momentum = sum(J[d,i,j,k] for d in [0,1,2])
          local_energy = -total_spin + np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
          interaction_with_neighbors = np.sum([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interacting_momentum + 0.5*local_energy - interaction_with_neighbors
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin - np.sum([J[0,s,j,k] for s in [(i-1)%N, i, (i+1)%N]])
  return(priorities)




#score: {'data3D.txt': -0.4998066}
#standard deviation: 0.04384450520236259
#island_id: 2
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val > 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          total_priority = magnetism_coeff + priority_ones + priority_magnetism
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val < 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          total_priority = magnetism_coeff - priority_ones + priority_magnetism
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.504167}
#standard deviation: 0.04178614592182438
#island_id: 2
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val > 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_ones + priority_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_ones = sum(val for val in interacting_spins if val < 0) / len(interacting_spins)
          priority_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_ones - priority_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin))
          priority_magnetic = abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] -= 2 * priority_total - priority_magnetic
        else:
          priority_total = -np.exp(abs(total_spin))
          priority_magnetic = -abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total + priority_magnetic
          priorities[i*N*N+j*N+k][1] += 2 * priority_total + priority_magnetic

  return(priorities)




#score: {'data3D.txt': -0.013290999999999997}
#standard deviation: 0.04675649087559929
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val == 0])
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin + sum(val for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val == 0])

        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority

  return(priorities)




#score: {'data3D.txt': -0.1348994}
#standard deviation: 0.04606551334393225
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins if val > 0) + sum(abs(val) for val in interacting_spins)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin + sum(val for val in interacting_spins if val < 0) + sum(abs(val) for val in interacting_spins)

        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority

  return(priorities)




#score: {'data3D.txt': 0.3908926000000002}
#standard deviation: 0.04677825162658391
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin + sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] += 2*priority

  return(priorities)




#score: {'data3D.txt': 0.0075918}
#standard deviation: 0.04598324621816081
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins if val > 0) + np.exp(-np.sum([abs(J[d,i,j,k]) for d in [0,1,2]]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin + sum(val for val in interacting_spins if val < 0) + np.exp(-np.sum([abs(J[d,i,j,k]) for d in [0,1,2]]))

        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 0
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.23019180000000006}
#standard deviation: 0.04690212077038736
#island_id: 0
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Calculate the priority for each site based on its magnetization and the total spin of its interacting sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(J[:,i,j,k]) - np.mean(J[:,i,j,k])
          priorities[i*N*N+j*N+k][1] -= np.sum(J[:,i,j,k]) - np.mean(J[:,i,j,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(J[:,i,j,k]) - np.mean(J[:,i,j,k])
          priorities[i*N*N+j*N+k][1] = np.sum(J[:,i,j,k]) - np.mean(J[:,i,j,k])

  return(priorities)




#score: {'data3D.txt': -0.339791}
#standard deviation: 0.04562325151718146
#island_id: 0
#version_generated: 2
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a term to account for the interaction with the neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.3617822}
#standard deviation: 0.0446494725966612
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(h[i][j][k]) > 0.5:
          if np.sum(interacting_spins) > 0:
            priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr].sum() > 0:
      priorities[i*N*(N+1) + i%N][0] += 1
      priorities[i*N*(N+1) + i%N][1] -= 1
    else:
      priorities[i*N*(N+1) + i%N][0] -= 1
      priorities[i*N*(N+1) + i%N][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.3621482}
#standard deviation: 0.04447653669925301
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(h[i][j][k]) > 0.5:
          if np.sum(interacting_spins) > 0:
            priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      priorities[i*N*(N+1) + i%N][0] += 1
      priorities[i*N*(N+1) + i%N][1] -= 1
    else:
      priorities[i*N*(N+1) + i%N][0] -= 1
      priorities[i*N*(N+1) + i%N][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.3621482}
#standard deviation: 0.04447653669925301
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(h[i][j][k]) > 0.5:
          if np.sum(interacting_spins) > 0:
            priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      priorities[i*N*(N+1) + i%N][0] += 1
      priorities[i*N*(N+1) + i%N][1] -= 1
    else:
      priorities[i*N*(N+1) + i%N][0] -= 1
      priorities[i*N*(N+1) + i%N][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.3627518}
#standard deviation: 0.044693062065157274
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(h[i][j][k]) > 0.5:
          if np.sum(interacting_spins) > 0:
            priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      priorities[i*N*(N+1) + i%N][0] += 1
      priorities[i*N*(N+1) + i%N][1] -= 1
    else:
      priorities[i*N*(N+1) + i%N][0] -= 1
      priorities[i*N*(N+1) + i%N][1] = -1

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      priorities[i*N*(N+1) + i%N][0] += sum(h[k][j][k] for k in range(N))
      priorities[i*N*(N+1) + i%N][1] -= -2
    else:
      priorities[i*N*(N+1) + i%N][0] -= sum(h[k][j][k] for k in range(N))
      priorities[i*N*(N+1) + i%N][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.1728302000000002}
#standard deviation: 0.046105921614907557
#island_id: 2
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = sum(h[site_nbr][i][j] for i in range(N) for j in range(N)) + h[i][j][k]
          if total_magnetism > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - abs(total_spin) / N)
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = sum(h[site_nbr][i][j] for i in range(N) for j in range(N)) + h[i][j][k]
          if total_magnetism < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - abs(total_spin) / N)
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.30701460000000014}
#standard deviation: 0.05175884066360065
#island_id: 2
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        total_spin += h[site_nbr][i%N][k]
        if h[site_nbr][i%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.270465}
#standard deviation: 0.0412800297359389
#island_id: 0
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + sum(val for val in site_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.339791}
#standard deviation: 0.04562325151718146
#island_id: 0
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_neighbors)

  return priorities




#score: {'data3D.txt': -0.4371502}
#standard deviation: 0.04264422352394284
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[0,i:i+2,j,k]) + np.sum(J[1,i,j:j+2,k])
        priorities[i*N*N+j*N+k][1] -= 4 - np.sum(J[0,i:i+2,j,k]) - np.sum(J[1,i,j:j+2,k])

  return(priorities)




#score: {'data3D.txt': -0.1725894}
#standard deviation: 0.049208434314048234
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a term to account for the interaction with the neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_neighbors)

        # Add a term to account for the interaction with the sites above and below
        if k > 0:
          site_above = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,(j+1)%N,k-1]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in site_above)
          priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_above)

        if k < N-1:
          site_below = [J[0,i,j,k+1], J[1,(i+1)%N,j,k+1], J[2,i,(j+1)%N,k+1]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in site_below)
          priorities[i*N*N+j*N+k][1] -= 2 - sum(val for val in site_below)

  return(priorities)




#score: {'data3D.txt': -0.1562818}
#standard deviation: 0.05033704866954359
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[:,i,j,k])
        priorities[i*N*N+j*N+k][1] -= 2 * np.sum(J[:,i,j,k])

  return(priorities)




#score: {'data3D.txt': -0.0786698}
#standard deviation: 0.045712628976684336
#island_id: 2
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.1957498}
#standard deviation: 0.04908269022741113
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.1957498}
#standard deviation: 0.04908269022741113
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.2339574}
#standard deviation: 0.04864379493049448
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          neighbor_magnetism_coeff = np.exp(-abs(neighbor_magnetism) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          neighbor_magnetism_coeff = np.exp(-abs(neighbor_magnetism) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.1957498}
#standard deviation: 0.04908269022741113
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization) * (np.abs(neighbor_magnetism) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)




#score: {'data3D.txt': -0.4627038}
#standard deviation: 0.041404650772105304
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins) + abs(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins) - abs(h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4892414000000001}
#standard deviation: 0.04227163405926011
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) + abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins) + abs(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) + abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins) - abs(h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.3542158}
#standard deviation: 0.043536527541364625
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = abs(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins) + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = abs(h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins) - priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4627038}
#standard deviation: 0.041404650772105304
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_momentum = sum(val for val in interacting_spins if val > 0) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_momentum + abs(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_momentum = sum(val for val in interacting_spins if val < 0) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - spin_momentum - abs(h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4011766}
#standard deviation: 0.042422211781565564
#island_id: 2
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(val for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + interaction_term
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(val for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - interaction_term
  
  return(priorities)




#score: {'data3D.txt': -0.20750059999999995}
#standard deviation: 0.04998320197466346
#island_id: 2
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(1 if val < 0 else -1 for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + interaction_term
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          interaction_term = sum(1 if val > 0 else -1 for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + interaction_term
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': -0.39893860000000003}
#standard deviation: 0.040783694168625775
#island_id: 2
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          interaction_term = sum(val for val in interacting_spins) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * interaction_term
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + interaction_term
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          interaction_term = sum(val for val in interacting_spins) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * interaction_term
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - interaction_term

  return(priorities)




#score: {'data3D.txt': -0.36710899999999996}
#standard deviation: 0.04379272449848262
#island_id: 2
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
          
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in site_neighbors]) > 0.5))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in site_neighbors if val < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.427697}
#standard deviation: 0.042783192856541225
#island_id: 0
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[0,i:i+2,j,k]) + np.sum(J[1,i,j:j+2,k])
        priorities[i*N*N+j*N+k][1] -= 4 - np.sum(J[0,i:i+2,j,k]) - np.sum(J[1,i,j:j+2,k])

  # Add a term to account for the interaction with the neighboring sites in the z-direction
  for i in range(N):
    for j in range(N):
      priorities[i*N*N+j*N+k][0] += np.sum(J[2,i,j,k:k+2])
      priorities[i*N*N+j*N+k][1] -= 2 - np.sum(J[2,i,j,k:k+2])

  return(priorities)




#score: {'data3D.txt': -0.24214660000000002}
#standard deviation: 0.0486854137133495
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[0,i:i+2,j,k]) + np.sum(J[1,i,j:j+2,k])
        priorities[i*N*N+j*N+k][1] -= 4 - np.sum(J[0,i:i+2,j,k]) - np.sum(J[1,i,j:j+2,k])

  # Add a term to account for the interaction with the diagonal sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[0,i:i+N-1,j,k]) + np.sum(J[2,i,j:j+N-1,k])
        priorities[i*N*N+j*N+k][1] -= 4 - np.sum(J[0,i:i+N-1,j,k]) - np.sum(J[2,i,j:j+N-1,k])

  return(priorities)




#score: {'data3D.txt': -0.09344419999999999}
#standard deviation: 0.04928945532626629
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a term to account for the interaction with the neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i:i+2,j,k], J[d,i,j:j+2,k]]
          priorities[i*N*N+j*N+k][0] += np.sum(J[0,i:i+2,j,k]) + np.sum(J[1,i,j:j+2,k])
          priorities[i*N*N+j*N+k][1] -= 4 - np.sum(J[0,i:i+2,j,k]) - np.sum(J[1,i,j:j+2,k])

  return(priorities)




#score: {'data3D.txt': -0.04577099999999977}
#standard deviation: 0.04781476256345943
#island_id: 2
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N + site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + spin_diff

  return(priorities)




#score: {'data3D.txt': -0.06343139999999999}
#standard deviation: 0.04539666787375479
#island_id: 2
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin + spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -2 + total_spin + spin_diff

  return(priorities)




#score: {'data3D.txt': -0.3595642}
#standard deviation: 0.04103958038723106
#island_id: 2
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priority_coeff = magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += priority_coeff + (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priority_coeff = magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= priority_coeff + (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1848054}
#standard deviation: 0.0471146322371299
#island_id: 0
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a term to account for the interaction with the neighboring sites
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)

  # Add a term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.sum(J[:,i,j,k])
        priorities[i*N*N+j*N+k][1] -= 2 * np.sum(J[:,i,j,k])

  return(priorities)




#score: {'data3D.txt': -0.410775}
#standard deviation: 0.04610460947671068
#island_id: 3
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.410775}
#standard deviation: 0.04610460947671068
#island_id: 3
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        # Calculate the total spin and magnetism coefficient
        total_spin = sum(interacting_spins)
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        
        # Calculate the hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Update priorities based on total spin and magnetism coefficient
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Update priorities based on neighboring spins
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4224818}
#standard deviation: 0.04415504307279068
#island_id: 3
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add a new term based on the number of neighbors with the same spin
        num_neighbors = len([val for val in interacting_spins if val == J[0,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.log(num_neighbors + 1)
        priorities[i*N*N+j*N+k][1] -= np.log(num_neighbors + 1)
        
  return(priorities)




#score: {'data3D.txt': -0.410775}
#standard deviation: 0.04610460947671068
#island_id: 3
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.17591340000000003}
#standard deviation: 0.05641153623541908
#island_id: 1
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3907186}
#standard deviation: 0.04927224831525348
#island_id: 1
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction between neighboring sites
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] -= interacting_spins[d]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] = -interacting_spins[d]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.19730100000000028}
#standard deviation: 0.04555505678846202
#island_id: 3
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)

        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

          # Add a new term to the priority function
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / len(interacting_spins))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / len(interacting_spins))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] += 1 - total_spin + sum(val for val in site_neighbors if val < 0)

          # Add a new term to the priority function
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / len(interacting_spins))
            priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / len(interacting_spins))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.410775}
#standard deviation: 0.04610460947671068
#island_id: 3
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        magnetism_coeff = np.exp(-abs(total_spin) / N**3)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4039998000000001}
#standard deviation: 0.047462149550562924
#island_id: 3
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add a new term to the priority function
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / len(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / len(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3907186}
#standard deviation: 0.04927224831525348
#island_id: 1
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction between neighboring sites
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] -= interacting_spins[d]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] = -interacting_spins[d]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 3
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 3
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 3
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 1
#version_generated: 3
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.3178598}
#standard deviation: 0.051859307978028395
#island_id: 1
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3907186}
#standard deviation: 0.04927224831525348
#island_id: 1
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction between neighboring sites
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] -= interacting_spins[d]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] = -interacting_spins[d]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3907186}
#standard deviation: 0.04927224831525348
#island_id: 1
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction between neighboring sites
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] -= interacting_spins[d]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(interacting_spins[d]))
            priorities[i*N*N+j*N+k][1] = -interacting_spins[d]
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.010266999999999998}
#standard deviation: 0.04161735252271581
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = np.exp(-total_spin) * (np.sum([val < 0 for val in interacting_spins]) > len(interacting_spins) // 2)
          priorities[i*N*N+j*N+k][0] += priority + sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2*priority - 2
        else:
          priority = np.exp(total_spin) * (np.sum([val > 0 for val in interacting_spins]) > len(interacting_spins) // 2)
          priorities[i*N*N+j*N+k][0] -= priority + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2*priority + 2
  return(priorities)




#score: {'data3D.txt': -0.34222139999999956}
#standard deviation: 0.04501484268594082
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = np.exp(-total_spin) * (np.sum([val < 0 for val in interacting_spins]) > len(interacting_spins) // 2)
        else:
          priority = -np.exp(total_spin) * (np.sum([val > 0 for val in interacting_spins]) > len(interacting_spins) // 2)

        # Add new term to account for the magnetism at the current site
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.024611400000000096}
#standard deviation: 0.04727126050826232
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        else:
          magnetism_coeff = np.exp(total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority
  return(priorities)




#score: {'data3D.txt': -0.2063734}
#standard deviation: 0.04154526847235435
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = np.exp(-total_spin) * (np.sum([val < 0 for val in interacting_spins]) > len(interacting_spins) // 2) * (1 + sum(val for val in interacting_spins if val > 0))
        else:
          priority = -np.exp(total_spin) * (np.sum([val > 0 for val in interacting_spins]) > len(interacting_spins) // 2) * (1 - sum(val for val in interacting_spins if val < 0))

        priorities[i*N*N+j*N+k][0] += priority
        priorities[i*N*N+j*N+k][1] -= 2*priority

  return(priorities)




#score: {'data3D.txt': 0.3178598}
#standard deviation: 0.051859307978028395
#island_id: 1
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
        
        # Add a new term to prioritize spins that are aligned with the local magnetism
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (np.exp(-total_spin) < 0.5)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 0
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0156898}
#standard deviation: 0.05369900013929496
#island_id: 3
#version_generated: 3
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          neighbor_priority = sum(J[d,i,(j+1)%N,k] if J[d,i,(j+1)%N,k] == h[i][j][k] else -J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += priority + neighbor_priority
          priorities[i*N*N+j*N+k][1] -= 2*priority - 2*neighbor_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          neighbor_priority = sum(J[d,i,(j+1)%N,k] if J[d,i,(j+1)%N,k] == h[i][j][k] else -J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= priority + neighbor_priority
          priorities[i*N*N+j*N+k][1] = -2*priority + 2*neighbor_priority

        layer_magnetism = sum(J[0,i,j,0] for j in range(N))
        priorities[i*N*N+j*N+k][0] += layer_magnetism
        priorities[i*N*N+j*N+k][1] -= layer_magnetism

  return(priorities)




#score: {'data3D.txt': -0.041784999999999996}
#standard deviation: 0.04683596540053381
#island_id: 3
#version_generated: 3
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * (len([val for val in interacting_spins if val < 0]) == len([val for val in interacting_spins if val > 0]))
          neighbor_priority = sum(J[d,i,(j+1)%N,k] if J[d,i,(j+1)%N,k] == h[i][j][k] else -J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += priority + neighbor_priority
          priorities[i*N*N+j*N+k][1] -= 2*priority - 2*neighbor_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          neighbor_priority = sum(J[d,i,(j+1)%N,k] if J[d,i,(j+1)%N,k] == h[i][j][k] else -J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= priority + neighbor_priority
          priorities[i*N*N+j*N+k][1] = -2*priority + 2*neighbor_priority

  return(priorities)




#score: {'data3D.txt': 0.27554060000000025}
#standard deviation: 0.04494805125519902
#island_id: 3
#version_generated: 3
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][0] += max(priority_up, priority_down)
          priorities[i*N*N+j*N+k][1] -= min(2*priority_up, 2*priority_down)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_down = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= max(priority_up, priority_down)
          priorities[i*N*N+j*N+k][1] = min(-2*priority_up, -2*priority_down)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_down = magnetism_coeff * (hamming_distance > 0.5) + total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetization_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += priority_up + neighbor_magnetization_coeff + sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= priority_down - neighbor_magnetization_coeff - sum(J[d,i,(j+1)%N,k] for d in [0,1,2])

  return(priorities)




#score: {'data3D.txt': -0.27339460000000004}
#standard deviation: 0.04378978523400178
#island_id: 1
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin)
        priorities[i*N*N+j*N+k][1] -= same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority based on the magnetism and interacting spins
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4936966000000001}
#standard deviation: 0.04168633623191177
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Calculate the number of nearest neighbors with the same spin
          same_spin_neighbors = sum(val > 0 for val in interacting_spins)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_neighbors > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          same_spin_neighbors = sum(val < 0 for val in interacting_spins)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (same_spin_neighbors > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.13678179999999998}
#standard deviation: 0.045650513565128704
#island_id: 1
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(same_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(same_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin
        
        # Add a new term that takes into account the number of sites with opposite spin as this one
        opposite_spin = len([val for val in interacting_spins if val == -J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(opposite_spin)
        priorities[i*N*N+j*N+k][1] -= opposite_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15155020000000002}
#standard deviation: 0.04569144733929972
#island_id: 1
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - same_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin)
        priorities[i*N*N+j*N+k][1] -= same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36961580000000005}
#standard deviation: 0.04152118531978585
#island_id: 1
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.34166820000000003}
#standard deviation: 0.04283657629596464
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(same_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(same_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3810258}
#standard deviation: 0.043458331472342564
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin)
        priorities[i*N*N+j*N+k][1] -= same_spin
        
        # Add a new term that takes into account the number of sites with different spin than this one
        diff_spin = len([val for val in interacting_spins if val != J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(-diff_spin)
        priorities[i*N*N+j*N+k][1] -= -diff_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26000660000000003}
#standard deviation: 0.0479269518792923
#island_id: 1
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate the number of sites with the same spin as this one
        same_spin = sum(val for val in interacting_spins if val == total_spin)
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin)
        priorities[i*N*N+j*N+k][1] -= same_spin
        
        # Calculate the number of sites with opposite spin as this one
        opposite_spin = sum(val for val in interacting_spins if val != total_spin)
        priorities[i*N*N+j*N+k][0] += np.exp(opposite_spin)
        priorities[i*N*N+j*N+k][1] -= opposite_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26561260000000025}
#standard deviation: 0.04566053132892782
#island_id: 3
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin)**2
          priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin)**2
          priorities[i*N*N+j*N+k][1] += 4 - 4*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetization_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += priorities[i*N*N+j*N+k][0] + neighbor_magnetization_coeff
          priorities[i*N*N+j*N+k][1] -= priorities[i*N*N+j*N+k][1] - neighbor_magnetization_coeff

  return(priorities)




#score: {'data3D.txt': -0.15155020000000002}
#standard deviation: 0.04569144733929972
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin_count = len([val for val in interacting_spins if val == J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin_count)
        priorities[i*N*N+j*N+k][1] -= same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.15155020000000002}
#standard deviation: 0.04569144733929972
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin_count)
        priorities[i*N*N+j*N+k][1] -= same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.04331100000000001}
#standard deviation: 0.046752522488096825
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_count > N//2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (same_spin_count > N//2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > N//2))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add a new term that takes into account the number of sites with the same spin as this one
        same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
        priorities[i*N*N+j*N+k][0] += np.exp(same_spin)
        priorities[i*N*N+j*N+k][1] -= same_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0848218}
#standard deviation: 0.04722652268333971
#island_id: 1
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          diff_spin = len([val for val in interacting_spins if val != J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(same_spin) - np.exp(diff_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          diff_spin = len([val for val in interacting_spins if val != J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(same_spin) + np.exp(diff_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          diff_spin = len([val for val in interacting_spins if val != J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - same_spin + diff_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + same_spin - diff_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin = len([val for val in interacting_spins if val == J[3,i,j,k]])
          diff_spin = len([val for val in interacting_spins if val != J[3,i,j,k]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - same_spin + diff_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + same_spin - diff_spin
    
  return(priorities)




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2716414}
#standard deviation: 0.04190049935311034
#island_id: 1
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - same_spin_count

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # Add the site's own magnetism to its priority
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.36961580000000005}
#standard deviation: 0.04152118531978585
#island_id: 1
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add the effect of the site itself
        same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_count > 0)
        priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.37068619999999997}
#standard deviation: 0.041562854203723784
#island_id: 1
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          neighbor_same_spin_count = sum(1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_count > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - same_spin_count
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          same_spin_count = sum(1 for val in interacting_spins if val == J[3,i,j,k])
          neighbor_same_spin_count = sum(1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val == J[3,i,j,k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (same_spin_count > 0.5) + total_spin + same_spin_count
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - same_spin_count
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_same_spin_count
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy - neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in J[::1,i,j,k] if val < 0])))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy - neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.4953614}
#standard deviation: 0.041285439443464814
#island_id: 2
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.49923540000000005}
#standard deviation: 0.04099421016241197
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        
        # Add more terms to account for the magnetism of neighboring sites
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy - neighbor_magnetism_coeff
        
        # Add more terms to account for the magnetism of the site itself and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4953614}
#standard deviation: 0.041285439443464814
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_flip_energy = sum(2 * J[d, i, j, k] * J[d, site_nbr, j, k] for d in [0,1,2])
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - spin_flip_energy + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + spin_flip_energy - neighbor_magnetism_coeff
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.44140179999999996}
#standard deviation: 0.04106351417937827
#island_id: 3
#version_generated: 2
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff
    
    # Add new term to account for the magnetism of the site itself
    if h[i][j][k] > 0:
      priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
      priorities[i*N*N+j*N+k][1] -= h[i][j][k]
    else:
      priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
      priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.40062060000000005}
#standard deviation: 0.05027439363771581
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate the absolute difference between the sum of spins and the total spin to penalize sites with strong interactions
        if total_spin > 0:
          abs_diff = abs(total_spin - sum(val for val in interacting_spins if val < 0))
          priorities[i*N*N+j*N+k][0] -= abs_diff
          priorities[i*N*N+j*N+k][1] += abs_diff
        
  return(priorities)




#score: {'data3D.txt': -0.4417658}
#standard deviation: 0.0458808316223671
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
  
  return(priorities)




#score: {'data3D.txt': -0.4913278}
#standard deviation: 0.04434832248417069
#island_id: 3
#version_generated: 3
#generate time22:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
  
  # Add new term to account for the magnetism of the site itself
  if h[i][j][k] > 0:
    priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2004798}
#standard deviation: 0.04513269138839385
#island_id: 3
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]))
          spin_coeff = np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff - spin_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]))
          spin_coeff = np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff - spin_coeff
 
  return(priorities)




#score: {'data3D.txt': -0.4913278}
#standard deviation: 0.04434832248417069
#island_id: 3
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
 
  # Add new term to account for the magnetism of the site itself
  if h[i][j][k] > 0:
    priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] = -h[i][j][k]
 
  return(priorities)




#score: {'data3D.txt': -0.30073460000000013}
#standard deviation: 0.0467573823351992
#island_id: 3
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.30073460000000013}
#standard deviation: 0.0467573823351992
#island_id: 3
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3263854}
#standard deviation: 0.049396888027890974
#island_id: 3
#version_generated: 3
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4077506000000003}
#standard deviation: 0.04815253596270917
#island_id: 3
#version_generated: 3
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44287020000000005}
#standard deviation: 0.04102355996205108
#island_id: 3
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff
  
  # Add new term to account for the magnetism of the site itself
  if h[i][j][k] > 0:
    priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.44287020000000005}
#standard deviation: 0.04102355996205108
#island_id: 3
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff
  
  # Add new term to account for the magnetism of the site itself
  if h[i][j][k] > 0:
    priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
    priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26198060000000034}
#standard deviation: 0.04816815611625589
#island_id: 2
#version_generated: 2
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4417658}
#standard deviation: 0.0458808316223671
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.4849210000000001}
#standard deviation: 0.040857166311431825
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate interactions with nearest neighbors
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len(site_neighbors))
          if sum(site_neighbors) < 0:
            neighbor_magnetism_coeff *= -1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4729714000000001}
#standard deviation: 0.0415614747337002
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1
          elif site_neighbors[d] > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.008363800000000001}
#standard deviation: 0.04715376813744582
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Calculate total interactions with nearest neighbors
        total_neighbor_interactions = 0
        for d in range(3):
          total_neighbor_interactions += np.abs(J[d,i,(j+1)%N,k]) + np.abs(J[d,(i+1)%N,j,k])
        
        priorities[i*N*N+j*N+k][0] += np.exp(total_neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= total_neighbor_interactions
  
  return(priorities)




#score: {'data3D.txt': -0.26198060000000034}
#standard deviation: 0.04816815611625589
#island_id: 2
#version_generated: 3
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)

          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26198060000000034}
#standard deviation: 0.04816815611625589
#island_id: 2
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26198060000000034}
#standard deviation: 0.04816815611625589
#island_id: 2
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.21580100000000002}
#standard deviation: 0.04461656417744424
#island_id: 2
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          
          # New term to account for the spin of the site itself
          self_spin = np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + self_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          
          # New term to account for the spin of the site itself
          self_spin = -np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + self_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
          # Add new term to account for the spin of the site itself
          priorities[i*N*N+j*N+k][0] -= self_spin
          priorities[i*N*N+j*N+k][1] += self_spin
  
  return(priorities)




#score: {'data3D.txt': -0.26198060000000034}
#standard deviation: 0.04816815611625589
#island_id: 2
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4417658}
#standard deviation: 0.0458808316223671
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




