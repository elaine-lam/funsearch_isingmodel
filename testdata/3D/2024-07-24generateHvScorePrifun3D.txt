#score: {'data3D.txt': -0.0024282}
#standard deviation: 0.04654176237273359
#island_id: 1
#version_generated: 3
#generate time00:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N + j][0] += np.exp(-h[i][j][k])
          priorities[i*N + j][1] -= h[i][j][k]
        elif h[i][j][k] < 0:
          priorities[i*N + j][0] -= np.exp(h[i][j][k])
          priorities[i*N + j][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*spin_magnetism
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.23075180000000017}
#standard deviation: 0.04760910035654946
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.33962779999999976}
#standard deviation: 0.04562009543128991
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        site_magnetism = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff + site_magnetism
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3327961999999998}
#standard deviation: 0.04548874262452194
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.2990554000000001}
#standard deviation: 0.04644272871871332
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        interaction_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - interaction_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff + interaction_coeff
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.46250700000000006}
#standard deviation: 0.04256300025844043
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]

  return(priorities)




#score: {'data3D.txt': -0.4017014}
#standard deviation: 0.042320664432874876
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]

  return priorities




#score: {'data3D.txt': -0.4025982}
#standard deviation: 0.04234428647125844
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4017014}
#standard deviation: 0.042320664432874876
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]
  
  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]
  
  return priorities




#score: {'data3D.txt': -0.21358900000000028}
#standard deviation: 0.04669823978481415
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Additional improvement: 
          # Prioritize assigning spin to sites with same magnetism as the current site
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin + sum(val for val in site_neighbors if val > 0)
          
        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.32277539999999977}
#standard deviation: 0.044773529622311424
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.32277539999999977}
#standard deviation: 0.044773529622311424
#island_id: 1
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.49438059999999995}
#standard deviation: 0.042496233052354185
#island_id: 0
#version_generated: 2
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.38466859999999997}
#standard deviation: 0.04114459349708051
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N ** 2 + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N ** 2 + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin

        for d in range(3):
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i * N ** 2 + j * N + k][0] += neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.30135740000000005}
#standard deviation: 0.04209836653885754
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in [0,1]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][d] += neighbor_magnetism_coeff
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14457380000000022}
#standard deviation: 0.04854912227383726
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][0] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][0]
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][0]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][0] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - h[i][j][0]
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin + h[i][j][0]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.30633940000000004}
#standard deviation: 0.04351724586459947
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = ((i + k%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        elif h[i][j][k] < 0:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = ((i + k%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) - total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 2
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.20584539999999998}
#standard deviation: 0.04688170708112067
#island_id: 2
#version_generated: 2
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14279260000000002}
#standard deviation: 0.05085330495887166
#island_id: 3
#version_generated: 2
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in [0,1]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5351134}
#standard deviation: 0.03919921402834501
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (total_spin > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.36011300000000007}
#standard deviation: 0.04288802153282429
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New: add term based on sum of absolute values of interacting spins
        priorities[i*N*N+j*N+k][0] += abs(sum(val for val in interacting_spins))
        priorities[i*N*N+j*N+k][1] -= abs(sum(val for val in interacting_spins if val > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        hamming_weight = int(hamming_distance > 0.5)
        site_magnetism = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += (hamming_weight * magnetism_coeff) + (site_magnetism - total_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5043118000000001}
#standard deviation: 0.041472838590576364
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count += sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.2901197999999999}
#standard deviation: 0.04771008622880491
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
        
  # Calculate the priority based on the site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.36506819999999995}
#standard deviation: 0.044656970214738044
#island_id: 3
#version_generated: 3
#generate time01:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46594939999999996}
#standard deviation: 0.04221089100741656
#island_id: 3
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0029658}
#standard deviation: 0.046977310165227645
#island_id: 3
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.35048019999999996}
#standard deviation: 0.04124170423200283
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_site = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        if h[site_nbr][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin_site))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * abs(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.236287}
#standard deviation: 0.04342625923332564
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return priorities




#score: {'data3D.txt': -0.04799460000000003}
#standard deviation: 0.04944132937978104
#island_id: 2
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 3 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 6 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 3 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 6 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Calculate the priority based on the site's magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07922939999999999}
#standard deviation: 0.04935483821916551
#island_id: 3
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in [0,1]:
          site_neighbors = []
          if d == 0 and k > 0:
            site_neighbors.append(J[1,i,j,k-1])
          elif d == 0 and k < N-1:
            site_neighbors.append(J[1,i,j,k+1])
          elif d == 1 and i > 0:
            site_neighbors.append(J[2,(i-1)%N,j,k])
          elif d == 1 and i < N-1:
            site_neighbors.append(J[2,(i+1)%N,j,k])
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5043118000000001}
#standard deviation: 0.041472838590576364
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count += sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4332122}
#standard deviation: 0.039882412805145075
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count = sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3669634}
#standard deviation: 0.04285286618698918
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          if h[i][j][k] > 0:
            priorities[i*N + j][0] += np.exp(h[i][j][0])
            priorities[i*N + j][1] -= h[i][j][0]
          elif h[i][j][k] < 0:
            priorities[i*N + j][0] -= np.exp(h[i][j][0])
            priorities[i*N + j][1] = -h[i][j][0]

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            priorities[i*N + j][0] += np.exp(h[i][j][d])
            priorities[i*N + j][1] -= h[i][j][d]
        else:
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            priorities[i*N + j][0] -= np.exp(h[i][j][d])
            priorities[i*N + j][1] = -h[i][j][d]

  return(priorities)




#score: {'data3D.txt': -0.4226014}
#standard deviation: 0.04152348200765442
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.39105100000000004}
#standard deviation: 0.04255599604051114
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N**2+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N**2+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N**2+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N**2+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N**2+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N**2+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0055569999999999994}
#standard deviation: 0.047605035353416134
#island_id: 1
#version_generated: 3
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(val for val in interacting_spins if val < 0)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.26714380000000004}
#standard deviation: 0.04845391874306967
#island_id: 1
#version_generated: 3
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.46594939999999996}
#standard deviation: 0.04221089100741656
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.5101622}
#standard deviation: 0.04090296090945006
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4983746}
#standard deviation: 0.042414806316191045
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)

        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20893740000000022}
#standard deviation: 0.048496734335829225
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3955258}
#standard deviation: 0.043135916060285544
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.474787}
#standard deviation: 0.041359001329819366
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0029658}
#standard deviation: 0.046977310165227645
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > sum(1 for val in interacting_spins if val > 0))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > sum(1 for val in interacting_spins if val > 0))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3666922000000001}
#standard deviation: 0.04460282165020504
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4559234000000003}
#standard deviation: 0.046763637288388935
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]

        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add neighbor interactions with magnetism
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]

            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add neighbor interactions with magnetism
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]

            if h[i][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)

  return priorities




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.4183650000000003}
#standard deviation: 0.04803587341768649
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
        
        # Add bias term
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
  
  return priorities




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism and spin value
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions and spin value
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.4571482000000002}
#standard deviation: 0.04579450793228376
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
        
        # Add neighbor magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - (sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
  
  return priorities




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.5358278000000001}
#standard deviation: 0.03964554637232283
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.474787}
#standard deviation: 0.041359001329819366
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2990274000000001}
#standard deviation: 0.04612857259053221
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5358278000000001}
#standard deviation: 0.03964554637232283
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)

        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43909180000000014}
#standard deviation: 0.04811941908169716
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2367586000000002}
#standard deviation: 0.049729270314775385
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin) / N)
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate magnetism coefficients and hamming distances
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate site magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate site neighbors' magnetization
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Calculate site magnetization with neighborhood and h
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.20893740000000022}
#standard deviation: 0.048496734335829225
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])

        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': 0.07246979999999997}
#standard deviation: 0.04791097293898341
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate the priority values for the neighbors
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) - total_spin
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.24824580000000002}
#standard deviation: 0.045293634236612104
#island_id: 3
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5270058}
#standard deviation: 0.03991027344381394
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4928978}
#standard deviation: 0.04171011957738793
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Remove duplicate calculations for site neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5035598}
#standard deviation: 0.04131457786254145
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0])))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2159042}
#standard deviation: 0.04309388706487267
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        if i < N-1 and j < N-1 and k < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.24824580000000002}
#standard deviation: 0.045293634236612104
#island_id: 3
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049936999999999995}
#standard deviation: 0.045422850538027665
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N, i]
        for site in site_neighbors:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        site_neighbors = [(i+1)%N, (j+1)%N, i]
        for site in site_neighbors:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        if k > 0:
          site_neighbors = [(i+1)%N, (j+1)%N, i]
          for site in site_neighbors:
            J_val = J[3,i,site,k-1] if site == (i+1)%N else J[4,i,j,k-1] if site == (j+1)%N else J[5,i,j,site]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
            priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3368566000000003}
#standard deviation: 0.04969523555070446
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + 1
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - 1
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin + 1
        
  return priorities




#score: {'data3D.txt': -0.22800260000000025}
#standard deviation: 0.04763292593616311
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
  
  return priorities




#score: {'data3D.txt': -0.0033894}
#standard deviation: 0.04694445321483679
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3524102000000003}
#standard deviation: 0.04863536178502222
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2]) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2]) - np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3235758000000003}
#standard deviation: 0.04984060046147117
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        # Add the site magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': 0.07246979999999997}
#standard deviation: 0.04791097293898341
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate the priority values for the neighbors
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) - total_spin
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.22800260000000025}
#standard deviation: 0.04763292593616311
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
  
  return priorities




#score: {'data3D.txt': -0.29026860000000015}
#standard deviation: 0.04840507219331462
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for d in [0,1]:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1568338}
#standard deviation: 0.04575847132018288
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total
        
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0072774}
#standard deviation: 0.047595297763959835
#island_id: 3
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0410938}
#standard deviation: 0.0493548186255405
#island_id: 3
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        for d in range(3):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.18311860000000002}
#standard deviation: 0.047175512864620774
#island_id: 3
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.24832980000000032}
#standard deviation: 0.049066915859466854
#island_id: 1
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
          
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31840140000000006}
#standard deviation: 0.044322795467343884
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_sum = np.sum(J[:, i, j, k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_sum
          priorities[i*N*N+j*N+k][1] -= total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_sum
          priorities[i*N*N+j*N+k][1] = -total_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3561538000000003}
#standard deviation: 0.04902511178528816
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(J[d, site_nbr, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(J[d, site_nbr, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.3631238000000003}
#standard deviation: 0.0447049607265234
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, site_nbr, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin + 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 2
        
  return priorities




#score: {'data3D.txt': -0.0476338}
#standard deviation: 0.046682693340894546
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0,i,j,k],J[1,(i+1)%N,j,k],J[2,i,(j+1)%N,k]] if val < 0])
        pos_interactions = len([val for val in [J[0,i,j,k],J[1,(i+1)%N,j,k],J[2,i,(j+1)%N,k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': 0.07002900000000001}
#standard deviation: 0.04689732016864077
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0056302}
#standard deviation: 0.04776897746404041
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.060711800000000024}
#standard deviation: 0.047903200944822054
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val < 0])) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.014241799999999999}
#standard deviation: 0.04584453438262843
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.0072774}
#standard deviation: 0.047595297763959835
#island_id: 3
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.14771220000000002}
#standard deviation: 0.04261923147078089
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        magnetization = np.sum([h[i][j][k] for i, j, k in itertools.product(range(N), range(N), range(N))])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -magnetization
          priorities[i*N*N+j*N+k][1] -= magnetization
        else:
          priorities[i*N*N+j*N+k][0] -= -magnetization
          priorities[i*N*N+j*N+k][1] = magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.04744619999999999}
#standard deviation: 0.049298780365846784
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) + h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0458818}
#standard deviation: 0.04975173473116289
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) + h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.0623034}
#standard deviation: 0.04998737028930408
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) - h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21641700000000022}
#standard deviation: 0.050153729980929644
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3253510000000001}
#standard deviation: 0.04724477239864746
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Additional term to account for nearest neighbor interactions
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (neg_interactions > pos_interactions))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional term to account for magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1769402000000003}
#standard deviation: 0.05036294336076875
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neg_interactions > pos_interactions) + total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (neg_interactions > pos_interactions) + total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.29442940000000023}
#standard deviation: 0.05014911261069333
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (pos_interactions - neg_interactions) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (neg_interactions - pos_interactions) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.5228126}
#standard deviation: 0.03996013765291607
#island_id: 1
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3253510000000001}
#standard deviation: 0.04724477239864746
#island_id: 1
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])

        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Additional term to account for nearest neighbor interactions
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (neg_interactions > pos_interactions))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional term to account for magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4972918}
#standard deviation: 0.04124089442240553
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors if val < 0) > sum(1 for val in interacting_spins if val < 0)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors if val > 0) < sum(1 for val in interacting_spins if val > 0)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1847754}
#standard deviation: 0.05021847622977026
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Improved calculation of neighbor magnetism coefficient
        neighbor_magnetism_coeff = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) / len([val for val in interacting_spins if val < 0])
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        # Improved calculation of magnetism coefficient
        magnetism_coeff = np.exp(h[i][j][k]) * (h[i][j][k] > 0) + (-1) * (h[i][j][k] < 0)
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.5384482}
#standard deviation: 0.03923028672798607
#island_id: 0
#version_generated: 2
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3470737999999996}
#standard deviation: 0.04395288606633242
#island_id: 1
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 4 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -4 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -8 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = 8 * (neg_interactions - pos_interactions)
        
        # Add the magnetism term
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.38299060000000007}
#standard deviation: 0.04615623155804642
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        
        # Add the magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.25082100000000024}
#standard deviation: 0.046545831166711384
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the interaction strength
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + (neg_interactions - pos_interactions) * J[0, i, j, k]
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - (pos_interactions - neg_interactions) * J[0, i, j, k]
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions) * J[0, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - (neg_interactions - pos_interactions) * J[0, i, j, k]
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + (pos_interactions - neg_interactions) * J[0, i, j, k]
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions) * J[0, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.019520600000000242}
#standard deviation: 0.049221844496524114
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions)
        
  return(priorities)




#score: {'data3D.txt': -0.408851}
#standard deviation: 0.04583480335945601
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0766822}
#standard deviation: 0.04724068080754129
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        total_site_magnetism = h[i][j][k] + sum(J[d,i,j,k] for d in [3,4,5])
        if total_site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_site_magnetism)
          priorities[i*N*N+j*N+k][1] -= total_site_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_site_magnetism)
          priorities[i*N*N+j*N+k][1] += total_site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.2527746}
#standard deviation: 0.04556095823004605
#island_id: 3
#version_generated: 3
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42277539999999997}
#standard deviation: 0.043217879573620915
#island_id: 3
#version_generated: 3
#generate time04:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors_1d = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors_1d if val < 0) > sum(1 for val in interacting_spins if val < 0)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors_1d)
        priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4867994}
#standard deviation: 0.041241506757634355
#island_id: 0
#version_generated: 2
#generate time04:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5372013999999999}
#standard deviation: 0.03953245297271597
#island_id: 0
#version_generated: 2
#generate time04:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032470000000000008}
#standard deviation: 0.04703315756995271
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.06962940000000001}
#standard deviation: 0.048736997605925626
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2

        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.1178762}
#standard deviation: 0.04834775189768393
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.26180540000000013}
#standard deviation: 0.04787520120939439
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (3 - total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 + 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (3 + total_spin)
          priorities[i*N*N+j*N+k][1] = 3 - 3*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return priorities




#score: {'data3D.txt': -0.2406462000000001}
#standard deviation: 0.05163958622568544
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        
        # Calculate the priority values
        if sum(val for val in site_neighbors) >= 2:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        elif sum(val for val in site_neighbors) <= -2:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum([val if val > 0 else -val for val in site_neighbors]))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.13420180000000032}
#standard deviation: 0.04947274357421469
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement: consider the number of neighboring sites with same spin
        num_same_spin_neighbors = len([val for val in site_neighbors if val == J[0, i, j, k]])
        priorities[i*N*N+j*N+k][0] += np.exp(-num_same_spin_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*num_same_spin_neighbors

  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return priorities




#score: {'data3D.txt': -0.4961702}
#standard deviation: 0.04116157567392191
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2912741999999999}
#standard deviation: 0.04652442169828659
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.44130939999999996}
#standard deviation: 0.0414878294399695
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4983954}
#standard deviation: 0.041370421545350484
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1568338}
#standard deviation: 0.04575847132018288
#island_id: 3
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total

        else:
          priority_total = np.sum([J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

  return priorities




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.46816740000000007}
#standard deviation: 0.040473716128371515
#island_id: 2
#version_generated: 2
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0)) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46816740000000007}
#standard deviation: 0.040473716128371515
#island_id: 2
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0)) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priority_total = np.zeros((N**3, 2))
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          priority_total[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0))
          priority_total[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 2
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46080100000000007}
#standard deviation: 0.041150725376352726
#island_id: 2
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.369459}
#standard deviation: 0.04057767365189877
#island_id: 3
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        total_spin_neighbors = sum(J[d,site_nbr,i,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.4932626}
#standard deviation: 0.04194558428774118
#island_id: 3
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4718414}
#standard deviation: 0.038532275381036096
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.3641098000000001}
#standard deviation: 0.047768571089786646
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          if J[d,i,j,k] < 0:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4718414}
#standard deviation: 0.038532275381036096
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.3641098000000001}
#standard deviation: 0.047768571089786646
#island_id: 3
#version_generated: 3
#generate time05:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          if J[d,i,j,k] < 0:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4245346000000001}
#standard deviation: 0.041271265583211765
#island_id: 3
#version_generated: 3
#generate time05:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          if J[d,i,j,k] < 0:
            site_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 2
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5045362}
#standard deviation: 0.041113516628476336
#island_id: 1
#version_generated: 2
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.40828020000000004}
#standard deviation: 0.041899691740632176
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        if site_nbr == i:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        elif site_nbr == (i+1)%N:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
        elif site_nbr == (i-1)%N:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.312785}
#standard deviation: 0.0456207748180585
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        # Additional improvement: take into account the magnetization of neighboring sites
        for site in site_neighbors:
          if h[site_nbr][i%N][j%N] > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.49948220000000004}
#standard deviation: 0.0408856963149706
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (h[site_nbr][i%N][k] > 0)
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff * (h[site_nbr][i%N][k] > 0)
          
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.0912406}
#standard deviation: 0.04638194726011404
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        site_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*site_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4644582}
#standard deviation: 0.042403716025367404
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # add the magnetism coefficient
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= np.exp(-h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.47078580000000003}
#standard deviation: 0.044853058740291066
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.23535180000000003}
#standard deviation: 0.05303813379786284
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
          for neighbor in site_neighbors:
            if J[d,neighbor[0],neighbor[1],neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_nbrs:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.281755}
#standard deviation: 0.05297517545983213
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
          for neighbor in site_neighbors:
            if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4617798}
#standard deviation: 0.045712929811597074
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4238102}
#standard deviation: 0.04642644866840452
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_3d = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors_3d:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, i, (j+1)%N, k], [(i+1)%N, j, k], [i, (j+1)%N, k]
        for neighbor in site_neighbors:
          if J[0, neighbor[0], neighbor[1], neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors_2d = [(i+1)%N, i, (j+1)%N], [(i+1)%N, j], [i, (j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0, neighbor[0], neighbor[1], k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.48002859999999997}
#standard deviation: 0.04112038450744351
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_neighbor = J[2,i,j,(k+1)%N]
        site_magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time06:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time06:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44477739999999993}
#standard deviation: 0.04489506976539852
#island_id: 0
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0]))
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_3d = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors_3d:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5370874}
#standard deviation: 0.039752541569565085
#island_id: 3
#version_generated: 2
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4230534}
#standard deviation: 0.04532318510916902
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47726979999999997}
#standard deviation: 0.04152077321004511
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New improvement: add a term based on the magnetism at the current site
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5124034000000001}
#standard deviation: 0.04123906240980753
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5147986}
#standard deviation: 0.04028881678629939
#island_id: 3
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        total_spin_sum = np.sum(J[0,i,j,k])
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * total_spin_sum
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * total_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.5138978000000001}
#standard deviation: 0.04207246219512236
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5007078}
#standard deviation: 0.040375926728187926
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors_magnetism = [h[site_nbr][i%N][k], h[(i+1)%N][j][k], h[i][(k+1)%N][j]]
        priorities[i*N*N+j*N+k][0] += np.exp(sum(neighbors_magnetism))
        priorities[i*N*N+j*N+k][1] -= sum(neighbors_magnetism)
        
  return(priorities)




#score: {'data3D.txt': -0.5138978000000001}
#standard deviation: 0.04207246219512236
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.24813220000000002}
#standard deviation: 0.04250175435390873
#island_id: 3
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(3):
          site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.5270058}
#standard deviation: 0.03991027344381394
#island_id: 0
#version_generated: 3
#generate time06:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        if any(abs(val) > 1 for val in interacting_spins):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 0
        if any(val < 0 for val in interacting_spins):
          neighbor_magnetism_coeff += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        
        neighbor_magnetism_coeff = np.sum(np.abs(J[:,i,j,k]), axis=0)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.40289620000000004}
#standard deviation: 0.04414803082312958
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.40289620000000004}
#standard deviation: 0.04414803082312958
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional priority calculation
        site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.44423419999999997}
#standard deviation: 0.04328755745430781
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate distance from each spin to the center of the grid
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)

        # Prioritize spins closer to the center of the grid
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center)
        priorities[i*N*N+j*N+k][1] -= dist_to_center

  return priorities




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4712014000000002}
#standard deviation: 0.044354917179947474
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.46302620000000005}
#standard deviation: 0.043795016994630794
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.00042579999999999994}
#standard deviation: 0.044740300561797744
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvement: calculate the number of neighbors that are aligned with the current spin and the total magnetization
        num_aligned_neighbors = sum(1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0)
        priorities[i*N*N+j*N+k][0] += 2 * (num_aligned_neighbors - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4967498000000001}
#standard deviation: 0.04427399959298911
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # Additional improvement
        if i == N-1 and j == N-1 and k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.4949106}
#standard deviation: 0.04148965229596411
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.029304200000000002}
#standard deviation: 0.04742723418416891
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate the distance from each spin to its neighbors
        distances = []
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_distances = np.sqrt((i - ((d+1)%2))**2 + (j - 0)**2 + (k - 0)**2)
          distances.append(neighbor_distances)

        # Prioritize spins closer to their neighbors
        for distance in distances:
          priorities[i*N*N+j*N+k][0] += np.exp(-distance)
          priorities[i*N*N+j*N+k][1] -= distance

  return priorities




#score: {'data3D.txt': -0.2270874}
#standard deviation: 0.04315819738172576
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)
        
        # Prioritize spins that are closer to the center of the grid and have higher magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center) * np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= dist_to_center - abs(h[i][j][k])
  
  return priorities




#score: {'data3D.txt': -0.44423419999999997}
#standard deviation: 0.04328755745430781
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate distance from each spin to the center of the grid
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)

        # Prioritize spins closer to the center of the grid
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center)
        priorities[i*N*N+j*N+k][1] -= dist_to_center

  return priorities




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.48356420000000006}
#standard deviation: 0.041610105964296706
#island_id: 0
#version_generated: 3
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.40886700000000004}
#standard deviation: 0.047902902949612566
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N,j,k], [i,(j+1)%N,k], [(i+1)%N,(j+1)%N,k]
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in [J[d,neighbor[0],neighbor[1],neighbor[2]] for d in [0,1,2]] if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in [J[d,neighbor[0],neighbor[1],neighbor[2]] for d in [0,1,2]] if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49317660000000013}
#standard deviation: 0.04276040659816041
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.506773}
#standard deviation: 0.043632984209196604
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.36848100000000006}
#standard deviation: 0.0437250660262509
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.466317}
#standard deviation: 0.04710316964918603
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.005967000000000044}
#standard deviation: 0.04610356852782657
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4635354}
#standard deviation: 0.04254398696455235
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.17582100000000003}
#standard deviation: 0.04564686275090546
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4635354}
#standard deviation: 0.04254398696455235
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.44820500000000013}
#standard deviation: 0.044002285565638524
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.43769420000000026}
#standard deviation: 0.04674303420147221
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_direction = np.sign(h[i][j][k])
        if spin_direction == 1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.16233260000000013}
#standard deviation: 0.04620070710757575
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin ** 2
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin ** 2
          priorities[i*N*N+j*N+k][1] += 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.05977740000000006}
#standard deviation: 0.11615759367876051
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  # Another additional improvement
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return priorities




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 2
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 2
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4697422}
#standard deviation: 0.04114674882855266
#island_id: 2
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5007078}
#standard deviation: 0.040375926728187926
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors_magnetism = [h[site_nbr][i%N][k], h[(i+1)%N][j][k], h[i][(k+1)%N][j]]
        priorities[i*N*N+j*N+k][0] += np.exp(sum(neighbors_magnetism))
        priorities[i*N*N+j*N+k][1] -= sum(neighbors_magnetism)
        
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # New improvements
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        # New improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # New improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvements
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvements
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
        # Improvement based on site interactions
        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4816502}
#standard deviation: 0.04188654199095457
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors) < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4496598000000002}
#standard deviation: 0.04563889288709796
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= spin_coeff - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += spin_coeff + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.40324220000000005}
#standard deviation: 0.04173520838764316
#island_id: 2
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += magnetism
          priorities[i*N*N+j*N+k][1] -= magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism
          priorities[i*N*N+j*N+k][1] += magnetism
  
  return priorities




#score: {'data3D.txt': -0.19323220000000021}
#standard deviation: 0.04908278438678882
#island_id: 2
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.13954660000000008}
#standard deviation: 0.0482783494792438
#island_id: 0
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Another additional improvement
        total_spin_sum = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_sum = sum(h[site_nbr][j][k] for _ in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum - 3 * site_nbr_sum / N**3))
        
  return priorities




#score: {'data3D.txt': -0.4982022}
#standard deviation: 0.04257542243078746
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3282598000000004}
#standard deviation: 0.05008388307589577
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Priority based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k])) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i][j][k])) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.19418100000000008}
#standard deviation: 0.051970690191684
#island_id: 0
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Another additional improvement
        if h[i][j][k] > 0:
          if (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            total_spin_coeff = 2 * total_spin / abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 * total_spin
        else:
          if (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 * total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            total_spin_coeff = 2 * total_spin / abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        
  return priorities




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
          
  return priorities




#score: {'data3D.txt': -0.23432380000000036}
#standard deviation: 0.04476066569612207
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4081586000000001}
#standard deviation: 0.04393126183072825
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4250734000000001}
#standard deviation: 0.044614149464491645
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.06330780000000001}
#standard deviation: 0.21953395295297717
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  # New term
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  
  return(priorities)




#score: {'data3D.txt': 0.07439220000000005}
#standard deviation: 0.047381750697499565
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return priorities




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2977354000000003}
#standard deviation: 0.049791340882125265
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.16192500000000007}
#standard deviation: 0.046661363192688654
#island_id: 0
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * total_spin / abs(total_spin)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        for d in range(3):
          site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
          neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.3156405999999998}
#standard deviation: 0.047314717283737394
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        if h[i][j][k] > 0 and total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3144554000000003}
#standard deviation: 0.046560523309344355
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
          
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.4083394}
#standard deviation: 0.04199644708353315
#island_id: 1
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_sum = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[d,(i+1)%N,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_sum > 0) - total_spin
        priorities[i*N*N+j*N+k][1] -= 1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4322438}
#standard deviation: 0.04138919329438543
#island_id: 1
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
  return priorities




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.43367100000000003}
#standard deviation: 0.05643875724181035
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
      
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+N-1][0] += 2*total_spin
        priorities[i*N*N+j*N+N-1][1] -= 2 - total_spin
      else:
        priorities[i*N*N+j*N+N-1][0] -= 2 + total_spin
        priorities[i*N*N+j*N+N-1][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14851940000000002}
#standard deviation: 0.08760719481663591
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    for d in [0,1]:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N][d] > 0:
        priorities[i][d] += 1 + total_spin
        priorities[i][1-d] -= 1 - total_spin
      else:
        priorities[i][d] -= 1 + total_spin
        priorities[i][1-d] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5255634000000001}
#standard deviation: 0.041010218000395955
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3658178000000003}
#standard deviation: 0.04881379521364836
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1317714000000001}
#standard deviation: 0.04715481589445557
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
          priorities[i*N*N+j*N+k][1] += total_spin_contrib
        else:
          site_interaction_coeff = 2 * sum(val for val in interacting_spins) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= site_interaction_coeff
          priorities[i*N*N+j*N+k][1] += site_interaction_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff

  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff

  return(priorities)




#score: {'data3D.txt': -0.5253858}
#standard deviation: 0.042492344703016806
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0) if h[i][j][k] > 0 else -np.exp(-total_h)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
  
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4139198000000002}
#standard deviation: 0.04650348038545073
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
        if i < N-1 and j < N-1 and k < N-1:  # check for neighboring sites
          adjacent_sites = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
          if sum(val for val in adjacent_sites) < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in adjacent_sites if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in adjacent_sites if val > 0]) - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.38685660000000044}
#standard deviation: 0.047225075928366694
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for neighbor in site_neighbors:
          if h[i][j][k] > 0 and neighbor < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          elif h[i][j][k] < 0 and neighbor > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return priorities




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20538340000000005}
#standard deviation: 0.0458472307172418
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3092614000000002}
#standard deviation: 0.04631319326110001
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= np.exp(-total_h) * (total_spin < 0)
  
  return priorities




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44424620000000004}
#standard deviation: 0.045206160482394425
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.47838660000000016}
#standard deviation: 0.043234359720481584
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.48180700000000004}
#standard deviation: 0.04082668332108304
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (1 + total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (1 + total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0815902}
#standard deviation: 0.07426463723711306
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
      
  for i in range(N**3):
    site_neighbors = [J[0,i//N%N,(i//N)%N,0], J[1,(i//N+1)%N,(i//N)%N,0], J[2,i//N%N,(i//N)%N,0]]
    if sum(h[i//N%N][i//N%N][k] for k in range(N)) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.42442900000000033}
#standard deviation: 0.047812994875870304
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0031834000000000003}
#standard deviation: 0.04699338341128462
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
        return priorities




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.14834780000000003}
#standard deviation: 0.04597185873074961
#island_id: 3
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  return(priorities)




#score: {'data3D.txt': -0.2200830000000002}
#standard deviation: 0.05247079140817299
#island_id: 3
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k]) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k] + total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1123462}
#standard deviation: 0.052688832455844
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.43049460000000017}
#standard deviation: 0.04511069729942112
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3269350000000002}
#standard deviation: 0.04458518290867495
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.002945}
#standard deviation: 0.04675148997625637
#island_id: 2
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[0,i//N%N,i%N,0], J[1,(i//N+1)%N,i%N,0], J[2,i//N%N,i%N,0]]
    total_spin = sum(J[d,i//N%N,i%N,0] for d in [0,1,2])
    
    if h[site_nbr][i//N%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.08292859999999999}
#standard deviation: 0.05943515779435603
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      priorities[i][1] -= 1 - sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
    else:
      priorities[i][0] -= 1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      priorities[i][1] = -1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      
  for i in range(N**3):
    site_neighbors = [J[0,i//N%N,(i//N)%N,0], J[1,(i//N+1)%N,(i//N)%N,0], J[2,i//N%N,(i//N)%N,0]]
    if sum(h[i//N%N][i//N%N][k] for k in range(N)) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.0004045999999999992}
#standard deviation: 0.0470033098711144
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      priorities[i][1] -= 2 - 2*np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) - 2*np.sum([h[site_nbr][k][0] for k in range(N)])
    else:
      priorities[i][0] -= np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      priorities[i][1] = -2 + 2*np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + 2*np.sum([h[site_nbr][k][0] for k in range(N)])
      
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.09839340000000002}
#standard deviation: 0.041808713881677825
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        # Add interactions with neighboring sites
        for x in range(-1, 2):
          for y in range(-1, 2):
            if i+x >= N or j+y >= N:
              continue
            site = (i+x) * N*N + (j+y) * N + k
            priorities[i*N*N+j*N+k][0] += np.exp(h[i+x][j+y][k]) * len([val for val in [J[0,i+x,j+y,k], J[1,(i+x+1)%N,j+y,k], J[2,i+x,(j+y+1)%N,k]] if val < 0])
            priorities[i*N*N+j*N+k][1] -= h[i+x][j+y][k]
        
  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5106282}
#standard deviation: 0.0422656537245078
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5162774000000002}
#standard deviation: 0.042542108660008855
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.33196979999999965}
#standard deviation: 0.04521094743488571
#island_id: 3
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbor_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          
          site_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*site_neighbor_spin
        
  return priorities




#score: {'data3D.txt': 0.22193660000000032}
#standard deviation: 0.04520538840049934
#island_id: 3
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        # Calculate the probability of being in a low energy state
        if h[i][j][k] > 0:
          probabilities = np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]], axis=0))
        else:
          probabilities = np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]], axis=0))
        
        # Update the priorities based on the probability
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] *= probabilities
          priorities[i*N*N+j*N+k][1] *= (1 - probabilities)
        else:
          priorities[i*N*N+j*N+k][0] = (1-probabilities) * priorities[i*N*N+j*N+k][0]
          priorities[i*N*N+j*N+k][1] = probabilities * priorities[i*N*N+j*N+k][1]
  
  return priorities




#score: {'data3D.txt': -0.4103446000000001}
#standard deviation: 0.050018970109749365
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3004070000000001}
#standard deviation: 0.04694090828903932
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3624178000000002}
#standard deviation: 0.04726851767466376
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_sum = sum(J[0,i,j,k] for j in range(N) for k in range(N))
        site_avg = site_sum / (N**2)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_avg)) * len([val for val in interacting_spins if val < 0]) + site_avg
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_avg
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_avg)) * len([val for val in interacting_spins if val > 0]) + site_avg
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_avg
        
  return(priorities)




#score: {'data3D.txt': -0.3004070000000001}
#standard deviation: 0.04694090828903932
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3950458}
#standard deviation: 0.0397398442669319
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # New priority rule: prioritize spins that have the same value as their neighbors
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], J[1,(i//N+1)%N,i%N, (i//N//N)%N], J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if site_nbrs.count(J[0,(i//N)%N,i%N, (i//N//N)%N]) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], J[1,(i//N+1)%N,i%N, (i//N//N)%N], J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.41461020000000004}
#standard deviation: 0.04315232109585764
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0027982000000000003}
#standard deviation: 0.04696454276110862
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if site_nbrs.count(0) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    elif site_nbrs.count(1) > 0:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      if h[(i//N)%N,(i%N)][(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.30956340000000004}
#standard deviation: 0.04673236031317057
#island_id: 2
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.4712014000000002}
#standard deviation: 0.044354917179947474
#island_id: 2
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin

        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin

        # New addition: Adjust the priority based on the magnetization at each site
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2607814000000004}
#standard deviation: 0.04534254970819352
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
          J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
          J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]

    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.39115140000000004}
#standard deviation: 0.0510151538078638
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1233586}
#standard deviation: 0.060012072835721984
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.45503580000000005}
#standard deviation: 0.042874552340053655
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.0688006}
#standard deviation: 0.04755855295990406
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    neighbor_site_nbr = ((i // N**2) % N + ((i // N - 1) % 2 - 1)) % N
    if h[neighbor_site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.03962179999999999}
#standard deviation: 0.04795258788386712
#island_id: 2
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,i//N%N,(i//N//N)%N,(i%N+1)%N], J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], J[2,i//N%N,(i//N//N)%N,(i%N+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][1] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    else:
      priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
    
  return(priorities)




#score: {'data3D.txt': -0.14435500000000004}
#standard deviation: 0.04652567135464032
#island_id: 3
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for d in [0,1,2])
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= total_spin
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.14834780000000003}
#standard deviation: 0.04597185873074961
#island_id: 3
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  return(priorities)




#score: {'data3D.txt': -0.08725420000000003}
#standard deviation: 0.060796803060358375
#island_id: 3
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
  return(priorities)




#score: {'data3D.txt': -0.1941218}
#standard deviation: 0.09110360083311746
#island_id: 3
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49317660000000013}
#standard deviation: 0.04276040659816041
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.004029800000000002}
#standard deviation: 0.04540896862911555
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Added this part to consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.00018500000000000005}
#standard deviation: 0.04628639168265334
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      site_neighbors = [(i+1)%N,(i+N)%N]
      for j in site_neighbors:
        if h[j][i%N][0] > 0:
          priorities[i][0] += J[2,site_nbr,i%N,0]
          break
    else:
      priorities[i][0] -= np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      site_neighbors = [(i+1)%N,(i+N)%N]
      for j in site_neighbors:
        if h[j][i%N][0] > 0:
          priorities[i][0] -= J[2,site_nbr,i%N,0]
          break
    
  return(priorities)




#score: {'data3D.txt': -0.4816502}
#standard deviation: 0.04188654199095457
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors) < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.494389}
#standard deviation: 0.042531144341529305
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[site_nbr][j][k] > 0:
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          site_neighbors = [-x for x in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': 2.5800000000000712e-05}
#standard deviation: 0.0464110445299392
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + sum(h[site_nbr][k][0] for k in range(N))
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) + sum([J[d,site_nbr,i%N,0] for d in [1,2]]) * total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) - sum([J[d,site_nbr,i%N,0] for d in [1,2]]) * total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3035622000000003}
#standard deviation: 0.04838116793918888
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.08725420000000003}
#standard deviation: 0.060796803060358375
#island_id: 3
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()

  return(priorities)




#score: {'data3D.txt': -0.131473}
#standard deviation: 0.07715211980885554
#island_id: 3
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        if J[0,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-J[0,i,j,k])
          priorities[i*N*N+j*N+k][1] -= np.exp(J[0,i,j,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(J[0,i,j,k])
          priorities[i*N*N+j*N+k][1] += np.exp(-J[0,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.194975}
#standard deviation: 0.07677348015428247
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()

        if h[i][j][k] > 0 and total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))

  return(priorities)




#score: {'data3D.txt': -0.1990334}
#standard deviation: 0.08133915197763007
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        spin_product = h[i][j][k] * total_spin
        if spin_product > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(spin_product))
        elif spin_product < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-spin_product))
        
  return(priorities)




#score: {'data3D.txt': -0.11466820000000007}
#standard deviation: 0.0813434871932597
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.45267660000000015}
#standard deviation: 0.0468923628370335
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45267660000000015}
#standard deviation: 0.0468923628370335
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1580374000000001}
#standard deviation: 0.04667733498433687
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.005098600000000001}
#standard deviation: 0.0447476095231913
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
           J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0030394000000000003}
#standard deviation: 0.047011194492801396
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * sum(1 for val in site_nbrs if val < 0) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * sum(1 for val in site_nbrs if val > 0) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbrs.sort()
    if all(val < 0 for val in site_nbrs):
      priorities[i][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
    elif any(val > 0 for val in site_nbrs):
      priorities[i][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
    
  return(priorities)




#score: {'data3D.txt': -0.30956340000000004}
#standard deviation: 0.04673236031317057
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin

        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin

        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.09359620000000003}
#standard deviation: 0.04658188087185832
#island_id: 2
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        # New addition: Adjust the priority based on the interaction between neighboring sites
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.29483260000000006}
#standard deviation: 0.04277614308513567
#island_id: 2
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0044214}
#standard deviation: 0.045143470646816695
#island_id: 1
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins = site_nbrs_x + site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.12493620000000012}
#standard deviation: 0.04565511898527919
#island_id: 1
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[2,i,j,(k+1)%N], J[0,i,j,(k-1)%N]]
        
        total_spin_x = sum(J[d,i,(j+1)%N,k] for d in [0, 1])
        total_spin_y = sum(J[d,i,j,(k+1)%N] for d in [2, 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins_x + interacting_spins_y if val < 0]) + total_spin_x + total_spin_y
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_x - 2*total_spin_y
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins_x + interacting_spins_y if val > 0]) + total_spin_x + total_spin_y
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_x + 2*total_spin_y
        
  return(priorities)




#score: {'data3D.txt': -0.0047745999999999995}
#standard deviation: 0.045422568342620165
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbrs_z = [J[1,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_z = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [1])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    site_nbrs_z = [J[3,(i//N)%N,i%N, (i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    interacting_spins_z = [val for val in site_nbrs_z if val < 0]

    priorities[i][0] += np.exp(-abs(sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3]))) * len(interacting_spins_z) + sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3])
    priorities[i][1] -= 2 - 2*sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': 0.0010354000000000001}
#standard deviation: 0.045692569930350826
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
    site_nbr = (i//N)%N
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.1476542}
#standard deviation: 0.09295196298282248
#island_id: 3
#version_generated: 3
#generate time08:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
  return(priorities)




#score: {'data3D.txt': -0.32505900000000015}
#standard deviation: 0.04707586301917363
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5036462}
#standard deviation: 0.04119095125825573
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_magnetism = sum(h[s][t][k] for s in range(N) for t in range(N))
        priority_total = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][0] += priority_total
        
  return(priorities)




#score: {'data3D.txt': -0.04739100000000011}
#standard deviation: 0.05016405524875357
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.12872900000000015}
#standard deviation: 0.04976944804797418
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        for d in [0,1]:
          if magnetism > 0:
            priorities[i*N*N+j*N+k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][d] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
        
        for d in [0,1]:
          for k_ in range(3):
            site = (i + ((k_-1)%2 - 1)) % N
            interacting_sites = [J[0,i,j,k_], J[1,(i+1)%N,j,k_], J[2,i,(j+1)%N,k_]]
            
            if magnetism > 0:
              priorities[i*N*N+j*N+k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_sites + interacting_spins if val < 0]) - total_spin
            else:
              priorities[i*N*N+j*N+k][d] -= np.exp(abs(total_spin)) * len([val for val in interacting_sites + interacting_spins if val > 0]) - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.11432100000000037}
#standard deviation: 0.04758921179216987
#island_id: 3
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        # Add the bias term
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 2 - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.003139}
#standard deviation: 0.04700711519546802
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.002924200000000001}
#standard deviation: 0.047102411555673025
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * sum(1 for val in interacting_spins_x if val < 0) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * sum(1 for val in interacting_spins_y if val < 0) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * sum(1 for val in interacting_spins_x if val > 0) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * sum(1 for val in interacting_spins_y if val > 0) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.004521000000000001}
#standard deviation: 0.04541866619573939
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += sum(1 for val in interacting_spins_x + interacting_spins_y if val < 0) + total_spin_x + total_spin_y
      priorities[i][1] -= 2 - 2*(total_spin_x + total_spin_y)
    else:
      priorities[i][0] -= sum(1 for val in interacting_spins_x + interacting_spins_y if val > 0) + total_spin_x + total_spin_y
      priorities[i][1] = -2 + 2*(total_spin_x + total_spin_y)
  
  return(priorities)




#score: {'data3D.txt': -0.215261}
#standard deviation: 0.047827678168608605
#island_id: 0
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_avg = (h[site_nbr][j][k] + h[(i+1)%N,j,k] + h[i,(j+1)%N,k] +
              h[(i-1)%N,j,k] + h[i,(j-1)%N,k] + h[i,j,(k-1)%N]) / 6
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_avg))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_avg
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_avg))
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_avg
        
  return(priorities)




#score: {'data3D.txt': -0.1343518}
#standard deviation: 0.05162814306906651
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.241393}
#standard deviation: 0.05864106676212499
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        avg_neighbor_spin = sum(J[d,site_nbr,j,k] for d in range(6)) / 6
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(avg_neighbor_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*avg_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1233586}
#standard deviation: 0.060012072835721984
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.004691400000000001}
#standard deviation: 0.04484690586919013
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins_x + interacting_spins_y if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
    
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins_x + interacting_spins_y if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.005151000000000001}
#standard deviation: 0.04530891434364766
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': 0.002951799999999999}
#standard deviation: 0.04773568850200026
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      total_spin = np.sum([J[d,site_nbr,i%N,0] for d in range(3)])
      interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= h[site_nbr][i%N][0]
    else:
      total_spin = -np.sum([J[d,site_nbr,i%N,0] for d in range(3)])
      interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] += h[site_nbr][i%N][0]

  return(priorities)




#score: {'data3D.txt': -0.0004938000000000004}
#standard deviation: 0.046197412498537184
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val > 0]) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
  
  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
  
  return(priorities)




#score: {'data3D.txt': -0.3438390000000002}
#standard deviation: 0.04750840724545498
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        # add magnetism coefficient to each term
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.22691460000000035}
#standard deviation: 0.04758617726651299
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3658178000000003}
#standard deviation: 0.04881379521364836
#island_id: 2
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0027298}
#standard deviation: 0.04686065121143751
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]
    
    interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': 0.0019970000000000005}
#standard deviation: 0.047906044201123515
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]

    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val > 0]) + total_spin
      priorities[i][1] += 2 - 2*total_spin

    site_neighbors = [J[0,site_nbr,i%N,0], J[1,(i+1)%N,site_nbr,0], J[2,site_nbr,(i+2)%N,0]]
    priorities[i][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > sum(val for val in [J[d,site_nbr,i%N,0] for d in [0,1,2]] if val < 0))
    priorities[i][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0005434000000000001}
#standard deviation: 0.04614171080963514
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,site_nbr,i%N,0] for d in [0,1,2]]
    total_spin = sum(interacting_spins) + h[site_nbr][i%N][0]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0005434000000000001}
#standard deviation: 0.04614171080963514
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,site_nbr,i%N,0] for d in [0,1,2]]
    total_spin = sum(interacting_spins) + h[site_nbr][i%N][0]

    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2943918000000002}
#standard deviation: 0.049333661254360575
#island_id: 3
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.33196979999999965}
#standard deviation: 0.04521094743488571
#island_id: 3
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbor_spin = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbor_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          
          site_neighbor_spin = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5207554}
#standard deviation: 0.0403781689882045
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,(j+1)%N,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in site_nbr_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.19654980000000014}
#standard deviation: 0.04875886544988509
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            
            if h[site_nbr][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3718922000000001}
#standard deviation: 0.04985959024260027
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        priorities[i*N*N+j*N+k][0] += h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0485186}
#standard deviation: 0.0503486164064118
#island_id: 2
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Additional term to favor spins that align with the magnetism
    priorities[i][0] += np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] > 0)
    priorities[i][1] -= np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.030189}
#standard deviation: 0.04785200767992917
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if sum(val for val in interacting_spins) < 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0369818}
#standard deviation: 0.047034913295976206
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin * sum(val for val in interacting_spins)
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin * sum(val for val in interacting_spins)
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.03962179999999999}
#standard deviation: 0.04795258788386712
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,i//N%N,(i//N//N)%N,(i%N+1)%N], J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], J[2,i//N%N,(i//N//N)%N,(i%N+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][1] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    else:
      priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0354162}
#standard deviation: 0.04709596264606977
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,(i//N//N)%N,(i%N)%N], 
               J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], 
               J[2,i//N%N,(i//N//N)%N,(i+2)%N]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,(i//N-1)%N%N,(i//N//N)%N,(i+1)%N], 
              J[1,i//N%N,(i//N//N)%N,(i+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    magnetism_coeff = np.exp(h[site_nbr][i//N%N][(i%N)%N])
    priorities[i][1] += magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i//N%N][(i%N)%N]
    
    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = -1
    
    for d in range(3):
      site_neighbors = [J[d,site_nbr,(i//N//N)%N,(i%N)%N], J[d,(site_nbr+1)%N,i//N//N,(i%N)%N], J[d,site_nbr,(i//N//N)%N,(i%N+1)%N]]
      magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in site_neighbors if val < 0]) > len([val for val in [J[d,site_nbr,i//N//N,(i%N)%N] for d in range(3)] if val < 0])))
      priorities[i][0] += magnetism_coeff + total_spin
      priorities[i][1] -= magnetism_coeff - total_spin
    
    priorities[i][0] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0045238000000000006}
#standard deviation: 0.04698863174811542
#island_id: 1
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] -= np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] = -2 + 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.0020429999999999992}
#standard deviation: 0.045967561073000165
#island_id: 1
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.09304580000000014}
#standard deviation: 0.05189621048169125
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] -= np.exp(np.abs(J[d,i,j,k]))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] += np.exp(-np.abs(J[d,i,j,k]))
  
  return priorities




#score: {'data3D.txt': -0.04739100000000011}
#standard deviation: 0.05016405524875357
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.1123462}
#standard deviation: 0.052688832455844
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.29367899999999997}
#standard deviation: 0.04549847952404563
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.24160420000000035}
#standard deviation: 0.04511871742813618
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*magnetism) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*magnetism - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*abs(magnetism)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2*abs(magnetism) - 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.29367899999999997}
#standard deviation: 0.04549847952404563
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.32221939999999977}
#standard deviation: 0.04463019587274965
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 2*J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] = -2*J[d,i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.002924200000000001}
#standard deviation: 0.047102411555673025
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.0050777999999999995}
#standard deviation: 0.046963743325676245
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(h[(i//N)%N,i%N,(i//N//N)%N])
      priorities[i][1] -= h[(i//N)%N,i%N,(i//N//N)%N]
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= h[(i//N)%N,i%N,(i//N//N)%N]
      priorities[i][1] = 2 - 2*h[(i//N)%N,i%N,(i//N//N)%N]
  
  return priorities




#score: {'data3D.txt': -0.22938100000000036}
#standard deviation: 0.04736858873768565
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin_x = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs_y = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin_y = sum(J[d,i,(j+1)%N,k] for d in [0,2])
        
        site_nbrs_z = [J[0,i,(j+1)%N,(k+1)%N], J[1,(i+1)%N,j,(k+1)%N], J[2,i,(j+1)%N,(k+1)%N]]
        total_spin_z = sum(J[d,i,(j+1)%N,(k+1)%N] for d in [0,2])
        
        interacting_spins_y = site_nbrs_y
        interacting_spins_z = site_nbrs_z
        
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_x
          
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_y
          
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) + total_spin_z
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_z
          
        else:
          priorities[i*N**2+j*N+k][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_x
          
          priorities[i*N**2+j*N+k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_y
          
          priorities[i*N**2+j*N+k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) + total_spin_z
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_z
  
  return priorities




#score: {'data3D.txt': -0.13267500000000007}
#standard deviation: 0.045328509516638645
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [J[0,(i+((k-1)%2 - 1))%N,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbrs_y = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1]]
        
        total_spin_x = sum(val for val in site_nbrs_x if val < 0) - len([val for val in site_nbrs_x if val > 0])
        total_spin_y = sum(J[d,(i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1]) - sum(J[d,i,j,k] for d in [0, 1, 2])
        
        interacting_spins_x = site_nbrs_x
        interacting_spins_y = site_nbrs_y
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_x
        
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_y
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_x
        
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3030058}
#standard deviation: 0.04656857831585585
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.484327}
#standard deviation: 0.04463422981300339
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # symmetry: flip sign and site nbrs for flipped spin
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5290678000000001}
#standard deviation: 0.040797563691475504
#island_id: 2
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0]))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4586318000000001}
#standard deviation: 0.042015511287618525
#island_id: 2
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val < 0]) > np.sum([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val > 0]) > np.sum([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in range(6)] + [J[d,i,j,(k+1)%N] for d in range(6)]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if np.sum([val for val in site_neighbors]) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (np.sum([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (np.sum([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4936030000000001}
#standard deviation: 0.04195864381745435
#island_id: 2
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46080100000000007}
#standard deviation: 0.041150725376352726
#island_id: 2
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.13033659999999997}
#standard deviation: 0.04796040638318237
#island_id: 2
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        # New approach: use a more sophisticated magnetization coefficient
        magnetization_coeff = np.exp(-abs(total_spin))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetization_coeff * (sum(val for val in interacting_spins if val < 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetization_coeff * (sum(val for val in interacting_spins if val > 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.29483260000000006}
#standard deviation: 0.04277614308513567
#island_id: 2
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.003480200000000001}
#standard deviation: 0.045505616444126984
#island_id: 1
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  # Consider all neighbors and add a new rule to prioritize spins that have the same value as their neighbors
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if site_nbrs.count(0) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0050658}
#standard deviation: 0.04635333720844703
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

    # Added this part to consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d,site,i%N,(i//N//N)%N] for d in range(3)] if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d,site,i%N,(i//N//N)%N] for d in range(3)] if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0024394000000000004}
#standard deviation: 0.04473272636046231
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Prioritize spins that have the same value as their neighbors
    for d in [0,1,2]:
      site_nbr = (i//N + ((d-1)%2 - 1)) % N
      if J[d,site_nbr,i%N,(i//N//N)%N] < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0028174000000000007}
#standard deviation: 0.0442928072856079
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0, 2])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [1, 0])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x

      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5225534000000001}
#standard deviation: 0.04006656796432657
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31238020000000005}
#standard deviation: 0.05059511170024235
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) + np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*np.exp(h[site_nbr][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) - np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*np.exp(h[site_nbr][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.153085}
#standard deviation: 0.05030878427272915
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38314420000000005}
#standard deviation: 0.04371125857670997
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[site_nbr][j][k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4497454000000001}
#standard deviation: 0.04697509743300167
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[d,(i+1)%N,j,k] for d in [0,1,2]) + sum(J[d,i,j,(k+1)%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4164538}
#standard deviation: 0.047073735623593765
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.4524514000000002}
#standard deviation: 0.04712465721933688
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5106421999999999}
#standard deviation: 0.04042277005797599
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5225534000000001}
#standard deviation: 0.04006656796432657
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -2.819999999999945e-05}
#standard deviation: 0.047768745898966194
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
    # Calculate the priority based on the magnetism at each site
    priorities[i][0] += np.exp(-abs(h[(i//N)%N,i%N,(i//N//N)%N])) * len([val for val in [h[(i//N)%N,i%N,0], h[(i//N-1)%N,i%N, (i//N//N-1)%N]] if val > 0]) + sum(h[(i//N)%N,i%N,k] for k in range(N))
    priorities[i][1] -= 2 - 2*sum(h[(i//N)%N,i%N,k] for k in range(N))
    
  return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0017301999999999994}
#standard deviation: 0.0469609570596682
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
    neighbor_sites = [(i//N)%N, ((i//N+1)%N), (i//N)//N]
    if all(x == y for x, y in zip(neighbor_sites, [0,1,2])):
      if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.0010354000000000001}
#standard deviation: 0.045692569930350826
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
    site_nbr = (i//N)%N
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
    # added new term to take into account of magnetism
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.0050777999999999995}
#standard deviation: 0.046963743325676245
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_total_spin = np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priority_non_interacting_spin_x = -2 + 2*total_spin_x

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += priority_total_spin + priority_non_interacting_spin_x
      priorities[i][1] -= 4 - 2*(priority_total_spin + priority_non_interacting_spin_x)
    else:
      priorities[i][0] -= priority_total_spin + priority_non_interacting_spin_x
      priorities[i][1] = 4 - 2*(priority_total_spin + priority_non_interacting_spin_x)

  return(priorities)




#score: {'data3D.txt': -0.0035594000000000008}
#standard deviation: 0.045283246257749675
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_total_spin_x = total_spin_x
    priority_total_spin_y = total_spin_y

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(priority_total_spin_x)) * len(interacting_spins_x) + priority_total_spin_x
      priorities[i][1] -= 2 - 2*priority_total_spin_x

      if interacting_spins_y: 
        priorities[i][0] += np.exp(-abs(priority_total_spin_y)) * len(interacting_spins_y) + priority_total_spin_y
        priorities[i][1] -= 2 - 2*priorities[i][0]
    else:
      priorities[i][0] -= np.exp(-abs(priority_total_spin_x)) * len(interacting_spins_x) + priority_total_spin_x
      priorities[i][1] = -2 + 2*priority_total_spin_x

      if interacting_spins_y: 
        priorities[i][0] -= np.exp(-abs(priority_total_spin_y)) * len(interacting_spins_y) + priority_total_spin_y
        priorities[i][1] = -2 + 2*priorities[i][0]

  return(priorities)




#score: {'data3D.txt': -0.001959}
#standard deviation: 0.04720936558565472
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin_x = np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priority_spin_y = np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += priority_spin_x + priority_spin_y
      priorities[i][1] -= 2 - 2*(priority_spin_x + priority_spin_y)
    else:
      priorities[i][0] -= priority_spin_x + priority_spin_y
      priorities[i][1] = -2 + 2*(priority_spin_x + priority_spin_y)

  return(priorities)




#score: {'data3D.txt': -0.006829}
#standard deviation: 0.046681784873759916
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbr_z = [J[3,(i//N)%N,(i//N)%N,(i//N//N)%N], 
           J[4,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    total_spin_z = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3, 4])
    
    site_neighbors = [site_nbrs_x[0], site_nbrs_y[0], site_nbr_z[0]]
    site_neighbors.sort()
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_neighbors if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbr_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_neighbors if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbr_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.005098600000000001}
#standard deviation: 0.0447476095231913
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr = ((i//N+N-1)%N) + ((i%N+N-1)%N*N + (i//N//N))
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.5106421999999999}
#standard deviation: 0.04042277005797599
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5276417999999999}
#standard deviation: 0.041633278669352965
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        site_nbr_spin = sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4864510000000001}
#standard deviation: 0.0442544397659715
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3979598000000001}
#standard deviation: 0.04434999643697844
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # added this part to prioritize -1 spin based on neighbor's spins
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if np.all([val > 0 for val in site_neighbors]):
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] += 2
        elif np.all([val < 0 for val in site_neighbors]):
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.0028482}
#standard deviation: 0.04690176837561671
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.19323220000000021}
#standard deviation: 0.04908278438678882
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.19323220000000021}
#standard deviation: 0.04908278438678882
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3754294000000002}
#standard deviation: 0.04550989316225648
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0020429999999999992}
#standard deviation: 0.045967561073000165
#island_id: 1
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.0012606000000000004}
#standard deviation: 0.04725574639808369
#island_id: 1
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0, 2])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [1, 0])
    
    interacting_spins_x = [(d, val) for d, val in zip([0, 2], site_nbrs_x) if val < 0]
    interacting_spins_y = [(d, val) for d, val in zip([1, 0], site_nbrs_y) if val < 0]
    
    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1
    
    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x
    
    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1
  
  return(priorities)




#score: {'data3D.txt': -0.0033361999999999997}
#standard deviation: 0.045450449167857516
#island_id: 1
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    total_spin = total_spin_x + total_spin_y

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len(interacting_spins_x) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(abs(total_spin)) * len(interacting_spins_y) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2517950000000001}
#standard deviation: 0.1633919048637356
#island_id: 0
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.484327}
#standard deviation: 0.04463422981300339
#island_id: 0
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # symmetry: flip sign and site nbrs for flipped spin
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4551826}
#standard deviation: 0.04176939905289517
#island_id: 0
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2640246}
#standard deviation: 0.04840141645489313
#island_id: 0
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005033}
#standard deviation: 0.04537006668498515
#island_id: 1
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins = site_nbrs_x + site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] -= len([val for val in interacting_spins if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    priorities[i][0] += h[(i//N)%N,i%N,(i//N//N)%N]
    priorities[i][1] -= h[(i//N)%N,i%N,(i//N//N)%N]
    
  return(priorities)




#score: {'data3D.txt': -0.0027405999999999997}
#standard deviation: 0.04691160146104586
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
      # Consider all neighbors
      for k in range(3):
        site = (i//N + ((k-1)%2 - 1)) % N
        if h[site,(i%N),(i//N//N)%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
      
      # Prioritize spins that have the same value as their neighbors
      for d in [0,1,2]:
        site_nbr = (i//N + ((d-1)%2 - 1)) % N
        if J[d,site_nbr,i%N,(i//N//N)%N] < 0:
          priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
          priorities[i][1] -= 2 - 2*total_spin
        else:
          priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
          priorities[i][1] = -2 + 2*total_spin
      
      # Add a term that favors the spin being aligned with its neighbors in space
      for d in [0,1,2]:
        site_nbr = (i//N + ((d-1)%2 - 1)) % N
        if J[d,site_nbr,i%N,(i//N//N)%N] == h[site_nbr,(i%N),(i//N//N)%N]:
          priorities[i][0] += np.exp(-abs(total_spin))
          priorities[i][1] -= 2 - 2*total_spin
        else:
          priorities[i][0] -= np.exp(-abs(total_spin))
          priorities[i][1] = -2 + 2*total_spin
      
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
      # Consider all neighbors
      for k in range(3):
        site = (i//N + ((k-1)%2 - 1)) % N
        if h[site,(i%N),(i//N//N)%N] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1
      
      # Prioritize spins that have the same value as their neighbors
      for d in [0,1,2]:
        site_nbr = (i//N + ((d-1)%2 - 1)) % N
        if J[d,site_nbr,i%N,(i//N//N)%N] < 0:
          priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
          priorities[i][1] = -2 + 2*total_spin
        else:
          priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
          priorities[i][1] -= 2 - 2*total_spin
      
      # Add a term that favors the spin being aligned with its neighbors in space
      for d in [0,1,2]:
        site_nbr = (i//N + ((d-1)%2 - 1)) % N
        if J[d,site_nbr,i%N,(i//N//N)%N] == h[site_nbr,(i%N),(i//N//N)%N]:
          priorities[i][0] -= np.exp(-abs(total_spin))
          priorities[i][1] = -2 + 2*total_spin
        else:
          priorities[i][0] += np.exp(-abs(total_spin))
          priorities[i][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0010366000000000006}
#standard deviation: 0.04434799815594837
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      priorities[i][0] -= len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Prioritize spins that have the same value as their neighbors
    for d in [0,1,2]:
      site_nbr = (i//N + ((d-1)%2 - 1)) % N
      if J[d,site_nbr,i%N,(i//N//N)%N] < 0:
        priorities[i][0] += len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.004029800000000002}
#standard deviation: 0.04540896862911555
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      total_spin += h[site,(i%N),(i//N//N)%N]
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.2428914000000003}
#standard deviation: 0.04769467481847421
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37858860000000033}
#standard deviation: 0.04837724826858179
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # Consider the magnetization at each site and adjust the priority accordingly
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.26599220000000035}
#standard deviation: 0.048084263321381965
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetization_coefficient = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetization_coefficient * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetization_coefficient * len([val for val in site_neighbors if val > 0]) - total_spin
        
        # Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # Adjust the priority based on the magnetization at each site
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3749366000000003}
#standard deviation: 0.049468500082779955
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        site_nbr_magnetization = sum(h[site_nbr][i%N][k] for i in range(N))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(site_nbr_magnetization)
          priorities[i*N*N+j*N+k][1] -= site_nbr_magnetization
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_nbr_magnetization)
          priorities[i*N*N+j*N+k][1] += site_nbr_magnetization
  
  return priorities




#score: {'data3D.txt': -0.0018717999999999994}
#standard deviation: 0.0466271011833247
#island_id: 1
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
      # Adjust the priority based on the magnetism at each site
      priorities[i][0] += np.exp(-abs(h[(i//N)%N,i%N,(i//N//N)%N])) * len([val for val in [h[(i//N)%N,i%N,0], h[(i//N-1)%N,i%N, (i//N//N-1)%N]] if val > 0]) + sum(h[(i//N)%N,i%N,k] for k in range(N))
      priorities[i][1] -= 2 - 2*sum(h[(i//N)%N,i%N,k] for k in range(N))
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.005429400000000001}
#standard deviation: 0.04720273525591499
#island_id: 1
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    # Calculate the priority based on the interactions with nearest neighbors
    site_nbrs_z = [J[3,(i//N)%N,i%N, (i//N//N)%N], 
           J[4,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    priorities[i][0] += np.exp(-abs(sum(J[d,(i//N-1)%N,i%N, (i//N//N-1)%N] for d in [3])) - sum(site_nbrs_z)) * len([val for val in site_nbrs_z if val < 0])
    priorities[i][1] -= 2 + 2*sum(J[d,(i//N-1)%N,i%N, (i//N//N-1)%N] for d in [3]) - sum(site_nbrs_z)
  
  return priorities




#score: {'data3D.txt': -0.42404020000000003}
#standard deviation: 0.046351196143789
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.46579420000000005}
#standard deviation: 0.06338927990094224
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
  
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5276417999999999}
#standard deviation: 0.041633278669352965
#island_id: 3
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        site_nbr_spin = sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1422974000000001}
#standard deviation: 0.045822019087333986
#island_id: 3
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin_neighbors = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42304700000000023}
#standard deviation: 0.04773539138836091
#island_id: 3
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[0,site_nbr,j,k]] + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[0,site_nbr,j,k]] + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4301078000000002}
#standard deviation: 0.045995306055727034
#island_id: 3
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][i%N][k] for k in range(N))
      
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += np.exp(-abs(total_spin)) * len([val for val in [h[site_nbr][i%N][k] for k in range(N)] if val < 0]) + total_spin
        priorities[i*N*N+j*N+0][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+0][0] -= np.exp(-abs(total_spin)) * len([val for val in [h[site_nbr][i%N][k] for k in range(N)] if val > 0]) + total_spin
        priorities[i*N*N+j*N+0][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.153085}
#standard deviation: 0.05030878427272915
#island_id: 2
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38916179999999995}
#standard deviation: 0.040776229604513464
#island_id: 2
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][1] -= 2 * magnetism
        else:
          priorities[i*N*N+j*N+k][1] += 2 * magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.1355978}
#standard deviation: 0.04523026017126145
#island_id: 2
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.1829142}
#standard deviation: 0.048639717498768435
#island_id: 2
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # add the magnetism term
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.20077060000000022}
#standard deviation: 0.045407208851018364
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0], -priorities[i*N*N+j*N+k][1]
  return(priorities)




#score: {'data3D.txt': -0.3667038}
#standard deviation: 0.04868022170820507
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.1554598000000001}
#standard deviation: 0.18659241780940625
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.25829580000000013}
#standard deviation: 0.12712435668415406
#island_id: 0
#version_generated: 3
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.31565459999999995}
#standard deviation: 0.11721357472084877
#island_id: 0
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.12101300000000008}
#standard deviation: 0.1635680492975325
#island_id: 0
#version_generated: 3
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2517950000000001}
#standard deviation: 0.1633919048637356
#island_id: 0
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in range(3)] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in range(3)] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Additional term to favor spins that align with the magnetism
    priorities[i][0] += np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] > 0)
    priorities[i][1] -= np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.0339486}
#standard deviation: 0.050826911356485156
#island_id: 2
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])

    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

    # Additional term to favor spins that align with the magnetism
    priorities[i][0] += np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] > 0)
    priorities[i][1] -= np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] < 0)

  # Improved term to consider the interactions with neighboring spins
  for i in range(N**3):
    site_neighbors = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    if total_spin > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.25829580000000013}
#standard deviation: 0.12712435668415406
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.25829580000000013}
#standard deviation: 0.12712435668415406
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43889979999999995}
#standard deviation: 0.04340529460745544
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
        # Add the interaction with diagonal neighbors
        diag_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in diag_neighbors if val < 0]) + sum(val for val in diag_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.2985430000000001}
#standard deviation: 0.07494243331384427
#island_id: 0
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # apply the symmetry rule for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.17334620000000012}
#standard deviation: 0.12977289095015185
#island_id: 0
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.31565459999999995}
#standard deviation: 0.11721357472084877
#island_id: 0
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return priorities




#score: {'data3D.txt': -0.08960900000000001}
#standard deviation: 0.10658618540411323
#island_id: 0
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.07342539999999999}
#standard deviation: 0.04555635844577571
#island_id: 0
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        for d in [0,1,2]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
  
  return(priorities)




#score: {'data3D.txt': 0.020656999999999995}
#standard deviation: 0.24268215754562592
#island_id: 0
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin

  return priorities




#score: {'data3D.txt': -0.2701753999999999}
#standard deviation: 0.048231786146067615
#island_id: 0
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j][0] > 0:
        priorities[i*N*N+j*N+0][0] -= 1
        priorities[i*N*N+j*N+0][1] += 1
      else:
        priorities[i*N*N+j*N+0][0] += 1
        priorities[i*N*N+j*N+0][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][0][k] > 0:
      priorities[i*N*N+0*j+N*k][0] -= 1
      priorities[i*N*N+0*j+N*k][1] += 1
    else:
      priorities[i*N*N+0*j+N*k][0] += 1
      priorities[i*N*N+0*j+N*k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.42442900000000033}
#standard deviation: 0.047812994875870304
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.4115606000000003}
#standard deviation: 0.04845139758190676
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0]))
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return priorities




#score: {'data3D.txt': 0.052834999999999736}
#standard deviation: 0.0469611211003315
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add neighbor interaction term
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add neighbor interaction term
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2517950000000001}
#standard deviation: 0.1633919048637356
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0623938}
#standard deviation: 0.04612953675856718
#island_id: 2
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d, spin in zip([0, 1, 2], [J[d,i,j,k] for d in [0,1,2]]):
          if spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += magnetism
          priorities[i*N*N+j*N+k][1] -= magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism
          priorities[i*N*N+j*N+k][1] += magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.38612140000000006}
#standard deviation: 0.04415878012400253
#island_id: 2
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += magnetism
          priorities[i*N*N+j*N+k][1] -= magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism
          priorities[i*N*N+j*N+k][1] += magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.0045238000000000006}
#standard deviation: 0.04698863174811542
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
      J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
      J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] -= np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0049398}
#standard deviation: 0.04743130206899237
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1
    
    # Add the magnetic term
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    
    # Add the term for the interacting spins
    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1
      
  return(priorities)




#score: {'data3D.txt': -0.005711399999999999}
#standard deviation: 0.04769781242405149
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1

    if total_spin_x + total_spin_y <= 0:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] += 2 - 2*total_spin_x
    else:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

    if total_spin_y <= 0:
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] += 2 - 2*total_spin_y
    else:
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    total_spin = total_spin_x + total_spin_y

    priorities[i][0] += np.exp(-abs(total_spin)) * len(interacting_spins_x + interacting_spins_y) + total_spin
    priorities[i][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2999918}
#standard deviation: 0.0472889032729667
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.2999918}
#standard deviation: 0.0472889032729667
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.291087}
#standard deviation: 0.049352321840010725
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N,(j+1)%N,k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  
  # symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      if h[(i+1)%N,j,0] > 0:
        priorities[i*N*N+0*j+N*0][0] -= 1
        priorities[i*N*N+0*j+N*0][1] += 1
  
  for j in range(N):
    if h[0,(j+1)%N,k] > 0:
      priorities[0*N*N+j*N+k][0] -= 1
      priorities[0*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.18015339999999985}
#standard deviation: 0.04917877050557487
#island_id: 0
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
  
  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] += 1
      else:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
  
  for i in range(N):
    for k in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2829266000000002}
#standard deviation: 0.046293810519766034
#island_id: 2
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          if len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          if len([val for val in site_neighbors if val > 0]) > len([val for val in site_neighbors if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': -0.0028482}
#standard deviation: 0.04690176837561671
#island_id: 2
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if sum(1 for val in interacting_spins if val < 0) > sum(1 for val in interacting_spins if val > 0):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if sum(1 for val in interacting_spins if val > 0) > sum(1 for val in interacting_spins if val < 0):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.494389}
#standard deviation: 0.042531144341529305
#island_id: 2
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          site_neighbors = [-x for x in site_neighbors]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': -0.3743626}
#standard deviation: 0.04753397438927235
#island_id: 2
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15386100000000016}
#standard deviation: 0.04595418587027737
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.0355706}
#standard deviation: 0.046919219682769665
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.0355706}
#standard deviation: 0.046919219682769665
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
  return priorities




#score: {'data3D.txt': -0.4149166000000002}
#standard deviation: 0.045159542562342246
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
        
        site_neighbor_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbor_neighbors = sum(J[d,i,(j+2)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbor_neighbors if val < 0]) + total_spin_neighbor_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbor_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbor_neighbors if val > 0]) + total_spin_neighbor_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.4534770000000001}
#standard deviation: 0.041864792260323
#island_id: 3
#version_generated: 3
#generate time11:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbors if val < 0]) + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbors if val > 0]) + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5182194000000001}
#standard deviation: 0.042744124083200025
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
  return priorities




#score: {'data3D.txt': -0.5182194000000001}
#standard deviation: 0.042744124083200025
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4968310000000001}
#standard deviation: 0.04282684343959989
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        
        # Calculate the priority based on the total magnetization at each site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbor_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Adjust the priority based on the magnetization at each site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3119634}
#standard deviation: 0.04847047163418157
#island_id: 0
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44064220000000004}
#standard deviation: 0.04457278114679406
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += 1 - total_spin
          priorities[i*N*N+j*N+k][1] += 1
        
        for d in [0,1,2]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
        
  return(priorities)




#score: {'data3D.txt': -0.4345838}
#standard deviation: 0.04639269702830393
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors and flipped site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          
          flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors and flipped site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          
          flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return priorities




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort(key=lambda x: abs(x))
          
          # Add the interaction with site's neighbors
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort(key=lambda x: abs(x))
          
          # Add the interaction with site's neighbors
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.22800299999999998}
#standard deviation: 0.044376266979095934
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.3808534}
#standard deviation: 0.04744737198665486
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(sum(h[site_nbr][i%N][k] for k in range(N)))) * len([val for val in [h[site_nbr][i%N][k] for k in range(N)] if val < 0]) + sum(h[site_nbr][i%N][k] for k in range(N)) / N
      priorities[i][1] -= 2 - 2*sum(h[site_nbr][i%N][k] for k in range(N)) / N - np.sum(np.sign([h[site_nbr][i%N][k] for k in range(N)]))
    else:
      priorities[i][0] -= np.exp(-abs(sum(h[site_nbr][i%N][k] for k in range(N)))) * len([val for val in [h[site_nbr][i%N][k] for k in range(N)] if val > 0]) + sum(h[site_nbr][i%N][k] for k in range(N)) / N
      priorities[i][1] = -2 + 2*sum(h[site_nbr][i%N][k] for k in range(N)) / N + np.sum(np.sign([h[site_nbr][i%N][k] for k in range(N)]))
  
  return(priorities)




#score: {'data3D.txt': -0.2659182}
#standard deviation: 0.08378618304207443
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins)) - np.sum(np.sign(h[site_nbr][i%N])) / 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins)) + np.sum(np.sign(h[site_nbr][i%N])) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.37764140000000007}
#standard deviation: 0.04944331062985165
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
  
  return(priorities)




#score: {'data3D.txt': -0.36621339999999997}
#standard deviation: 0.04925138150793336
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.42404020000000003}
#standard deviation: 0.046351196143789
#island_id: 3
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4534770000000001}
#standard deviation: 0.041864792260323
#island_id: 3
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbors if val < 0]) + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbors if val > 0]) + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1813802000000004}
#standard deviation: 0.05022739300381814
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        neighbors_spin = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(neighbors_spin)
          priorities[i*N*N+j*N+k][1] -= neighbors_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-neighbors_spin)
          priorities[i*N*N+j*N+k][1] = -neighbors_spin
  
  return(priorities)




#score: {'data3D.txt': -0.40730140000000004}
#standard deviation: 0.04573268675728555
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins.sort()
          idx = np.searchsorted(interacting_spins, 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:idx] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(np.sign(interacting_spins))
        else:
          interacting_spins.sort()
          idx = np.searchsorted(interacting_spins, 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[idx:] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + sum(np.sign(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.4180346000000001}
#standard deviation: 0.04534251914968995
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37764140000000007}
#standard deviation: 0.04944331062985165
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
  
  return(priorities)




#score: {'data3D.txt': -0.37764140000000007}
#standard deviation: 0.04944331062985165
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))

  return(priorities)




#score: {'data3D.txt': -0.4460894}
#standard deviation: 0.04150695517187451
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        if i < N-1:
          z_plus = J[0,i+1,j,k]
          z_minus = J[1,i,(j+1)%N,k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [z_plus, z_minus] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(z_plus) + np.sign(z_minus))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,N-1,j,k], J[1,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(J[0,N-1,j,k]) + np.sign(J[1,i,(j+1)%N,k]))
        
        if j < N-1:
          x_plus = J[0,i,(j+1)%N,k]
          x_minus = J[1,i,j,k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [x_plus, x_minus] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(x_plus) + np.sign(x_minus))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[1,i,N-1,k], J[0,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(J[1,i,N-1,k]) + np.sign(J[0,i,(j+1)%N,k]))
        
        if k < N-1:
          y_plus = J[2,i,j,(k+1)%N]
          y_minus = J[2,i,j,k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [y_plus, y_minus] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(y_plus) + np.sign(y_minus))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2,i,j,N-1], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(J[2,i,j,N-1]) + np.sign(y_minus))
  
  return(priorities)




#score: {'data3D.txt': -0.4164538}
#standard deviation: 0.047073735623593765
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

  return(priorities)




#score: {'data3D.txt': -0.006406599999999999}
#standard deviation: 0.04534980569351978
#island_id: 1
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [2])
    
    site_nbrs_z = [J[1,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_z = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [1])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.006236599999999999}
#standard deviation: 0.046219567938698865
#island_id: 1
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1])

    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    total_spin_y = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [2,0])

    site_nbrs_z = [J[1,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    total_spin_z = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [1,0])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.0054946000000000005}
#standard deviation: 0.04573555696435761
#island_id: 1
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbrs_z = [J[1,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_z = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [1])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.006804999999999999}
#standard deviation: 0.04621193368600799
#island_id: 1
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1])
    total_spin_y = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [2,0])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.22966060000000005}
#standard deviation: 0.04789329606155748
#island_id: 3
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        total_spin_h = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin_h)
          priorities[i*N*N+j*N+k][1] -= total_spin_h
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin_h)
          priorities[i*N*N+j*N+k][1] = -total_spin_h
        
  return(priorities)




#score: {'data3D.txt': -0.3846562000000001}
#standard deviation: 0.04544034948765249
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        if i < N-1 and j < N-1 and k < N-1:
          site_neighbors2 = [J[0,i+1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k+1]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors2 if val < 0]) + sum(val for val in site_neighbors2) / 3
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors2))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors2 if val > 0]) + sum(val for val in site_neighbors2) / 3
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors2))
  
  return(priorities)




#score: {'data3D.txt': -0.4081894000000001}
#standard deviation: 0.04420562778244417
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        # Add the total spin as a heuristic term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * total_spin
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4180346000000001}
#standard deviation: 0.04534251914968995
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.27926019999999996}
#standard deviation: 0.04757726532662423
#island_id: 0
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1-k)%2 - 1)) % N
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] += 1
      else:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.045952200000000054}
#standard deviation: 0.05200158069866728
#island_id: 0
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.22662899999999994}
#standard deviation: 0.05560802962702419
#island_id: 0
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2979542}
#standard deviation: 0.04268720771331852
#island_id: 0
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        # Calculate priority for up spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Calculate priority for down spin
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.23649099999999998}
#standard deviation: 0.05415334670175057
#island_id: 2
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.21775019999999995}
#standard deviation: 0.05339256839636018
#island_id: 0
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites (again)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites (again, again)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1384222000000002}
#standard deviation: 0.10632669555271623
#island_id: 0
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(N-j-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.17334620000000012}
#standard deviation: 0.12977289095015185
#island_id: 0
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return priorities




#score: {'data3D.txt': -0.3081202000000001}
#standard deviation: 0.09118211004336327
#island_id: 0
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(j+N-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return priorities




#score: {'data3D.txt': -0.36621339999999997}
#standard deviation: 0.04925138150793336
#island_id: 3
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.4664338}
#standard deviation: 0.044423575020027375
#island_id: 3
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5087685999999999}
#standard deviation: 0.042384996567653516
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49986739999999996}
#standard deviation: 0.0428755144253687
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) - sum(h[i%N][j%N][l%N] for l in range(N)) / N
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center) - sum(h[i%N][j%N][k%N] for l in range(N)) / N
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4679234}
#standard deviation: 0.04253975472942927
#island_id: 0
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  for k in range(N):
    site_nbr = (k + ((i-1)%2 - 1)) % N
    if h[site_nbr][j][0] > 0:
      priorities[i*N*N+0*j+N*k][0] -= 1
      priorities[i*N*N+0*j+N*k][1] += 1
    else:
      priorities[i*N*N+0*j+N*k][0] += 1
      priorities[i*N*N+0*j+N*k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.1833670000000002}
#standard deviation: 0.0442192708103605
#island_id: 1
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = J[0,i,j,k] + J[1,(i+1)%N,j,k] + J[2,i,(j+1)%N,k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5256834000000001}
#standard deviation: 0.0414153619378124
#island_id: 1
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.08960900000000001}
#standard deviation: 0.10658618540411323
#island_id: 0
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        flipped_site_nbr = (site_nbr + ((k-1)%2 - 1)) % N
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.14513219999999996}
#standard deviation: 0.0486394720690922
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(N):
          site_nbr_l = (l + ((k-1)%2 - 1)) % N
          if h[site_nbr_l][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.08960900000000001}
#standard deviation: 0.10658618540411323
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.22756939999999998}
#standard deviation: 0.04427850204828524
#island_id: 0
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = np.array([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]])
        site_neighbors = np.array([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (interacting_spins < 0).sum() + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (site_neighbors < 0).sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*(site_neighbors).sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (interacting_spins > 0).sum() + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (site_neighbors > 0).sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*(site_neighbors).sum()
          
  for i in range(N):
    site_nbr = (i + ((N-1-k)%2 - 1)) % N
    if h[site_nbr][j][k] > 0:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] += 1
    else:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2487926}
#standard deviation: 0.04514354068125361
#island_id: 0
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.2962074000000001}
#standard deviation: 0.09913585257231615
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028982}
#standard deviation: 0.04651805409472756
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.2605486000000002}
#standard deviation: 0.04759881130910726
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[i*N*N+j*N+k][1], -priorities[i*N*N+j*N+k][0]
        
  return(priorities)




#score: {'data3D.txt': -0.45012299999999994}
#standard deviation: 0.044662679174003884
#island_id: 0
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': 0.019317400000000103}
#standard deviation: 0.26642279200030916
#island_id: 0
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.0528806}
#standard deviation: 0.11321013675303111
#island_id: 0
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(N-j-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03159740000000002}
#standard deviation: 0.08024643514350033
#island_id: 0
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(N-j-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

        if h[(i+1)%N][(N-j-1)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1384222000000002}
#standard deviation: 0.10632669555271623
#island_id: 0
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(N-j-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.075101}
#standard deviation: 0.13747213389992902
#island_id: 0
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(N-j-1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44427020000000006}
#standard deviation: 0.045057908428598865
#island_id: 2
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 2
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2328746}
#standard deviation: 0.0651066902463948
#island_id: 2
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbor_spin = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[0,i,(j+1)%N,j] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_neighbor_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23649099999999998}
#standard deviation: 0.05415334670175057
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.3567814}
#standard deviation: 0.04562704564225038
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.16899780000000003}
#standard deviation: 0.045689307667768395
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.3617206}
#standard deviation: 0.047224883013513116
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.44427020000000006}
#standard deviation: 0.045057908428598865
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.5241666}
#standard deviation: 0.04220103368923563
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + 1
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + 1
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3377218000000001}
#standard deviation: 0.04782602810980649
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [J[0,i,j,k], *site_neighbors]
        total_spin += sum(val for val in interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4599194}
#standard deviation: 0.03937088091013459
#island_id: 1
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 1
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 1
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.06579140000000003}
#standard deviation: 0.08474508484885714
#island_id: 0
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1810054}
#standard deviation: 0.0439222332178135
#island_id: 0
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2606962}
#standard deviation: 0.047190065750748855
#island_id: 0
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        flipped_site_nbr = (site_nbr + ((N-j-1)%N)*N + k) % (N**3)
        
        if h[i][j][k] > 0:
          priorities[flipped_site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr][1] = -2 + 2*total_spin
        
        else:
          priorities[flipped_site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.30684139999999993}
#standard deviation: 0.04526073978670698
#island_id: 0
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        flipped_site_nbr = (i + ((k+1)%2 - 1)) % N
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.4599194}
#standard deviation: 0.03937088091013459
#island_id: 1
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.24331540000000013}
#standard deviation: 0.04386186775366503
#island_id: 1
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4599194}
#standard deviation: 0.03937088091013459
#island_id: 1
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47006220000000015}
#standard deviation: 0.04544902651498709
#island_id: 1
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3790686}
#standard deviation: 0.04940710853753739
#island_id: 2
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31790179999999996}
#standard deviation: 0.052572241313834055
#island_id: 2
#version_generated: 3
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
          
          site_nbr_spin = J[0,site_nbr,j,k] + J[1,i,(j+1)%N,k] + J[2,i,j,(k+1)%N]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val < 0]) + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_nbr_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
          
          site_nbr_spin = J[0,site_nbr,j,k] + J[1,i,(j+1)%N,k] + J[2,i,j,(k+1)%N]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val > 0]) + site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*site_nbr_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37719100000000005}
#standard deviation: 0.049501247246912884
#island_id: 2
#version_generated: 3
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr_neighbor = ((i + (j-1)%N - N//2) % N)
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr_neighbor,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr_neighbor,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3299054}
#standard deviation: 0.05175288176362742
#island_id: 2
#version_generated: 3
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2 - total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2 - total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26345340000000006}
#standard deviation: 0.045657471551105416
#island_id: 2
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spin_neighbors = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors_site = sum(val for val in interacting_spin_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin_neighbors if val < 0]) + (total_spin_neighbors_site) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors_site
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin_neighbors if val > 0]) + (total_spin_neighbors_site) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors_site
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1554598000000001}
#standard deviation: 0.18659241780940625
#island_id: 0
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.048565}
#standard deviation: 0.08313821801674606
#island_id: 0
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
        priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites with periodic boundary conditions
  for i in range(N):
    for j in range(N):
      if k == N-1:
        site_nbr = (i + ((N-2)%2 - 1)) % N
      else:
        site_nbr = (i + ((k-1)%2 - 1)) % N
      priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0193418}
#standard deviation: 0.04705007218655461
#island_id: 0
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4247642}
#standard deviation: 0.0496425635756253
#island_id: 0
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites with periodic boundary conditions
  for i in range(N):
    for j in range(N):
      if k == N-1:
        site_nbr = (i + ((N-2)%2 - 1)) % N
      else:
        site_nbr = (i + ((k-1)%2 - 1)) % N
      priorities[site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.022939400000000006}
#standard deviation: 0.05965251685922397
#island_id: 0
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # symmetry: flip sign and site nbrs for flipped spin on all sites with periodic boundary conditions
        for d in [0,1]:
          i_nbr = (i+d) % N
          j_nbr = (j+((d-1)%2-1)) % N
          k_nbr = (k+((d-1)%2-1)) % N
          priorities[i_nbr*N*N+j_nbr*N+k_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i_nbr*N*N+j_nbr*N+k_nbr][1] = -2 + 2*total_spin

        # symmetry: flip sign and site nbrs for flipped spin on all sites with periodic boundary conditions (second iteration)
        for d in [0,1]:
          i_nbr = (i+d) % N
          j_nbr = (j+((d-1)%2-1)) % N
          k_nbr = (k+((d-1)%2-1)) % N
          priorities[i_nbr*N*N+j_nbr*N+k_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i_nbr*N*N+j_nbr*N+k_nbr][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.11710459999999999}
#standard deviation: 0.08895719498073217
#island_id: 0
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites with periodic boundary conditions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3617206}
#standard deviation: 0.047224883013513116
#island_id: 2
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.18299219999999997}
#standard deviation: 0.053850202405933446
#island_id: 2
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.4599194}
#standard deviation: 0.03937088091013459
#island_id: 1
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1292606}
#standard deviation: 0.04818296926964962
#island_id: 2
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.12159340000000012}
#standard deviation: 0.04514610322541692
#island_id: 2
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.119809}
#standard deviation: 0.05720431416423065
#island_id: 2
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

  return(priorities)




#score: {'data3D.txt': -0.08477340000000001}
#standard deviation: 0.04901486358687537
#island_id: 2
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.0551038}
#standard deviation: 0.053119543536818914
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        
        site_neighbors = [(i + ((j-1)%2 - 1)) % N, (i + ((j+1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,site_nbr,k], J[0,i,(j+1)%N,k]] if val < 0]) + sum(val for val in [J[0,i,site_nbr,k], J[0,i,(j+1)%N,k]]) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,site_nbr,k] for j in range(N)) - 2*sum(J[0,i,(j+1)%N,k] for j in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,site_nbr,k], J[0,i,(j+1)%N,k]] if val > 0]) + sum(val for val in [J[0,i,site_nbr,k], J[0,i,(j+1)%N,k]]) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,site_nbr,k] for j in range(N)) + 2*sum(J[0,i,(j+1)%N,k] for j in range(N))

  return(priorities)




#score: {'data3D.txt': -0.1417382}
#standard deviation: 0.06785204418998737
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        
        site_neighbors_2 = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) - 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) - 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) + 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) + 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
  
  return(priorities)




#score: {'data3D.txt': -0.1016494}
#standard deviation: 0.055013638305787406
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

        site_up = (i, j)
        site_down = ((i+1)%N, j)
        site_left = (i, (j-1)%N)
        site_right = ((i+1)%N, (j+1)%N)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

  return(priorities)




#score: {'data3D.txt': -0.10708460000000009}
#standard deviation: 0.0453298286213394
#island_id: 0
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12498620000000012}
#standard deviation: 0.04407965164971248
#island_id: 0
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3072062}
#standard deviation: 0.04562691575769723
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1] = -priorities[i*N*N+j*N+k][0], -priorities[i*N*N+j*N+k][1]
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      priorities[i*N*N+(N-j-1)%N*k][0], priorities[i*N*N+(N-j-1)%N*k][1] = priorities[N-i-1*N+(N-j-1)%N*k][0], priorities[N-i-1*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.2652050000000002}
#standard deviation: 0.047301420856037724
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = -priorities[(i+1)%N*N+(N-j-1)%N*k][0], -priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.0028982}
#standard deviation: 0.04651805409472756
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.0025198}
#standard deviation: 0.04682272448245617
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  # additional symmetry: flip sign and site nbrs for flipped spin on all sites (2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(N-i-1)%N*N+(N-j-1)%N*k][0], priorities[(N-i-1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.23493139999999998}
#standard deviation: 0.04593372066401764
#island_id: 0
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [(i+((k-1)%2-1))%N,J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.2487926}
#standard deviation: 0.04514354068125361
#island_id: 0
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.22800299999999998}
#standard deviation: 0.044376266979095934
#island_id: 0
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.2487926}
#standard deviation: 0.04514354068125361
#island_id: 0
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 1
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22258419999999987}
#standard deviation: 0.04479683326263142
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.sign(interacting_spins)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.sign(interacting_spins)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4108898000000001}
#standard deviation: 0.04949404545963079
#island_id: 2
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,i,(j-1)%N,k], J[4,(i-1)%N,j,k], J[5,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0031870000000000006}
#standard deviation: 0.048114022394723975
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.0006717999999999997}
#standard deviation: 0.04566862560620803
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[d,i,(j+1)%N,k] if d < 3 else J[d-3,i,j,(k+1)%N] for d in range(6)]
        total_spin_neighbors = sum(val for val in site_neighbors)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.3651078000000002}
#standard deviation: 0.04938894227618162
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,i,(j-1)%N,k], J[4,(i-1)%N,j,k], J[5,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Additional term based on the site magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k]
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.4108898000000001}
#standard deviation: 0.04949404545963079
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,i,(j-1)%N,k], J[4,(i-1)%N,j,k], J[5,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3616890000000001}
#standard deviation: 0.048751220282163193
#island_id: 3
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin - np.mean(np.sign(site_neighbors))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + np.mean(np.sign(site_neighbors))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
  
  return(priorities)




#score: {'data3D.txt': -0.2250358}
#standard deviation: 0.04614003595967389
#island_id: 3
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))

        # Additional improvement: Use the sign of the interacting spins to adjust the priority
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))

  return(priorities)




#score: {'data3D.txt': -0.37625980000000003}
#standard deviation: 0.04867668008358829
#island_id: 3
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin - (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.29825700000000005}
#standard deviation: 0.18798247958519965
#island_id: 1
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add interactions with neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 1
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_spin_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3722006}
#standard deviation: 0.0438973534468765
#island_id: 0
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site and sum up the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        # Calculate the number of negative interactions at each site
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        negative_interactions = len([val for val in interacting_spins if val < 0])
        
        # Calculate the number of positive interactions at each site
        positive_interactions = len([val for val in interacting_spins if val > 0])
        
        # Assign priorities based on the total spin and the number of negative/positive interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (negative_interactions - positive_interactions) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (positive_interactions - negative_interactions) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2999918}
#standard deviation: 0.0472889032729667
#island_id: 0
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.35300220000000015}
#standard deviation: 0.045666602623361426
#island_id: 0
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.29929779999999995}
#standard deviation: 0.04717924114650426
#island_id: 0
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[flipped_site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # improved symmetry: consider flipped spin on all sites and their neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][0][k] > 0:
        priorities[i*N*N+0*j+N*k][0] -= 1
        priorities[i*N*N+0*j+N*k][1] += 1
      else:
        priorities[i*N*N+0*j+N*k][0] += 1
        priorities[i*N*N+0*j+N*k][1] -= 1

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    if h[site_nbr][k][0] > 0:
      priorities[i*N*N+j*N+0][0] -= 1
      priorities[i*N*N+j*N+0][1] += 1
    else:
      priorities[i*N*N+j*N+0][0] += 1
      priorities[i*N*N+j*N+0][1] -= 1

  for k in range(N):
    site_nbr = (k + ((i-1)%2 - 1)) % N
    if h[site_nbr][i][j] > 0:
      priorities[i*N*N+j*N+k][0] -= 1
      priorities[i*N*N+j*N+k][1] += 1
    else:
      priorities[i*N*N+j*N+k][0] += 1
      priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.16913660000000005}
#standard deviation: 0.07449689027362143
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.30729900000000016}
#standard deviation: 0.09032102434649428
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[(i+1)%N][(j+1)%N][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2476366000000001}
#standard deviation: 0.06602632853975751
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.24511899999999998}
#standard deviation: 0.05713794780178932
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] += 2 - 2*total_spin

  # symmetry: flip sign and site nbrs for flipped spin on all sites (continued)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          priorities[(i+1)%N*N+(N-j-1)%N*k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[(i+1)%N*N+(N-j-1)%N*k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5202102}
#standard deviation: 0.03964064499929334
#island_id: 3
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin + total_site_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42404020000000003}
#standard deviation: 0.046351196143789
#island_id: 1
#version_generated: 3
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48673500000000003}
#standard deviation: 0.04039546775320222
#island_id: 1
#version_generated: 3
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          elif spin > 0:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * 2
          
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 1
#version_generated: 3
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.10434580000000006}
#standard deviation: 0.1364187443951894
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # Additional optimization: Use the fact that the priority for a site is symmetric in its neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0013134000000000006}
#standard deviation: 0.04650831560527644
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend([val for val in site_neighbors if val < 0])
        
        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 4
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] = -4
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3103066}
#standard deviation: 0.04967954142743269
#island_id: 3
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin - (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        if i < N//2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.18217020000000017}
#standard deviation: 0.11418523876561286
#island_id: 3
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Improved part: consider the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin - (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.37625980000000003}
#standard deviation: 0.04867668008358829
#island_id: 3
#version_generated: 3
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + (np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin - (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + (np.sum(np.sign(site_neighbors)))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.179695}
#standard deviation: 0.04537102572126842
#island_id: 0
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
          
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3273886}
#standard deviation: 0.04689703007696756
#island_id: 0
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          flipped_site_nbr = (site_nbr + ((N-j-1)%N)*N + k) % (N**3)

          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[flipped_site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[flipped_site_nbr][1] -= 2 - 2*total_spin

        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          flipped_site_nbr = (site_nbr + ((N-j-1)%N)*N + k) % (N**3)

          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[flipped_site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[flipped_site_nbr][1] = 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.12498620000000012}
#standard deviation: 0.04407965164971248
#island_id: 0
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2292314}
#standard deviation: 0.0492027114500817
#island_id: 0
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
            
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3030058}
#standard deviation: 0.04656857831585585
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3030058}
#standard deviation: 0.04656857831585585
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44064220000000004}
#standard deviation: 0.04457278114679406
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += 1 - total_spin
          priorities[i*N*N+j*N+k][1] += 1
        
        for d in [0,1,2]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09627340000000002}
#standard deviation: 0.04494745123408001
#island_id: 0
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = -np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = -np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.0007346000000000004}
#standard deviation: 0.04725013442139609
#island_id: 0
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # additional symmetry: flip sign and site nbrs for flipped spin on all sites (2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(N-i-1)%N*N+(N-j-1)%N*k][0], priorities[(N-i-1)%N*N+(N-j-1)%N*k][1]
        
  return(priorities)




#score: {'data3D.txt': -0.0025198}
#standard deviation: 0.04682272448245617
#island_id: 0
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
        
  # additional symmetry: flip sign and site nbrs for flipped spin on all sites (2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(N-i-1)%N*N+(N-j-1)%N*k][0], priorities[(N-i-1)%N*N+(N-j-1)%N*k][1]
        
  return(priorities)




#score: {'data3D.txt': -0.0005314000000000006}
#standard deviation: 0.04649912831484048
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 * total_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': 0.0315778}
#standard deviation: 0.040779386301905036
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.where(J[:, i, j, k] < 0, J[:, i, j, k], 0))
          priorities[i*N*N+j*N+k][1] -= total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.where(J[:, i, j, k] > 0, J[:, i, j, k], 0))
          priorities[i*N*N+j*N+k][1] = total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.3567814}
#standard deviation: 0.04562704564225038
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2004694000000003}
#standard deviation: 0.044722580690742794
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 + (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = 2 - (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.2554666}
#standard deviation: 0.0501442471719339
#island_id: 0
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add the interaction with site's neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        
        # Add the interaction with flipped site's neighbors
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add the interaction with site's flipped neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2518706000000001}
#standard deviation: 0.14659071899557632
#island_id: 0
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add the interaction with site's neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.45012299999999994}
#standard deviation: 0.044662679174003884
#island_id: 0
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = np.array([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]])
        site_neighbors = np.array([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins < 0) + np.sum(site_neighbors < 0)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.sum(interacting_spins > 0) + np.sum(site_neighbors > 0)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2553258}
#standard deviation: 0.04056331710252503
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2]))) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.0709746}
#standard deviation: 0.04852564059175314
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in range(3)) + sum(J[d,(i+1)%N,j,k] for d in range(3)) + sum(J[d,i,j,(k+1)%N] for d in range(3))
        if total_spin_neighbors > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin_neighbors))
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.270873}
#standard deviation: 0.04007483089172056
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])) - abs(sum(J[0,i,j,(k+1)%N] for j in range(N)))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])) - abs(sum(J[0,i,j,(k+1)%N] for j in range(N)))) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3151382}
#standard deviation: 0.04053863516153449
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(val for val in site_neighbors) / 3
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in site_neighbors) / 3
        
  return(priorities)




#score: {'data3D.txt': -0.0808482}
#standard deviation: 0.06452004740202848
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[0,i,j,k] for d in [0])
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[0,(i+1)%N,j,k] for i in range(N)) + sum(J[0,i,j,(k+1)%N] for k in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= -1 + 2*total_spin + 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = 3 - 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.23649099999999998}
#standard deviation: 0.05415334670175057
#island_id: 2
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.4521902}
#standard deviation: 0.07882462422339861
#island_id: 3
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
  
  site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
  
  return(priorities)




#score: {'data3D.txt': -0.39129300000000017}
#standard deviation: 0.046180923669844456
#island_id: 3
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[d,(i+1)%N,j,k] for d in [0,1,2]) + sum(J[d,i,j,(k+1)%N] for d in [0,1,2])
        total_spin_center = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + total_spin_center
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_center
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + total_spin_center
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_center
        
  return(priorities)




#score: {'data3D.txt': -0.37825580000000003}
#standard deviation: 0.04548091430875154
#island_id: 3
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_neighbor = sum(J[d,i,(j+1)%N,k] if d == 0 else J[d,(i+1)%N,j,k] if d == 1 else J[d,i,j,(k+1)%N] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbor)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbor
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbor
        
  return(priorities)




#score: {'data3D.txt': -0.003359}
#standard deviation: 0.047783052633752904
#island_id: 0
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [(i+((k-1)%2 - 1))%N,J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.003359}
#standard deviation: 0.047783052633752904
#island_id: 0
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [(i+((k-1)%2-1))%N,J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors.sort()
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
  # symmetry: flip sign and site nbrs for flipped spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] = -2 + 2*total_spin
        else:
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[flipped_site_nbr*N*N+((N-j-1)%N)*N+k][1] -= 2 - 2*total_spin
        
  # symmetry: flip sign and site nbrs for flipped spin on all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0], priorities[i*N*N+j*N+k][1] = priorities[(i+1)%N*N+(N-j-1)%N*k][0], priorities[(i+1)%N*N+(N-j-1)%N*k][1]
  
  return(priorities)




#score: {'data3D.txt': 0.391109}
#standard deviation: 0.04702051636254115
#island_id: 0
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [(i+((k-1)%2-1))%N,J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # symmetry: flip sign and site nbrs for flipped spin on all sites
        priorities[i*N*N+j*N+k] = np.roll(priorities[i*N*N+j*N+k], (i, j, k))
  
  return(priorities)




#score: {'data3D.txt': -0.4389198}
#standard deviation: 0.042533640426843315
#island_id: 3
#version_generated: 3
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))

        if i < N-1:
          z_plus = J[0,i+1,j,k]
          z_minus = J[1,i,(j+1)%N,k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [z_plus, z_minus] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(z_plus) + np.sign(z_minus))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,N-1,j,k], J[1,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(J[0,N-1,j,k]) + np.sign(J[1,i,(j+1)%N,k]))

        if j < N-1:
          y_plus = J[2,i,j,(k+1)%N]
          y_minus = J[2,i,j,k]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [y_plus, y_minus] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(y_plus) + np.sign(y_minus))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2,i,j,N-1], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - (np.sign(J[2,i,j,N-1]) + np.sign(y_minus))

  return(priorities)




#score: {'data3D.txt': -0.4711302}
#standard deviation: 0.03922373220334852
#island_id: 0
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
  
  return(priorities)




#score: {'data3D.txt': -0.44201060000000014}
#standard deviation: 0.0433215660801869
#island_id: 0
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.19809900000000016}
#standard deviation: 0.04431984926644043
#island_id: 0
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4464674000000001}
#standard deviation: 0.043834122521615504
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
          site_nbr_total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_nbr_total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + site_nbr_total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_nbr_total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
          site_nbr_total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_nbr_total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + site_nbr_total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_nbr_total_spin
          
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.43080900000000016}
#standard deviation: 0.04303883872736346
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.4201318000000001}
#standard deviation: 0.0431498823724932
#island_id: 0
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37773500000000015}
#standard deviation: 0.047839772313421396
#island_id: 3
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_center))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_center))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37773500000000015}
#standard deviation: 0.047839772313421396
#island_id: 3
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_center))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_center))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3607506000000001}
#standard deviation: 0.04801528672870756
#island_id: 3
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.33337660000000013}
#standard deviation: 0.05125349990429922
#island_id: 3
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)) / 2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 - (np.sum(np.sign(interacting_spins)) / 2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3 - (np.sum(np.sign(site_neighbors)) / 2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3 - (np.sum(np.sign(site_neighbors)) / 2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center) / 3 - (np.sum(np.sign(site_center)) / 2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_center))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + sum(val for val in site_center) / 3 - (np.sum(np.sign(site_center)) / 2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_center))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46612300000000007}
#standard deviation: 0.042658983004755284
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.48503620000000003}
#standard deviation: 0.04328777760014945
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.18959540000000016}
#standard deviation: 0.04613709244024812
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43080900000000016}
#standard deviation: 0.04303883872736346
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])
        
        total_spin_nbr = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.43080900000000016}
#standard deviation: 0.04303883872736346
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.2829302}
#standard deviation: 0.039779224325770864
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2002994}
#standard deviation: 0.04324883443099941
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
  
  return priorities




#score: {'data3D.txt': -0.0954094}
#standard deviation: 0.045694393000016965
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.2002994}
#standard deviation: 0.04324883443099941
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
  
  return priorities




#score: {'data3D.txt': -0.15375060000000002}
#standard deviation: 0.04405606064595426
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(val for val in site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(val for val in site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
        
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.37773500000000015}
#standard deviation: 0.047839772313421396
#island_id: 3
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_center))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + sum(val for val in site_center) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_center))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2337842}
#standard deviation: 0.05045854011324545
#island_id: 2
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2 + abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2 - abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.41920899999999994}
#standard deviation: 0.04506213176271181
#island_id: 2
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors + sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors - sum(val > 0 for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.37118380000000023}
#standard deviation: 0.04612742023525703
#island_id: 1
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        # Calculate the total spin
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        # If magnetism is positive, assign a higher priority to 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # If magnetism is negative, assign a higher priority to -1
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] += 2 - 2*sum(J[d,i,j,k] for d in range(3))
        else:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(3))
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49354580000000015}
#standard deviation: 0.044458536889555866
#island_id: 1
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.33100980000000013}
#standard deviation: 0.05104940924202747
#island_id: 1
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(3))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(3))
  
  return(priorities)




#score: {'data3D.txt': -0.27596740000000003}
#standard deviation: 0.05854261095339019
#island_id: 3
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins)) - np.sum(np.sign(h[site_nbr][i%N])) / 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins)) + np.sum(np.sign(h[site_nbr][i%N])) / 2
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3 - np.sum(np.sign(h[i%N, (j+1)%N])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors)) - np.sum(np.sign(h[i%N, (j+1)%N])) / 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3 + np.sum(np.sign(h[i%N, (j+1)%N])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors)) + np.sum(np.sign(h[i%N, (j+1)%N])) / 2
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.29079699999999997}
#standard deviation: 0.06793446688537418
#island_id: 3
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins)) - np.sum(np.sign(h[site_nbr][i%N])) / 2 + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins)) + np.sum(np.sign(h[site_nbr][i%N])) / 2 - abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.3269962000000001}
#standard deviation: 0.058071133152023134
#island_id: 3
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3 - np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins)) - np.sum(np.sign(h[site_nbr][i%N])) / 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3 + np.sum(np.sign(h[site_nbr][i%N])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins)) + np.sum(np.sign(h[site_nbr][i%N])) / 2

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 3 - np.sum(np.sign(h[(i+1)%N,j%N,k])) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors)) - np.sum(np.sign(h[(i+1)%N,j%N,k])) / 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 3 - np.sum(np.sign(h[(i+1)%N,j%N,k])) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors)) + np.sum(np.sign(h[(i+1)%N,j%N,k])) / 2

        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4602846000000001}
#standard deviation: 0.04547618016984276
#island_id: 3
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5143514}
#standard deviation: 0.04063369239978075
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_site_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1422974000000001}
#standard deviation: 0.045822019087333986
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin_neighbors = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.4597686000000001}
#standard deviation: 0.0429015805541008
#island_id: 1
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        total_spin = sum(J[d,i,j,k] for d in range(3))

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        else:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(3))

          elif h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(3))

          else:
            site_neighbors_sum = sum(val for val in site_neighbors)
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + site_neighbors_sum
              priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbors_sum

            elif h[site_nbr][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + site_neighbors_sum
              priorities[i*N*N+j*N+k][1] = -2 + 2*site_neighbors_sum

  return priorities




#score: {'data3D.txt': -0.4439290000000001}
#standard deviation: 0.045059118932797605
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(3))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(3))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': -0.33492260000000024}
#standard deviation: 0.04730973144332992
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(3))
          else:
            priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(3))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(3))
          else:
            priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(3))
            priorities[i*N*N+j*N+k][1] = -2 - 2*sum(J[d,i,j,k] for d in range(3))
  
  return(priorities)




#score: {'data3D.txt': -0.32751220000000014}
#standard deviation: 0.05207269775189298
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(6))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.27795099999999995}
#standard deviation: 0.05048231649795797
#island_id: 3
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        # Additional improvement: Use the sign of the interacting spins to adjust the priority
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * (np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin)
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': 0.040447}
#standard deviation: 0.04516846146372489
#island_id: 3
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))

        # Additional improvement: Use the sign of the interacting spins to adjust the priority
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))

        # Additional improvement: Use the sign of the site neighbors to adjust the priority
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(site_neighbors))

  return(priorities)




#score: {'data3D.txt': 0.040447}
#standard deviation: 0.04516846146372489
#island_id: 3
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))

        # Additional improvement: Use the sign of the interacting spins to adjust the priority
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))

        # New improvement: Use the sign of the site neighbors to adjust the priority
        sign_site_neighbors = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign_site_neighbors * np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign_site_neighbors * (2 - 2*total_spin) - np.sum(np.sign(site_neighbors))

  return(priorities)




#score: {'data3D.txt': -0.2250358}
#standard deviation: 0.04614003595967389
#island_id: 3
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.44201060000000014}
#standard deviation: 0.0433215660801869
#island_id: 0
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43536660000000016}
#standard deviation: 0.04355698479509343
#island_id: 0
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46612300000000007}
#standard deviation: 0.042658983004755284
#island_id: 0
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4201318000000001}
#standard deviation: 0.0431498823724932
#island_id: 0
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr

        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1292606}
#standard deviation: 0.04818296926964962
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.0421758}
#standard deviation: 0.05842064921207227
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for _ in range(N)) + sum(J[1,(i+1)%N,j,k] for _ in range(N)) + sum(J[2,i,j,(k+1)%N] for _ in range(N))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors

  return(priorities)




#score: {'data3D.txt': -0.2470238}
#standard deviation: 0.05473375954162111
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        # new additions: consider the magnetization of neighboring sites
        neighbors_magnetization = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_magnetization = sum(neighbors_magnetization)
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_magnetization)) * len([val for val in neighbors_magnetization if val < 0]) + (total_spin + total_magnetization) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_magnetization
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_magnetization)) * len([val for val in neighbors_magnetization if val > 0]) + (total_spin + total_magnetization) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.253691}
#standard deviation: 0.05893940480697103
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[1,(i+1)%N,j,k] for j in range(N)) + sum(J[2,i,j,(k+1)%N] for i in range(N))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + (total_spin + total_spin_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy

  return(priorities)




#score: {'data3D.txt': -0.24331540000000013}
#standard deviation: 0.04386186775366503
#island_id: 0
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.40730140000000004}
#standard deviation: 0.04573268675728555
#island_id: 3
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))

  return(priorities)




#score: {'data3D.txt': -0.40115660000000025}
#standard deviation: 0.048429194464083336
#island_id: 3
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin

  return(priorities)




#score: {'data3D.txt': -0.1911170000000003}
#standard deviation: 0.04639157112019381
#island_id: 3
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        sign = 1 if h[i][j][k] > 0 else -1
        
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.08897659999999999}
#standard deviation: 0.04479249192041005
#island_id: 3
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
        # added new logic here
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(site_neighbors))
        
        # added new logic here
        sign = -1 if h[i][j][k] > 0 else 1
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.4709578000000002}
#standard deviation: 0.045152449536653046
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += sum([np.exp(-abs(val)) * (val < 0) for val in site_neighbors]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5099982000000001}
#standard deviation: 0.04418946431854544
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*np.sum(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*np.sum(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum(site_neighbors) + len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*np.sum(J[:,i,j,k])
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.029915000000000008}
#standard deviation: 0.049929947075878216
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + np.sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.22655619999999999}
#standard deviation: 0.04569216696065093
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_site_nbr)) * len([val for val in interacting_spins if val < 0]) + total_spin_site_nbr - (len([val for val in site_neighbors if val < 0]) + abs(total_spin_site_nbr))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_site_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_site_nbr)) * len([val for val in interacting_spins if val > 0]) + total_spin_site_nbr - (len([val for val in site_neighbors if val > 0]) + abs(total_spin_site_nbr))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.2855262}
#standard deviation: 0.05154231769682073
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin)) - (total_spin_site_nbr >= 0)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2442302}
#standard deviation: 0.0437789639891124
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        if h[site_nbr][k][i] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val < 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + total_spin_neighbors - (len([val for val in site_neighbors if val > 0]) + abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.0808482}
#standard deviation: 0.06452004740202848
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0])
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[0,(i+1)%N,j,k] for i in range(N)) + sum(J[0,i,j,(k+1)%N] for k in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= -2 + 4*total_spin + 4*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = 6 - 4*total_spin - 4*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.012712200000000002}
#standard deviation: 0.046915155026494376
#island_id: 2
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d][site_nbr][j][k] for d in [0,1,2])
        site_neighbors = [J[0][((i+1)%N if i < N//2 else i-1)][j][k], J[1][i][((j+1)%N if j < N//2 else j-1)][k], J[2][i][j][((k+1)%N if k < N//2 else k-1)]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] -= -2 + 4*total_spin + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum(1 for val in site_neighbors if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 4*total_spin + sum(1 for val in site_neighbors if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.004481}
#standard deviation: 0.046894959633205786
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_neighbors = sum(J[0,i,(j+1)%N,k] for j in range(N)) + sum(J[0,(i+1)%N,j,k] for i in range(N)) + sum(J[0,i,j,(k+1)%N] for k in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin_neighbors / N**2) * 3
          priorities[i*N*N+j*N+k][1] -= -1 + 4*total_spin_neighbors / N**2
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin_neighbors / N**2) * 3
          priorities[i*N*N+j*N+k][1] = 3 - 4*total_spin_neighbors / N**2
        
  return(priorities)




#score: {'data3D.txt': -0.3689006}
#standard deviation: 0.04141504170757287
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k]] if val < 0]) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy

  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.46370900000000004}
#standard deviation: 0.04113205561359656
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors.sort(key=lambda x: abs(x))
        priorities[i*N*N+j*N+k][0] += sum(abs(val) for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3552514000000001}
#standard deviation: 0.05078024377688631
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        # New algorithm to improve the priority function:
        interacting_sites = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_site = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_site)) * len([val for val in interacting_sites if val < 0]) + total_spin_site
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_site - np.sum(np.sign(interacting_sites))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_site)) * len([val for val in interacting_sites if val > 0]) + total_spin_site
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_site + np.sum(np.sign(interacting_sites))
        
  return(priorities)




#score: {'data3D.txt': -0.5050222000000001}
#standard deviation: 0.04107050361463809
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_neighbors_3d = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if site_nbr < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_3d if val < 0]) + sum(val for val in site_neighbors_3d)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_3d if val > 0]) + sum(val for val in site_neighbors_3d)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.1493441999999999}
#standard deviation: 0.04833123510070895
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.33649700000000016}
#standard deviation: 0.04714776252379322
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,(k+1)%N], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) + sum(val for val in neighbor_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.4201318000000001}
#standard deviation: 0.0431498823724932
#island_id: 0
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_nbr = sum(J[d,i,(j+1)%N,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr

        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.18853780000000026}
#standard deviation: 0.046326937424785594
#island_id: 3
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        sign = 1 if h[i][j][k] > 0 else -1
        
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.1628726}
#standard deviation: 0.04526024093219125
#island_id: 3
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        sign = np.where(h[i][j][k], 1, -1)
        
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': 0.12925700000000012}
#standard deviation: 0.043773247434934506
#island_id: 3
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        sign = 1 if h[i][j][k] > 0 else -1

        priority_up = sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priority_down = -sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))

        priorities[i*N*N+j*N+k][0] += max(0, priority_up)
        priorities[i*N*N+j*N+k][1] -= min(0, priority_down)

  return(priorities)




#score: {'data3D.txt': -0.1911170000000003}
#standard deviation: 0.04639157112019381
#island_id: 3
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        sign = 1 if h[i][j][k] > 0 else -1
        
        priorities[i*N*N+j*N+k][0] += sign * np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= sign * (2 - 2*total_spin) - np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.029915000000000008}
#standard deviation: 0.049929947075878216
#island_id: 1
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + np.sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.08863339999999999}
#standard deviation: 0.051416461609488456
#island_id: 1
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if np.sum(site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.05051780000000002}
#standard deviation: 0.051624817318417705
#island_id: 1
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3550222000000001}
#standard deviation: 0.049583616922931305
#island_id: 1
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1417382}
#standard deviation: 0.06785204418998737
#island_id: 2
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

        site_neighbors_2 = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) - 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) - 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) + 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) + 2*sum(J[2,i,j,(k-1)%N] for k in range(N))

  return(priorities)




#score: {'data3D.txt': -0.1417382}
#standard deviation: 0.06785204418998737
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        
        site_neighbors_2 = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) - 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) - 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) + 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) + 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
  
  return(priorities)




#score: {'data3D.txt': -0.1417382}
#standard deviation: 0.06785204418998737
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

        site_neighbors_2 = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) - 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) - 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) + 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) + 2*sum(J[2,i,j,(k-1)%N] for k in range(N))

  return(priorities)




#score: {'data3D.txt': -0.1417382}
#standard deviation: 0.06785204418998737
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) - 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) - 2*sum(J[2,i,j,(k+1)%N] for i in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j+1)%N,k] for j in range(N)) + 2*sum(J[1,(i+1)%N,j,k] for j in range(N)) + 2*sum(J[2,i,j,(k+1)%N] for i in range(N))

        site_neighbors_2 = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) - 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) - 2*sum(J[2,i,j,(k-1)%N] for k in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + sum(val for val in site_neighbors_2) / 2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*sum(J[0,i,(j-1)%N,k] for j in range(N)) + 2*sum(J[1,(i-1)%N,j,k] for i in range(N)) + 2*sum(J[2,i,j,(k-1)%N] for k in range(N))

  return(priorities)




#score: {'data3D.txt': 0.036687399999999995}
#standard deviation: 0.047088056248267465
#island_id: 2
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin_neighbors = sum(J[d,i,(j+1)%N,k] if d < 3 else J[d-3,i,j,(k+1)%N] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + total_spin_neighbors

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.15053260000000018}
#standard deviation: 0.04441363368651567
#island_id: 2
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_neighbors)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_neighbors

        site_nbr_neighbors = [(i + ((j-1)%N - N//2)) % N, (i + ((k-1)%2 - 1)) % N]
        for site in site_nbr_neighbors:
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[site][j][k])
            priorities[i*N*N+j*N+k][1] = -h[site][j][k]

  return(priorities)




#score: {'data3D.txt': -0.36621339999999997}
#standard deviation: 0.04925138150793336
#island_id: 3
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.3964330000000002}
#standard deviation: 0.04669167967636205
#island_id: 3
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for l in range(3):
          site_center = [J[d,i,j,k] for d in [0,1,2]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center + site_neighbors if val < 0]) + sum(val for val in site_center + site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center + site_neighbors if val > 0]) + sum(val for val in site_center + site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5087685999999999}
#standard deviation: 0.042384996567653516
#island_id: 3
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][l] for l in range(N)) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.398691}
#standard deviation: 0.04860528941380764
#island_id: 3
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_center if val > 0]) + sum(val for val in site_center)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0954094}
#standard deviation: 0.045694393000016965
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.0954094}
#standard deviation: 0.045694393000016965
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])

  return priorities




#score: {'data3D.txt': -0.21339540000000023}
#standard deviation: 0.04491729131236656
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0]) - total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': 0.1680833999999999}
#standard deviation: 0.048934935214425296
#island_id: 1
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(6))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(6))
        
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(6))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': 0.17043060000000007}
#standard deviation: 0.04932875331528257
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum([val for val in interacting_spins]) + 1)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (np.sum([val for val in interacting_spins]) - 1)
          priorities[i*N*N+j*N+k][1] += h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
  
  return priorities




#score: {'data3D.txt': 0.1493441999999999}
#standard deviation: 0.04833123510070895
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + total_spin
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) - total_spin
          priorities[i*N*N+j*N+k][1] += h[i][j][k] + total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0783022}
#standard deviation: 0.04809276198306768
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,i,j,k]
        
        site_nbr_neighbors = [J[0,site_nbr,i,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        for d in range(3):
          if J[d,site_nbr,i,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,site_nbr,i,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,site_nbr,i,k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.25298220000000027}
#standard deviation: 0.04479419117653538
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(val for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3887914}
#standard deviation: 0.047076408168423386
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.34596220000000005}
#standard deviation: 0.05462833084728107
#island_id: 1
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        for neighbor in neighbors:
          if h[neighbor][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.45212260000000004}
#standard deviation: 0.04697944028231924
#island_id: 1
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + np.sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4857686}
#standard deviation: 0.04122873772067247
#island_id: 0
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': 0.27450220000000003}
#standard deviation: 0.044250574630845196
#island_id: 0
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        spin_energy = h[i][j][k]
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
            priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + spin_energy
            priorities[i*N*N+j*N+k][1] = -2 + 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4229666000000001}
#standard deviation: 0.04291050272881921
#island_id: 0
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_energy = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*spin_energy

  return(priorities)




#score: {'data3D.txt': -0.05051780000000002}
#standard deviation: 0.051624817318417705
#island_id: 1
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        spin = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin
        priorities[i*N*N+j*N+k][1] -= spin

  return(priorities)




#score: {'data3D.txt': 0.3161942000000002}
#standard deviation: 0.04777183947013136
#island_id: 1
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          if np.sum([val for val in site_neighbors if val < 0]) > 0:
            priorities[i*N*N+j*N+k][0] += 3
          elif np.sum([val for val in site_neighbors if val > 0]) > 0:
            priorities[i*N*N+j*N+k][0] -= 3

        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          if np.sum([val for val in site_neighbors if val < 0]) > 0:
            priorities[i*N*N+j*N+k][0] -= 3
          elif np.sum([val for val in site_neighbors if val > 0]) > 0:
            priorities[i*N*N+j*N+k][0] += 3

  return(priorities)




#score: {'data3D.txt': -0.040887000000000104}
#standard deviation: 0.047535264288736195
#island_id: 1
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_nbr = (i + ((k-1)%2 - 1)) % N
        if h[neighbor_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.2705974}
#standard deviation: 0.05161685958327957
#island_id: 1
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(J[d,i,j,k] for d in range(3)) > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1547574}
#standard deviation: 0.04342829383293799
#island_id: 0
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2])))*len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.2748502000000002}
#standard deviation: 0.04580724134850297
#island_id: 0
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
          for neighbor in site_neighbors:
            site_nbr_neighbors = [J[0,i,neighbor,k], J[1,i,j,neighbor], J[2,i,site_nbr,neighbor]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,neighbor,k] for d in [0,1,2])))*len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,neighbor,k] for d in [0,1,2])
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
          for neighbor in site_neighbors:
            site_nbr_neighbors = [J[0,i,neighbor,k], J[1,i,j,neighbor], J[2,i,site_nbr,neighbor]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,neighbor,k] for d in [0,1,2])))*len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,neighbor,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.26480020000000026}
#standard deviation: 0.048746581828472836
#island_id: 2
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4966042}
#standard deviation: 0.043748852583353544
#island_id: 2
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2956022}
#standard deviation: 0.04290084515670991
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[d,i,j,k] for d in [0,1,2]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5340130000000001}
#standard deviation: 0.04195602782676168
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3501242000000003}
#standard deviation: 0.04649351669168509
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.34904900000000016}
#standard deviation: 0.04540097486838801
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,(k+1)%N], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) + sum(val for val in neighbor_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3066250000000002}
#standard deviation: 0.048712558288392105
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k] * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.3037194000000002}
#standard deviation: 0.04820608865734701
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5091886}
#standard deviation: 0.04090321442185198
#island_id: 2
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.5247178000000001}
#standard deviation: 0.042473051257944726
#island_id: 2
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.39802740000000025}
#standard deviation: 0.04619820093077218
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
          
  return priorities




#score: {'data3D.txt': 0.0783022}
#standard deviation: 0.04809276198306768
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,i,j,k]
        
        site_nbr_neighbors = [J[0,site_nbr,i,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        for d in range(3):
          if J[d,site_nbr,i,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,site_nbr,i,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,site_nbr,i,k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': 0.0783022}
#standard deviation: 0.04809276198306768
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,i,j,k]
        
        site_nbr_neighbors = [J[0,site_nbr,i,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        for d in range(3):
          if J[d,site_nbr,i,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,site_nbr,i,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,site_nbr,i,k])
            priorities[i*N*N+j*N+k][1] += 2 + 2*J[d,site_nbr,i,k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.427353}
#standard deviation: 0.042385985313544386
#island_id: 2
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.1470314}
#standard deviation: 0.04557785267034857
#island_id: 2
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val > 0]
        priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] += 2 + 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.28346580000000005}
#standard deviation: 0.045059951513067575
#island_id: 2
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': 0.037214999999999825}
#standard deviation: 0.04873990290306291
#island_id: 2
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          interacting_spins += [val for val in site_neighbors if val < 0]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          interacting_spins += [val for val in site_neighbors if val > 0]
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*len(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.22418420000000008}
#standard deviation: 0.04395166197494699
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0]) + np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45781780000000005}
#standard deviation: 0.04090951629095607
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # New term: interaction with nearest neighbors
        for d in range(3):
          nn = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          interacting_spins = [val for val in nn if val < 0]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
          
  return(priorities)




#score: {'data3D.txt': -0.427353}
#standard deviation: 0.042385985313544386
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5043394000000001}
#standard deviation: 0.04328015489390028
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.5307654}
#standard deviation: 0.041807737595330366
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5340130000000001}
#standard deviation: 0.04195602782676168
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.24555860000000007}
#standard deviation: 0.04553897326510557
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = h[i][j][k] - total_spin
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
            priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
            priorities[i*N*N+j*N+k][1] = h[i][j][k] - total_spin
          else:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
              priorities[i*N*N+j*N+k][1] -= h[i][j][k]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
              priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5340130000000001}
#standard deviation: 0.04195602782676168
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2563825999999999}
#standard deviation: 0.04815800968935488
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) + len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.2665206000000001}
#standard deviation: 0.04548396262024672
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          interacting_spins = [val for val in site_neighbors if val < 0]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.47748820000000003}
#standard deviation: 0.044560674375058555
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.16334820000000003}
#standard deviation: 0.04839253906089244
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val != 0]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.4821226000000001}
#standard deviation: 0.04229887527157194
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins + [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins + [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49274940000000006}
#standard deviation: 0.04100753832699545
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        magnetism = np.sign(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += magnetism
        priorities[i*N*N+j*N+k][1] -= magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.4688194}
#standard deviation: 0.044572340118508476
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors + [J[d,i,j,k] for d in [0,1,2]]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4982998}
#standard deviation: 0.03965522210201325
#island_id: 3
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.1371942}
#standard deviation: 0.047501202578040067
#island_id: 3
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) + np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 3
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5023478}
#standard deviation: 0.04347468729226238
#island_id: 3
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5023478}
#standard deviation: 0.04347468729226238
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.502077}
#standard deviation: 0.0434896377428003
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetization of neighboring spins
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
  return(priorities)




#score: {'data3D.txt': 0.0548214}
#standard deviation: 0.045052593066770306
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5409390000000001}
#standard deviation: 0.041891910424328944
#island_id: 3
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5135274}
#standard deviation: 0.043134572320123916
#island_id: 3
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5145914}
#standard deviation: 0.042079581343449704
#island_id: 3
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy, the interaction with neighboring sites and the number of nearest neighbors with the same spin
        site_neighbor_same_spin_count = 0
        for d in [0, 1, 2]:
          if J[d,i,j,k] < 0:
            site_neighbor_same_spin_count += 1
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3) + site_neighbor_same_spin_count
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5319034}
#standard deviation: 0.041215941435808555
#island_id: 3
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.47748820000000003}
#standard deviation: 0.044560674375058555
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5043394000000001}
#standard deviation: 0.04328015489390028
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5129701999999999}
#standard deviation: 0.04247482962838109
#island_id: 3
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbor_same_spin_count = 0
        for d in [0, 1, 2]:
          if J[d,i,j,k] < 0:
            site_neighbor_same_spin_count += 1
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3) + site_neighbor_same_spin_count
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the local energy, the interaction with neighboring sites and the number of nearest neighbors with the same spin
        for d in [0, 1, 2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5261346000000001}
#standard deviation: 0.04204557816037259
#island_id: 3
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbor_same_spin_count = 0
        for d in [0, 1, 2]:
          if J[d,i,j,k] < 0:
            site_neighbor_same_spin_count += 1
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3) + site_neighbor_same_spin_count
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5145914}
#standard deviation: 0.042079581343449704
#island_id: 3
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy, the interaction with neighboring sites and the number of nearest neighbors with the same spin
        site_neighbor_same_spin_count = 0
        for d in [0, 1, 2]:
          if J[d,i,j,k] < 0:
            site_neighbor_same_spin_count += 1
        
        # Calculate the total interaction energy from neighboring sites and add it to the priority score
        site_interaction_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * site_interaction_energy + site_neighbor_same_spin_count
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.35674219999999995}
#standard deviation: 0.04314637202778468
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors
        
        # Add a new term based on the total energy
        priorities[i*N*N+j*N+k][0] += np.exp(-(total_spin + h[i][j][k]))
        priorities[i*N*N+j*N+k][1] += -(total_spin + h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.5190962}
#standard deviation: 0.03971022721617191
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (num_positive_neighbors + 1) 
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (num_positive_neighbors + 1) 
        
  return(priorities)




#score: {'data3D.txt': -0.25361700000000004}
#standard deviation: 0.046048575993183544
#island_id: 3
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum(h[i][j]) / N)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum(h[i][j]) / N)
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2002994}
#standard deviation: 0.04324883443099941
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]
  
  return priorities




#score: {'data3D.txt': -0.1934606}
#standard deviation: 0.04346889149311264
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.2247914}
#standard deviation: 0.04167529779185747
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in site_neighbors if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr

        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.34596220000000005}
#standard deviation: 0.05462833084728107
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        for neighbor in neighbors:
          if h[neighbor][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3182554000000002}
#standard deviation: 0.05032596318839809
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + np.sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.sum([val for val in [J[d,i,j,k]] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.sum([val for val in [J[d,i,j,k]] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.510941}
#standard deviation: 0.041382275420764385
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        total_neighbor_spin = 0
        for neighbor in neighbors:
          if h[neighbor][j][k] > 0:
            total_neighbor_spin += 1
          else:
            total_neighbor_spin -= 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin + total_neighbor_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3086378}
#standard deviation: 0.05119141071664269
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.2811706000000001}
#standard deviation: 0.04492216263315913
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif all(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] - total_spin
        elif any(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k])) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i][j][k])) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.24973539999999994}
#standard deviation: 0.04564531812617808
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = h[i][j][k] - total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] - total_spin
        else:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5319034}
#standard deviation: 0.041215941435808555
#island_id: 3
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5319034}
#standard deviation: 0.041215941435808555
#island_id: 3
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5157002000000002}
#standard deviation: 0.04253853782113344
#island_id: 3
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5319034}
#standard deviation: 0.041215941435808555
#island_id: 3
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and the interaction with neighboring sites
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]) / 3
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.2547426}
#standard deviation: 0.04553239050653941
#island_id: 3
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i) - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4464674000000001}
#standard deviation: 0.043834122521615504
#island_id: 0
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
          site_nbr_total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_nbr_total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + site_nbr_total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_nbr_total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
          site_nbr_total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_nbr_total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + site_nbr_total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_nbr_total_spin
          
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': 0.07949379999999996}
#standard deviation: 0.047677741993093596
#island_id: 1
#version_generated: 3
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        elif h[site_nbr][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + site_neighbors_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbors_sum
        
        elif h[site_nbr][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + site_neighbors_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_neighbors_sum
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.10722140000000001}
#standard deviation: 0.05235762238719402
#island_id: 1
#version_generated: 3
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in J[0,:,j,k] if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in J[0,:,j,k] if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': -0.3835334}
#standard deviation: 0.04565475314181427
#island_id: 1
#version_generated: 3
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.18672260000000007}
#standard deviation: 0.04731751355724432
#island_id: 1
#version_generated: 3
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.sum([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_site_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in [J[0,site_nbr,j,k], J[1,site_nbr,j,k], J[2,site_nbr,j,k]] if val < 0]) + total_spin_site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_site_nbr
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in [J[0,site_nbr,j,k], J[1,site_nbr,j,k], J[2,site_nbr,j,k]] if val > 0]) + total_spin_site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_site_nbr
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4502386000000002}
#standard deviation: 0.04734521380287558
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34596220000000005}
#standard deviation: 0.05462833084728107
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        for neighbor in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if h[neighbor][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.47044340000000007}
#standard deviation: 0.040975012830260345
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        total_neighbor_spin = sum(h[n][j][k] for n in neighbors)
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k] + np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin + total_neighbor_spin
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34596220000000005}
#standard deviation: 0.05462833084728107
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        for neighbor in neighbors:
          if h[neighbor][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4231046}
#standard deviation: 0.04208252438768378
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.5043394000000001}
#standard deviation: 0.04328015489390028
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.012375800000000013}
#standard deviation: 0.05108286615255647
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        # new calculation
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin / abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*(total_spin / abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': 0.046295400000000056}
#standard deviation: 0.04677580634088525
#island_id: 0
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3689006}
#standard deviation: 0.04141504170757287
#island_id: 0
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k]] if val < 0]) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3689006}
#standard deviation: 0.04141504170757287
#island_id: 0
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k]] if val < 0]) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3011938000000002}
#standard deviation: 0.04970826170326217
#island_id: 2
#version_generated: 3
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.044468600000000004}
#standard deviation: 0.050849791878040174
#island_id: 2
#version_generated: 3
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        for d in [0,1]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d==0)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*d
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (d==0)
            priorities[i*N*N+j*N+k][1] = -2 + 2*d
        
  return(priorities)




#score: {'data3D.txt': -0.2582558}
#standard deviation: 0.04522776455187676
#island_id: 3
#version_generated: 3
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum(h[i][j]) / N)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum(h[i][j]) / N)
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return priorities




#score: {'data3D.txt': -0.25361700000000004}
#standard deviation: 0.046048575993183544
#island_id: 3
#version_generated: 3
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum(h[i][j]) / N)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum(h[i][j]) / N)

        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return(priorities)




#score: {'data3D.txt': -0.151131}
#standard deviation: 0.04600679253110349
#island_id: 3
#version_generated: 3
#generate time14:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum(h[i][j]) / N)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum(h[i][j]) / N)
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add new term based on the total number of positive spins in the neighborhood
        priorities[i*N*N+j*N+k][0] += np.exp(-sum(1 for val in interacting_spins if val > 0)) * sum(1 for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.23504540000000032}
#standard deviation: 0.04686889180298591
#island_id: 1
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in J[0,:,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[site_nbr][j][k] * len([val for val in J[0,:,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k] * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.22895180000000034}
#standard deviation: 0.047704228290163124
#island_id: 1
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k] * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,(site_nbr+1)%N,j,k]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in site_neighbors + [J[0,site_nbr,(j+1)%N,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[site_nbr][j][k] * len([val for val in site_neighbors + [J[0,site_nbr,(j+1)%N,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.3066250000000002}
#standard deviation: 0.048712558288392105
#island_id: 1
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k] * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.22984100000000035}
#standard deviation: 0.04664751353502135
#island_id: 2
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in [0,1]:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3179966000000001}
#standard deviation: 0.04640086150536432
#island_id: 2
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0]) + np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in [site_up, site_down, site_left, site_right] if val < 0]) + sum(val for val in [site_up, site_down, site_left, site_right])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in [site_up, site_down, site_left, site_right] if val > 0]) + sum(val for val in [site_up, site_down, site_left, site_right])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3702514000000001}
#standard deviation: 0.04741566954119703
#island_id: 2
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.21754220000000002}
#standard deviation: 0.04697946933672197
#island_id: 3
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the second-order correction
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]]))) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.046280999999999996}
#standard deviation: 0.04495840076114807
#island_id: 3
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy, the interaction with neighboring spins, and the total spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2159666}
#standard deviation: 0.04695073465282519
#island_id: 3
#version_generated: 3
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy, the interaction with neighboring spins and the global spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]]))) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.17043060000000007}
#standard deviation: 0.04932875331528257
#island_id: 1
#version_generated: 3
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum([val for val in interacting_spins]) + 1)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (np.sum([val for val in interacting_spins]) - 1)
          priorities[i*N*N+j*N+k][1] += h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
        
  return(priorities)




#score: {'data3D.txt': 0.08647380000000005}
#standard deviation: 0.05090232483452991
#island_id: 1
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - 2*J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 + 2*J[d,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum([val for val in interacting_spins]) + 1)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (np.sum([val for val in interacting_spins]) - 1)
          priorities[i*N*N+j*N+k][1] += h[i][j][k] * (np.sum([val for val in interacting_spins]) + 2)
        
        if site_nbr == i:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
  
  return(priorities)




#score: {'data3D.txt': -0.1977906}
#standard deviation: 0.04229276192967303
#island_id: 0
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy

  return(priorities)




#score: {'data3D.txt': 0.44966380000000017}
#standard deviation: 0.04216105180803724
#island_id: 2
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4469986}
#standard deviation: 0.046749968535176586
#island_id: 2
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        # Additional optimization
        site_nbr_neighbors = [J[0,site_nbr,(j+1)%N,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        interacting_spins = [val for val in site_nbr_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.47748820000000003}
#standard deviation: 0.044560674375058555
#island_id: 2
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.4299278}
#standard deviation: 0.04303769170343596
#island_id: 2
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum([1 if val > 0 else -1 for val in site_neighbors])
        
        diagonals = [J[0,i,(j+1)%N,k-1], J[1,(i+1)%N,j-1,k], J[2,i,j-1,(k+1)%N]]
        interacting_spins = [val for val in diagonals if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23950540000000017}
#standard deviation: 0.04763213842396749
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40120500000000026}
#standard deviation: 0.04504387655386689
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.5220378000000001}
#standard deviation: 0.04007542053628384
#island_id: 1
#version_generated: 2
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 1
#version_generated: 2
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 1
#version_generated: 2
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 1
#version_generated: 2
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.34504060000000003}
#standard deviation: 0.047199532112511454
#island_id: 2
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        site_neighbors = [site_up, site_down, site_left, site_right]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add some magic here to improve the algorithm
        if i < N-1 and j < N-1 and k < N-1:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.02427020000000021}
#standard deviation: 0.04983303073223622
#island_id: 2
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend(site_neighbors)
        total_spin += sum(J[d,i,j,k] for d in [0,1,2])
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        interacting_spins.extend([site_up, site_down, site_left, site_right])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4415998000000001}
#standard deviation: 0.04329450912021062
#island_id: 2
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33080060000000033}
#standard deviation: 0.04674378118680601
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.005945399999999995}
#standard deviation: 0.0455683576491407
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val > 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 1
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 1
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5000322}
#standard deviation: 0.04054446698576762
#island_id: 1
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4951978000000001}
#standard deviation: 0.04238968312172197
#island_id: 2
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val > 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5227126000000001}
#standard deviation: 0.042335811805609684
#island_id: 2
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N

        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5086574000000001}
#standard deviation: 0.042265103634558855
#island_id: 2
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4009038000000002}
#standard deviation: 0.04616707469138585
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44340700000000005}
#standard deviation: 0.04032569591463984
#island_id: 1
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] -= 3
  
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3421694000000002}
#standard deviation: 0.04637958757513913
#island_id: 2
#version_generated: 3
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1713526}
#standard deviation: 0.05343086629692616
#island_id: 2
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend([val if val < 0 else -val for val in site_neighbors])
        total_spin += sum(J[d,i,j,k] for d in [0,1,2])

        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        interacting_spins.extend([val if val < 0 else -val for val in [site_up, site_down, site_left, site_right]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2645902000000001}
#standard deviation: 0.04623206964824309
#island_id: 2
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if h[i][j][0] > 0:
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k]] if val < 0]) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
      else:
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k]] if val > 0]) * np.exp(abs(total_spin))
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.061229399999999996}
#standard deviation: 0.044952407450991994
#island_id: 2
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend(site_neighbors)

        up_down = 0
        left_right = 0

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          up_down = J[0,i,j,k]
          left_right = J[2,i,j,(k+1)%N]

          if up_down > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2

          if left_right > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2

        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.29011180000000014}
#standard deviation: 0.047416811583656696
#island_id: 2
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.23291500000000012}
#standard deviation: 0.04351233589454834
#island_id: 0
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(spin_energy)
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.1977906}
#standard deviation: 0.04229276192967303
#island_id: 0
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.23291500000000012}
#standard deviation: 0.04351233589454834
#island_id: 0
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbors
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(spin_energy)
        priorities[i*N*N+j*N+k][1] -= spin_energy
  
  return(priorities)




#score: {'data3D.txt': -0.4138038000000001}
#standard deviation: 0.044232276287344746
#island_id: 2
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighboring_spin_counts = [sum(1 if val < 0 else -1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]), 
                      sum(1 if val < 0 else -1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]),
                      sum(1 if val < 0 else -1 for val in [J[0,i,j,(k+1)%N], J[1,(i+1)%N,j,k]])]

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighboring_spin_counts[2] + 2) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4190994000000001}
#standard deviation: 0.04492318688205458
#island_id: 2
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3043366000000003}
#standard deviation: 0.04593445700604286
#island_id: 2
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.29011180000000014}
#standard deviation: 0.047416811583656696
#island_id: 2
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3366454000000001}
#standard deviation: 0.04840037746588347
#island_id: 2
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 if val < 0 else -1 for val in interacting_spins) + 2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (sum(1 if val > 0 else -1 for val in interacting_spins) + 2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a small trick to adjust the spin based on the site's magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.29011180000000014}
#standard deviation: 0.047416811583656696
#island_id: 2
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.48559860000000016}
#standard deviation: 0.042111480121696035
#island_id: 2
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5094706}
#standard deviation: 0.0409320257944803
#island_id: 1
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        dist_to_boundary = max(i, j, k) / N
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 + dist_to_boundary)
          priorities[i*N*N+j*N+k][1] -= (2 - 2*total_spin) * (1 + dist_to_boundary)
        elif i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - dist_to_boundary)
          priorities[i*N*N+j*N+k][1] -= (-2 + 2*total_spin) * (1 - dist_to_boundary)
        
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.4220918}
#standard deviation: 0.04101411674972411
#island_id: 1
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4932770000000001}
#standard deviation: 0.04198925137460777
#island_id: 1
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.431621}
#standard deviation: 0.03976092351794661
#island_id: 1
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the nearest neighbor's spin
        if i > 0:
          site_nbr_spin = J[2,i-1,j,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if j > 0:
          site_nbr_spin = J[1,i,j-1,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k > 0:
          site_nbr_spin = J[2,i,j,k-1]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2731182}
#standard deviation: 0.0453568622014354
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add a new term based on the distance from the edge
        if k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2540318}
#standard deviation: 0.04535110041399216
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.2695014}
#standard deviation: 0.04606097000758885
#island_id: 3
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.2566738}
#standard deviation: 0.04613978103068978
#island_id: 3
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.4050034000000001}
#standard deviation: 0.0413764593511818
#island_id: 0
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 0
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbors_total_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbors_total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbors_total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*neighbors_total_spin

  return priorities




#score: {'data3D.txt': -0.13389939999999997}
#standard deviation: 0.04265337969774494
#island_id: 0
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, site_nbr, j, k], J[1, i, site_nbr, k], J[2, i, j, site_nbr]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, site_nbr, j, k] for d in [0, 1, 2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2559190000000003}
#standard deviation: 0.04625057101269129
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        interacting_spins = [site_up, site_down, site_left, site_right] + [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14288900000000018}
#standard deviation: 0.0474539983457664
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        total_spin += sum([site_up, site_down, site_left, site_right])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [site_up, site_down, site_left, site_right] if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [site_up, site_down, site_left, site_right] if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3239118000000002}
#standard deviation: 0.046151682317766056
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]] + [J[2,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3472326}
#standard deviation: 0.03881182934673397
#island_id: 2
#version_generated: 3
#generate time14:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0956934}
#standard deviation: 0.045020953748671294
#island_id: 0
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 0
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_spin_energy = h[i][j][k]
        
        if site_spin_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])

  return priorities




#score: {'data3D.txt': -0.37098180000000014}
#standard deviation: 0.04528188190391385
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= (h[i][j][k] + neighbor_spin)
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= (h[i][j][k] + neighbor_spin)
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i*N*N+j*N+k][1] -= 1.5
        
  return priorities




#score: {'data3D.txt': -0.3890026}
#standard deviation: 0.04436458625119815
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors
        site_nbr_energy = h[site_nbr % N, (j+1)%N, k]
        if site_nbr_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        elif site_nbr_energy < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.431621}
#standard deviation: 0.03976092351794661
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary and magnetism
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the nearest neighbor's spin and magnetism
        if i > 0:
          site_nbr_spin = J[2,i-1,j,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if j > 0:
          site_nbr_spin = J[1,i,j-1,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k > 0:
          site_nbr_spin = J[2,i,j,k-1]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.476741}
#standard deviation: 0.04140405196354579
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and nearest neighbors with the same spin
        site_nbr_energy = h[site_nbr][j][k]
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (site_nbr_energy + 1)
            priorities[i*N*N+j*N+k][1] -= site_nbr_energy + 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (site_nbr_energy + 1)
            priorities[i*N*N+j*N+k][1] -= site_nbr_energy + 1

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (2 + site_nbr_energy)
          priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_energy

  return(priorities)




#score: {'data3D.txt': -0.4279986000000003}
#standard deviation: 0.045851055800711936
#island_id: 1
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3825058}
#standard deviation: 0.04107828387798108
#island_id: 1
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the third nearest neighbors with the same spin
        if k > 2:
          neighbor_spin = J[2,i,j,k-3]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-3:
          neighbor_spin = J[2,i,j,k+3]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1934606}
#standard deviation: 0.04346889149311264
#island_id: 0
#version_generated: 3
#generate time14:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))*len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        total_spin_nbr = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_nbr
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_nbr)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_nbr
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]] if val < 0]) + J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.24977539999999998}
#standard deviation: 0.04852843202536015
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
          site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
          
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if neighbor_spin_count > 0:
            priorities[i*N*N+j*N+k][0] -= 3 * np.exp(neighbor_spin_count)
            priorities[i*N*N+j*N+k][1] += 3 * neighbor_spin_count
        else:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
          site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
          
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val > 0 else -1 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if neighbor_spin_count > 0:
            priorities[i*N*N+j*N+k][0] += 3 * np.exp(neighbor_spin_count)
            priorities[i*N*N+j*N+k][1] -= 3 * neighbor_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.35785060000000024}
#standard deviation: 0.04588117216942043
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5071342000000001}
#standard deviation: 0.042957928608814464
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val > 0 else -1 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2797466000000003}
#standard deviation: 0.04646716075294463
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin**2 + len([val for val in J[::1,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin**2 + len([val for val in J[::1,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40120500000000026}
#standard deviation: 0.04504387655386689
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.4692866}
#standard deviation: 0.04347560396866271
#island_id: 2
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0,i,j,:].flatten() if val < 0]) + len([val for val in J[1,:,j,:].flatten() if val < 0]) + len([val for val in J[2,:,:].flatten() if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (len([val for val in J[0,i,j,:].flatten() if val > 0]) + len([val for val in J[1,:,j,:].flatten() if val > 0]) + len([val for val in J[2,:,:].flatten() if val > 0]))
          priorities[i*N*N+j*N+k][1] = -3 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.37736300000000006}
#standard deviation: 0.038561654930772876
#island_id: 2
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) - total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3555206000000002}
#standard deviation: 0.04444837067475028
#island_id: 2
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val < 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          spin_count = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_count = sum(1 if val > 0 else -1 for val in site_neighbors)

          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_count + 2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3472326}
#standard deviation: 0.03881182934673397
#island_id: 2
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33000579999999996}
#standard deviation: 0.047084760234708645
#island_id: 2
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          
          priorities[i*N*N+j*N+k][0] += sum(1 if val < 0 else -1 for val in interacting_spins) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          
          priorities[i*N*N+j*N+k][0] -= sum(1 if val > 0 else -1 for val in interacting_spins) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4821289999999999}
#standard deviation: 0.04339016615547813
#island_id: 3
#version_generated: 3
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif all(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.524479}
#standard deviation: 0.04046114134574061
#island_id: 3
#version_generated: 3
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetization of neighboring spins
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.2239506}
#standard deviation: 0.045357409974997466
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.2239506}
#standard deviation: 0.045357409974997466
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return(priorities)




#score: {'data3D.txt': -0.2239506}
#standard deviation: 0.045357409974997466
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.44878139999999994}
#standard deviation: 0.043290473017050767
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2776902000000002}
#standard deviation: 0.04667146777164823
#island_id: 3
#version_generated: 3
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate interactions with neighbors
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        for neighbor in site_neighbors:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[0,i,j,k])) * len([val for val in [J[d,i,neighbor,k] for d in [0,1,2]] if val < 0]) + sum(J[d,i,neighbor,k] for d in [0,1,2])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,neighbor,k] for d in [0,1,2])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[0,i,j,k])) * len([val for val in [J[d,i,neighbor,k] for d in [0,1,2]] if val > 0]) + sum(J[d,i,neighbor,k] for d in [0,1,2])
            priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,neighbor,k] for d in [0,1,2])

  return priorities




#score: {'data3D.txt': -0.4641466}
#standard deviation: 0.04150303782182698
#island_id: 3
#version_generated: 3
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors
        
        # Add a new term based on the total energy
        priorities[i*N*N+j*N+k][0] += np.exp(-(total_spin + h[i][j][k]))
        priorities[i*N*N+j*N+k][1] += -(total_spin + h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.4003106}
#standard deviation: 0.04248757898068564
#island_id: 3
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors
        
        # Add a new term based on the total energy
        priorities[i*N*N+j*N+k][0] += np.exp(-(total_spin + h[i][j][k]))
        priorities[i*N*N+j*N+k][1] += -(total_spin + h[i][j][k])
        
        # Add a new term based on the magnitude of the local field
        local_field = h[i][j][k]
        if local_field > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-local_field)
          priorities[i*N*N+j*N+k][1] -= local_field
        elif local_field < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(local_field))
          priorities[i*N*N+j*N+k][1] = -abs(local_field)
        
  return(priorities)




#score: {'data3D.txt': -0.5308706}
#standard deviation: 0.04095394993941366
#island_id: 3
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (len([val for val in neighbor_spins if val > 0]))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (len([val for val in neighbor_spins if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.35674219999999995}
#standard deviation: 0.04314637202778468
#island_id: 3
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of neighbors with positive spin
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-num_positive_neighbors)
        priorities[i * N * N + j * N + k][1] -= num_positive_neighbors

        # Add a new term based on the total energy
        priorities[i * N * N + j * N + k][0] += np.exp(-(total_spin + h[i][j][k]))
        priorities[i * N * N + j * N + k][1] += -(total_spin + h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.31321219999999994}
#standard deviation: 0.045818799320366296
#island_id: 2
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        interacting_spins = [site_up, site_down, site_left, site_right] + [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= (2 - 2*total_spin) + np.sum(np.abs(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -(2 - 2*total_spin) + np.sum(np.abs(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.3336818000000003}
#standard deviation: 0.04631132894616608
#island_id: 2
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        interacting_spins = [site_up, site_down, site_left, site_right] + [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.24829460000000017}
#standard deviation: 0.04758203243704497
#island_id: 2
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        interacting_spins = [site_up, site_down, site_left, site_right] + [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [site_up, site_down, site_left, site_right]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.1096934}
#standard deviation: 0.04581007090629745
#island_id: 2
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin)) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.49220540000000007}
#standard deviation: 0.041287927664633406
#island_id: 1
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        
  return(priorities)




#score: {'data3D.txt': -0.4909394000000001}
#standard deviation: 0.04053132575724609
#island_id: 1
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        
  return(priorities)




#score: {'data3D.txt': -0.48112260000000007}
#standard deviation: 0.041853558620982285
#island_id: 1
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        neighbor_spin = J[2,i,site_nbr,k]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and magnetism
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.4313802}
#standard deviation: 0.040418557717464394
#island_id: 1
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + 2
            priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + 2
            priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        
        # Add a new term based on the distance to the boundary
        boundary_penalty = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + 3
        priorities[i*N*N+j*N+k][0] += boundary_penalty
        priorities[i*N*N+j*N+k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3366454000000001}
#standard deviation: 0.04840037746588347
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 if val < 0 else -1 for val in interacting_spins) + 2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (sum(1 if val > 0 else -1 for val in interacting_spins) + 2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a small trick to adjust the spin based on the site's magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.37736300000000006}
#standard deviation: 0.038561654930772876
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) - total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27492700000000003}
#standard deviation: 0.04892724712264118
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]
        
        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 if val < 0 else -1 for val in interacting_spins) + 2) / len([val for val in interacting_spins if val < 0]) 
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (sum(1 if val > 0 else -1 for val in interacting_spins) + 2) / len([val for val in interacting_spins if val > 0]) 
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.10509300000000009}
#standard deviation: 0.05000384976179335
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          spin_count = sum(1 if val < 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_count + 2) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1258530000000001}
#standard deviation: 0.049418872012622884
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.11255420000000006}
#standard deviation: 0.05012586739758227
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - (total_spin**2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - (total_spin**2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2865734000000003}
#standard deviation: 0.045997703990960224
#island_id: 2
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        up = J[0,i,j,k]
        down = J[1,(i+1)%N,j,k]
        left = J[2,i,(j+1)%N,k]
        right = J[2,i,j,(k+1)%N]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + [up, down, left, right] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + [up, down, left, right] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.46612300000000007}
#standard deviation: 0.042658983004755284
#island_id: 0
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])

        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(spin_energy)
        priorities[i*N*N+j*N+k][1] -= spin_energy

  return(priorities)




#score: {'data3D.txt': -0.46612300000000007}
#standard deviation: 0.042658983004755284
#island_id: 0
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(spin_energy)
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.46612300000000007}
#standard deviation: 0.042658983004755284
#island_id: 0
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        site_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4259554}
#standard deviation: 0.04171633026573647
#island_id: 1
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 + np.exp(-abs(neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 + np.exp(-abs(neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 + np.exp(-abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 + np.exp(-abs(neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 + np.exp(-abs(neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3112546}
#standard deviation: 0.0432329321101403
#island_id: 1
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of second nearest neighbors with different spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.37119820000000003}
#standard deviation: 0.041570473617220195
#island_id: 1
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
            priorities[i*N*N+j*N+k][1] -= 1.5
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
            priorities[i*N*N+j*N+k][1] -= 1.5
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] -= 3
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        
  return(priorities)




#score: {'data3D.txt': -0.27145539999999996}
#standard deviation: 0.042401362370093724
#island_id: 1
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] -= 3
        
        # Add a new term based on the distance to the center
        if i > N/2 or j > N/2 or k > N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.4158526}
#standard deviation: 0.04073292124608791
#island_id: 1
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
            priorities[i*N*N+j*N+k][1] -= 1.5
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
            priorities[i*N*N+j*N+k][1] -= 1.5
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return(priorities)




#score: {'data3D.txt': -0.5335742}
#standard deviation: 0.04046884745529579
#island_id: 1
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2, i, j, k - 1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2, i, j, k + 1] < 0

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - same_spin_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - same_spin_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.3695766}
#standard deviation: 0.04153596480689958
#island_id: 1
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its gradient
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k]**2)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin and its gradient
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (i + j + k)
          priorities[i*N*N+j*N+k][1] -= i + j + k
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - 1 - i - j - k)
          priorities[i*N*N+j*N+k][1] -= N - 1 - i - j - k
        
  return(priorities)




#score: {'data3D.txt': -0.4937566000000001}
#standard deviation: 0.04165117329007672
#island_id: 1
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and second nearest neighbors with same spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.exp(-abs(total_spin)) * (1.5 if k > 1 else 1) + 1.5 if k < N-2 else 1)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.exp(-abs(total_spin)) * (1.5 if k > 1 else 1) + 1.5 if k < N-2 else 1)

  return(priorities)




#score: {'data3D.txt': -0.1864898000000002}
#standard deviation: 0.04522492648927138
#island_id: 2
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins + site_neighbors if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins + site_neighbors if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.15663660000000015}
#standard deviation: 0.04408473636577631
#island_id: 2
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin)) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
        # Calculate the total spin including the current site
        total_spin_with_site = total_spin + h[i][j][k]
        
        # Update the priority based on the total spin with the site included
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_with_site)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin_with_site
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_with_site
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin_with_site)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin_with_site
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_with_site
        
  return(priorities)




#score: {'data3D.txt': -0.1096934}
#standard deviation: 0.04581007090629745
#island_id: 2
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [val for val in site_neighbors if val < 0]
        priorities[i*N*N+j*N+k][0] += len(interacting_spins) * np.exp(-abs(total_spin)) + sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.1164858}
#standard deviation: 0.04575618295225247
#island_id: 3
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
  
  return(priorities)




#score: {'data3D.txt': -0.1164858}
#standard deviation: 0.04575618295225247
#island_id: 3
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)

        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return(priorities)




#score: {'data3D.txt': -0.0272594}
#standard deviation: 0.047703154944301114
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2,i,j,k-1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2,i,j,k+1] < 0
        
        for d in [0,1]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0 and J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif h[i][j][k] > 0 and J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          elif h[i][j][k] < 0 and J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
          elif h[i][j][k] < 0 and J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49934100000000003}
#standard deviation: 0.039423370720931515
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2, i, j, k - 1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2, i, j, k + 1] < 0
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - same_spin_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - same_spin_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] -= 4
        
        # Add a new term based on the interaction energy with nearest neighbors
        for d in [0, 1]:
          if d == 0:
            site_nbr = (i - 1) % N
          else:
            site_nbr = (i + 1) % N
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 3
          
  return(priorities)




#score: {'data3D.txt': -0.44208340000000024}
#standard deviation: 0.04214559199299495
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3

        # Add a new term based on the distance to the boundary and the magnetism at each site
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] -= 5
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.07362780000000001}
#standard deviation: 0.047407972189917595
#island_id: 3
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        num_positive_neighbors = sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add a new term based on the distance from the edge
        if k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of positive spins
        num_positive_spins = sum(1 for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_spins) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_spins * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.15318300000000018}
#standard deviation: 0.04535582334166144
#island_id: 1
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) - total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) - total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + sum(site_neighbors)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - sum(site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + sum(site_neighbors)
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val < 0]) - sum(site_neighbors)

        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += (total_spin > 0) * len([val for val in interacting_spins + site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= (total_spin > 0) * len([val for val in interacting_spins + site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins.extend([val if val < 0 else -val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5157002000000002}
#standard deviation: 0.04253853782113344
#island_id: 3
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5157002000000002}
#standard deviation: 0.04253853782113344
#island_id: 3
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4450498000000001}
#standard deviation: 0.04344871689658972
#island_id: 3
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        neighbor_site_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_site_energy) * (site_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= neighbor_site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5319034}
#standard deviation: 0.041215941435808555
#island_id: 3
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        site_energy = h[i][j][k]
        neighbor_energy = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.07179179999999999}
#standard deviation: 0.04430050443008522
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, site_nbr, j, k], J[1, i, site_nbr, k], J[2, i, j, site_nbr]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, site_nbr, j, k] for d in [0, 1, 2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2908082}
#standard deviation: 0.04100890894378927
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) - h[i][(j+1)%N][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]) - h[i][(j+1)%N][k]

        site_nbr_neighbors = [J[0, site_nbr, j, k], J[1, i, site_nbr, k], J[2, i, j, site_nbr]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d, site_nbr, j, k] for d in [0, 1, 2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors) - h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, site_nbr, j, k] for d in [0, 1, 2]) - h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3457242}
#standard deviation: 0.03944923084624084
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
        
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,site_nbr,k], J[2,i,j,site_nbr]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,site_nbr,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.48524700000000004}
#standard deviation: 0.044323936546746386
#island_id: 3
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetization of neighboring spins
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
        # Add a new term based on the correlation with neighboring spins
        neighbor_correlation = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_correlation)) * neighbor_correlation
        priorities[i*N*N+j*N+k][1] -= neighbor_correlation
        
  return(priorities)




#score: {'data3D.txt': -0.502077}
#standard deviation: 0.0434896377428003
#island_id: 3
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        site_energy = np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (site_energy)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetization of neighboring sites
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
  return(priorities)




#score: {'data3D.txt': 0.25314100000000017}
#standard deviation: 0.04521478695073107
#island_id: 2
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_up = J[0,i,j,k]
        site_down = J[1,(i+1)%N,j,k]
        site_left = J[2,i,(j+1)%N,k]
        site_right = J[2,i,j,(k+1)%N]

        interacting_spins = [site_up, site_down, site_left, site_right]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.where(np.array(interacting_spins) < 0, 1, -1))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.where(np.array(interacting_spins) > 0, 1, -1))
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.43685339999999995}
#standard deviation: 0.044885448738316076
#island_id: 2
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += len([val for val in site_neighbors if val < 0]) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy

  return(priorities)




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 2
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5110014}
#standard deviation: 0.03963439160678514
#island_id: 2
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 2
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5448202}
#standard deviation: 0.03934815309464982
#island_id: 2
#version_generated: 2
#generate time15:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  # Apply the Metropolis-Hastings algorithm to improve the priority function
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47843420000000014}
#standard deviation: 0.04496037266704981
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
  
  return(priorities)




#score: {'data3D.txt': -0.47848820000000003}
#standard deviation: 0.03996681849684811
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(spin_energy))
        priorities[i*N*N+j*N+k][1] -= abs(spin_energy)
        
  return(priorities)




#score: {'data3D.txt': -0.5143422000000001}
#standard deviation: 0.03978519296371453
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_neighbors if val > 0])
        
  # Apply the Metropolis-Hastings algorithm to improve the priority function
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5453013999999999}
#standard deviation: 0.039864656000522566
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  # Add a new term based on the number of nearest neighbors with the same spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.5337206}
#standard deviation: 0.0383979246267295
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (k + 1) / N
            priorities[i*N*N+j*N+k][1] -= (k + 1) / N
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - k) / N
            priorities[i*N*N+j*N+k][1] -= (N - k) / N
  
  return(priorities)




#score: {'data3D.txt': -0.5325529999999999}
#standard deviation: 0.04034475518577353
#island_id: 2
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2664162000000003}
#standard deviation: 0.04587554487480231
#island_id: 1
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] -= 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
            priorities[i*N*N+j*N+k][1] -= 5

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] += 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
            priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.33421060000000036}
#standard deviation: 0.04579334894545276
#island_id: 1
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add a new term based on the number of nearest neighbors with the same spin
          if k > 0 and J[2, i, j, k-1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2

          if k < N-1 and J[2, i, j, k+1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add a new term based on the number of nearest neighbors with the same spin
          if k > 0 and J[2, i, j, k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] = -2 + 2

          if k < N-1 and J[2, i, j, k+1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] = -2 + 2

        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3

        # Add a new term based on the distance to the boundary and the magnetism at each site
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] -= 5
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.1715254}
#standard deviation: 0.05428096530866046
#island_id: 1
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2, i, j, k - 1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2, i, j, k + 1] < 0

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - same_spin_neighbors) + site_nbr_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - same_spin_neighbors) + site_nbr_energy
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and nearest neighbors with the same spin
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 3
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] = -3

        # Add a new term based on the distance to the boundary and the magnetism at each site
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] -= 5
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.09544380000000001}
#standard deviation: 0.04534539669646744
#island_id: 1
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy and nearest neighbors with the same spin
        for neighbor_site in [(i, j, k-1), (i, j, k+1)]:
          if 0 <= neighbor_site[2] < N:
            neighbor_spin = J[2, neighbor_site[0], neighbor_site[1], neighbor_site[2]]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] -= 3

        # Add a new term based on the distance to the boundary and the magnetism at each site
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] -= 5
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.33093059999999996}
#standard deviation: 0.04306290681828155
#island_id: 3
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i) - h[i][j][k]
        
        # Improved term
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2547426}
#standard deviation: 0.04553239050653941
#island_id: 3
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i) - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.15275780000000022}
#standard deviation: 0.046765591829463694
#island_id: 1
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0:
          interacting_spins.append(J[1,i-1,j,k])
        if i < N-1:
          interacting_spins.append(J[1,i+1,j,k])
        if j > 0:
          interacting_spins.append(J[0,i,j-1,k])
        if j < N-1:
          interacting_spins.append(J[0,i,j+1,k])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and distance to boundary
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.16021380000000013}
#standard deviation: 0.046454721283848005
#island_id: 1
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0 and j > 0 and k > 0:
          interacting_spins.append(J[3,i-1,j-1,k-1])
        if i > 0 and j > 0 and k < N-1:
          interacting_spins.append(J[4,i-1,j-1,k+1])
        if i > 0 and j < N-1 and k > 0:
          interacting_spins.append(J[5,i-1,j,k-1])
        if i > 0 and j < N-1 and k < N-1:
          interacting_spins.append(J[5,i-1,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.1994038}
#standard deviation: 0.04433234333486106
#island_id: 1
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its gradient
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k]**2)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin and its gradient
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (i + j + k)
          priorities[i*N*N+j*N+k][1] -= i + j + k
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - 1 - i - j - k)
          priorities[i*N*N+j*N+k][1] -= N - 1 - i - j - k
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] -= 4
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] -= 4
        
  return(priorities)




#score: {'data3D.txt': -0.3315582}
#standard deviation: 0.04099067372903256
#island_id: 1
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin and its gradient
        neighbor_count = 0
        for d in range(6):
          if J[d,i,j,k] < 0:
            neighbor_count += 1
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= 2 * neighbor_count
        
        # Add a new term based on the distance to the boundary and corners
        distance_to_boundary = min(i, j, k, N-1-i, N-1-j, N-1-k)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * distance_to_boundary
        priorities[i*N*N+j*N+k][1] -= distance_to_boundary
        
  return priorities




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.441421}
#standard deviation: 0.042031265493677444
#island_id: 0
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13491460000000005}
#standard deviation: 0.04613547297730891
#island_id: 1
#version_generated: 3
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.19891980000000017}
#standard deviation: 0.045836017365822705
#island_id: 1
#version_generated: 3
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0:
          interacting_spins.append(J[0,i-1,j,k])
        if i < N-1:
          interacting_spins.append(J[0,i+1,j,k])
        if j > 0:
          interacting_spins.append(J[1,i,j-1,k])
        if j < N-1:
          interacting_spins.append(J[1,i,j+1,k])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.2445298000000003}
#standard deviation: 0.04643126093441788
#island_id: 1
#version_generated: 3
#generate time15:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.24663940000000006}
#standard deviation: 0.04565445791639631
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the number of corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return(priorities)




#score: {'data3D.txt': -0.13918420000000004}
#standard deviation: 0.044916945915322436
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 16
          priorities[i*N*N+j*N+k][1] -= 16
        
        if (k > 1 and (i+j+k) % 4 == 3) or (k < N-2 and (i+j+k) % 4 == 0):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.153529}
#standard deviation: 0.04320912356204416
#island_id: 1
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or (i == N-1 or j == N-1 or k == N-1):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the distance to the center of the grid
        if (i <= N/2 and j <= N/2) or (i >= N/2 and j >= N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        
        # Add a new term based on the distance to the edges of the grid
        if (i == 0 or j == 0) or (i == N-1 or j == N-1):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.43020460000000005}
#standard deviation: 0.0430078934480637
#island_id: 1
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i-1//N-1,j%N,((i//N)-1)%2]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i-1//N-1,j%N,((i//N)-1)%2]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
  
  return(priorities)




#score: {'data3D.txt': -0.2491858}
#standard deviation: 0.0408877556043371
#island_id: 1
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        neighbor_energy = 0
        for d in range(3):
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            neighbor_energy += np.exp(-abs(J[d,i,j,k-1]))
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            neighbor_energy += np.exp(-abs(J[d,i,j,k+1]))
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (1 + neighbor_energy)
          priorities[i*N*N+j*N+k][1] += h[i][j][k] * (1 + neighbor_energy)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in range(3):
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i*N*N+j*N+k][1] -= 2
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 16
          priorities[i*N*N+j*N+k][1] -= 16
        
  return(priorities)




#score: {'data3D.txt': -0.40941700000000003}
#standard deviation: 0.0408545448022616
#island_id: 1
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2

        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8

  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4877522}
#standard deviation: 0.04050136386789956
#island_id: 3
#version_generated: 3
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetization of neighboring spins
        site_magnetization = np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_magnetization)) * site_magnetization
        priorities[i*N*N+j*N+k][1] -= site_magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4544698}
#standard deviation: 0.04182104025439826
#island_id: 3
#version_generated: 3
#generate time15:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[0,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2540318}
#standard deviation: 0.04535110041399216
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return(priorities)




#score: {'data3D.txt': -0.1259574}
#standard deviation: 0.046433278424423144
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add a new term based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the distance from the edge
        if k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of positive neighbors
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
  return(priorities)




#score: {'data3D.txt': -0.24875460000000002}
#standard deviation: 0.04450038358081872
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add a new term based on the distance from the edge
        if k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27631219999999995}
#standard deviation: 0.0456368510215155
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add new terms based on the local energy and the number of neighbors with positive spin
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5143422000000001}
#standard deviation: 0.03978519296371453
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_neighbors if val > 0])
        
  # Apply the Metropolis-Hastings algorithm to improve the priority function
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if J[2,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        elif k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        site_opposite_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.08293940000000001}
#standard deviation: 0.04934755645054779
#island_id: 1
#version_generated: 3
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0:
          interacting_spins.append(J[1,i-1,j,k])
        if i < N-1:
          interacting_spins.append(J[1,i+1,j,k])
        if j > 0:
          interacting_spins.append(J[0,i,j-1,k])
        if j < N-1:
          interacting_spins.append(J[0,i,j+1,k])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the distance to the boundary
        boundary_penalty = 0
        if i == 0:
          boundary_penalty += 3
        elif i == N-1:
          boundary_penalty -= 3
        if j == 0:
          boundary_penalty += 3
        elif j == N-1:
          boundary_penalty -= 3
        if k == 0:
          boundary_penalty += 3
        elif k == N-1:
          boundary_penalty -= 3
        
        priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * boundary_penalty
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + boundary_penalty
        
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5108738}
#standard deviation: 0.04296904506223055
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44227939999999993}
#standard deviation: 0.039257147828643896
#island_id: 0
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.441421}
#standard deviation: 0.042031265493677444
#island_id: 0
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.441421}
#standard deviation: 0.042031265493677444
#island_id: 0
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.441421}
#standard deviation: 0.042031265493677444
#island_id: 0
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.35773659999999996}
#standard deviation: 0.03861922863600463
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(spin_energy))
        priorities[i*N*N+j*N+k][1] -= abs(spin_energy)
        
        # Add a new term based on the number of nearest neighbors with the same spin in x, y and z directions
        for d in [0, 1, 2]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42446660000000014}
#standard deviation: 0.04804155206110644
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_energy = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5135998}
#standard deviation: 0.041994782056346
#island_id: 3
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2811706000000001}
#standard deviation: 0.04492216263315913
#island_id: 3
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif all(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] - total_spin
        elif any(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k])) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i][j][k])) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44670980000000016}
#standard deviation: 0.043853384635168136
#island_id: 3
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4903974000000001}
#standard deviation: 0.04233139488890013
#island_id: 3
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)
        
        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) / 3)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4595754000000001}
#standard deviation: 0.04233206627179921
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.388591}
#standard deviation: 0.03966598491150825
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.38543900000000003}
#standard deviation: 0.04028149300857653
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the distance from the boundary
        if i == 0 or i == N - 1 or j == 0 or j == N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.44227939999999993}
#standard deviation: 0.039257147828643896
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return (priorities)




#score: {'data3D.txt': -0.44970659999999996}
#standard deviation: 0.039682043753314925
#island_id: 2
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (k + 1) / N
            priorities[i*N*N+j*N+k][1] -= (k + 1) / N
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - k) / N
            priorities[i*N*N+j*N+k][1] -= (N - k) / N
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0,1]:
          neighbor_spins = []
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            neighbor_spins.append(neighbor_spin)
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            neighbor_spins.append(neighbor_spin)
          for neighbor_spin in neighbor_spins:
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0])
              priorities[i*N*N+j*N+k][1] -= len([val for val in neighbor_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0028898000000000005}
#standard deviation: 0.04700872659368683
#island_id: 2
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (k + 1) / N
            priorities[i*N*N+j*N+k][1] -= (k + 1) / N
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - k) / N
            priorities[i*N*N+j*N+k][1] -= (N - k) / N
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0,1]:
          if i > 0:
            neighbor_spin = J[d,i-1,j,k]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          if i < N-1:
            neighbor_spin = J[d,i+1,j,k]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          
          if j > 0:
            neighbor_spin = J[d,i,j-1,k]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          if j < N-1:
            neighbor_spin = J[d,i,j+1,k]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.5273658}
#standard deviation: 0.03873348306517244
#island_id: 2
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (k + 1) / N
            priorities[i*N*N+j*N+k][1] -= (k + 1) / N
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - k) / N
            priorities[i*N*N+j*N+k][1] -= (N - k) / N
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) / N
            priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val > 0]) + 1) / N
        
  return(priorities)




#score: {'data3D.txt': -0.27547699999999997}
#standard deviation: 0.04401582477927683
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in range(3):
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0 and h[i][j][k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 2
              priorities[i*N*N+j*N+k][1] -= 2
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin > 0 and h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 2
              priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 16
          priorities[i*N*N+j*N+k][1] -= 16
  
  return(priorities)




#score: {'data3D.txt': -0.2445298000000003}
#standard deviation: 0.04643126093441788
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.25069900000000034}
#standard deviation: 0.04666401781887195
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.548019}
#standard deviation: 0.03865090217575781
#island_id: 2
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Apply the Metropolis-Hastings algorithm to improve the priority function
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5448202}
#standard deviation: 0.03934815309464982
#island_id: 2
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  # Apply the Metropolis-Hastings algorithm to improve the priority function
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.5403274}
#standard deviation: 0.038808072990551855
#island_id: 2
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the probability of flipping the spin
        flip_prob = np.exp(-2 * total_spin)
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= flip_prob
  
  return(priorities)




#score: {'data3D.txt': -0.2649974000000003}
#standard deviation: 0.04644143702815408
#island_id: 1
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] -= 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          dist_to_boundary = max(i, j, k) / N
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 + dist_to_boundary)
            priorities[i*N*N+j*N+k][1] -= (2 - 2*total_spin) * (1 + dist_to_boundary)

          elif i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 - dist_to_boundary)
            priorities[i*N*N+j*N+k][1] -= (-2 + 2*total_spin) * (1 - dist_to_boundary)

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] += 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
            priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.18042740000000024}
#standard deviation: 0.044340995131367994
#island_id: 1
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] -= 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 5
            priorities[i*N*N+j*N+k][1] -= 5

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] += 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 5
            priorities[i*N*N+j*N+k][1] = -5

  return(priorities)




#score: {'data3D.txt': -0.27079420000000026}
#standard deviation: 0.046365320729614294
#island_id: 1
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] -= 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 + max(i, j, k) / N)
            priorities[i*N*N+j*N+k][1] -= (2 - 2*total_spin) * (1 + max(i, j, k) / N)

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add a new term based on the local energy and nearest neighbors with the same spin
          if k > 0:
            neighbor_spin = J[2, i, j, k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * 3
              priorities[i*N*N+j*N+k][1] += 3

          # Add a new term based on the distance to the boundary and the magnetism at each site
          if i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (1 - max(i, j, k) / N)
            priorities[i*N*N+j*N+k][1] = (-2 + 2*total_spin) * (1 - max(i, j, k) / N)

  return(priorities)




#score: {'data3D.txt': -0.31074659999999993}
#standard deviation: 0.04595009454223134
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= (-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] += 2
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if site_nbr < i:
            site_nbr_spin = J[2,i-1,j,k]
            if site_nbr_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          elif site_nbr > i:
            site_nbr_spin = J[2,i+1,j,k]
            if site_nbr_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          
          if j > 0:
            site_nbr = (i + ((k-1)%2 - 1)) % N
            site_nbr_spin = J[1,i,j-1,k]
            if site_nbr_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          
          if k > 0:
            site_nbr = (i + ((k-1)%2 - 1)) % N
            site_nbr_spin = J[2,i,j,k-1]
            if site_nbr_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] += (-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] += 2
          
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if site_nbr < i:
            site_nbr_spin = J[2,i-1,j,k]
            if site_nbr_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1
          elif site_nbr > i:
            site_nbr_spin = J[2,i+1,j,k]
            if site_nbr_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1
          
          if j > 0:
            site_nbr = (i + ((k-1)%2 - 1)) % N
            site_nbr_spin = J[1,i,j-1,k]
            if site_nbr_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1
          
          if k > 0:
            site_nbr = (i + ((k-1)%2 - 1)) % N
            site_nbr_spin = J[2,i,j,k-1]
            if site_nbr_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4043822}
#standard deviation: 0.04024074307415309
#island_id: 0
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        
        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[i][j][int((k+1)%N)] > 0 or val > 0 and h[i][j][int((k-1)%N)] < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i*N*N+j*N+k][1] -= neighbor_opposite_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18569259999999996}
#standard deviation: 0.04371648322132054
#island_id: 0
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and spin correlation
        correlation_factor = np.exp(abs(h[i][j][k])) * (1 + np.tanh(total_spin))
        priorities[i*N*N+j*N+k][0] += correlation_factor
        priorities[i*N*N+j*N+k][1] -= correlation_factor
        
  return(priorities)




#score: {'data3D.txt': -0.37777340000000004}
#standard deviation: 0.042540203718835205
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return(priorities)




#score: {'data3D.txt': -0.06862180000000001}
#standard deviation: 0.0469954862168698
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)
        
        # Add a new term based on the distance from the edge
        if k == 0 or k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the number of positive neighbors
        num_positive_interacting_neighbors = sum(1 for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_interacting_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_interacting_neighbors * (N - i)
  
  return(priorities)




#score: {'data3D.txt': -0.4610558}
#standard deviation: 0.04167151312779511
#island_id: 3
#version_generated: 3
#generate time16:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2*h[i][j][k]*total_spin

  return priorities




#score: {'data3D.txt': -0.377587}
#standard deviation: 0.042586352168271
#island_id: 3
#version_generated: 3
#generate time16:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

        # Add a new term based on the distance from the edge
        if k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the number of positive neighbors
        num_positive_neighbors = sum(1 for val in site_neighbors if val > 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-num_positive_neighbors) * (N - i)
        priorities[i*N*N+j*N+k][1] -= num_positive_neighbors * (N - i)

  return priorities




#score: {'data3D.txt': -0.537095}
#standard deviation: 0.03879958524262856
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the probability of flipping the spin
        flip_prob = np.exp(-2 * total_spin)
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= flip_prob
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the probability of flipping the spin in both directions
        flip_prob = np.exp(-2 * total_spin)
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += flip_prob
            priorities[i*N*N+j*N+k][1] -= flip_prob
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += flip_prob
            priorities[i*N*N+j*N+k][1] -= flip_prob
  
  return(priorities)




#score: {'data3D.txt': -0.5363002000000001}
#standard deviation: 0.041673079079424885
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the probability of flipping the spin
        flip_prob = np.exp(-2 * total_spin)
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= flip_prob
        
  return(priorities)




#score: {'data3D.txt': -0.48727780000000004}
#standard deviation: 0.039168231861548206
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the probability of flipping the spin
        flip_prob = np.exp(-2 * total_spin)
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= flip_prob
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5403274}
#standard deviation: 0.038808072990551855
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the probability of flipping the spin
        flip_prob = np.exp(-2 * total_spin)
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= flip_prob
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2873222000000001}
#standard deviation: 0.04313100494029788
#island_id: 3
#version_generated: 3
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2*h[i][j][k]*total_spin

        # Add a new term based on the interaction with the next neighboring site
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + total_spin)
          priorities[i*N*N+j*N+k][1] -= neighbor_spin - 2*neighbor_spin*total_spin

        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + total_spin)
          priorities[i*N*N+j*N+k][1] -= neighbor_spin - 2*neighbor_spin*total_spin

  return priorities




#score: {'data3D.txt': -0.06051620000000003}
#standard deviation: 0.04586027537597218
#island_id: 3
#version_generated: 3
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        local_energy = h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-local_energy) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) + total_spin)
        priorities[i*N*N+j*N+k][1] -= local_energy - 2*local_energy*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4610558}
#standard deviation: 0.04167151312779511
#island_id: 3
#version_generated: 3
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

        # Add a new term based on the local energy and the interaction with neighboring sites
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2*h[i][j][k]*total_spin

  return priorities




#score: {'data3D.txt': -0.46097620000000006}
#standard deviation: 0.04424921008967279
#island_id: 0
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k])) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k]) * (h[i][j][k] > 0)

  return priorities




#score: {'data3D.txt': -0.388591}
#standard deviation: 0.03966598491150825
#island_id: 0
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.30683619999999995}
#standard deviation: 0.04149658792671995
#island_id: 0
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin and same direction
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 2

        # Add a new term based on the number of nearest neighbors with different spin and opposite direction
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.3633302}
#standard deviation: 0.04021557071533363
#island_id: 0
#version_generated: 3
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with same spin and different energy
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0 and h[i][j][k] != h[i][j][k - 1]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0 and h[i][j][k] != h[i][j][k + 1]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.1653774}
#standard deviation: 0.04469221508540386
#island_id: 3
#version_generated: 3
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = h[i][j][k] - total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] - total_spin
        else:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.17701940000000013}
#standard deviation: 0.04553730408840647
#island_id: 3
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.4224642}
#standard deviation: 0.043075886506954215
#island_id: 3
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.0627794}
#standard deviation: 0.04492479599998202
#island_id: 3
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 2
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 2
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 2
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5389226000000001}
#standard deviation: 0.04301157947855438
#island_id: 2
#version_generated: 2
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36124860000000003}
#standard deviation: 0.0400491337988726
#island_id: 0
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the distance from the boundary
        if i == 0 or i == N - 1 or j == 0 or j == N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of sites with the same spin in the previous layer
        if k > 0:
          site_spin = J[2, i, j, k - 1]
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N - 1:
          site_spin = J[2, i, j, k + 1]
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.441421}
#standard deviation: 0.042031265493677444
#island_id: 0
#version_generated: 3
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

  return priorities




#score: {'data3D.txt': -0.38543900000000003}
#standard deviation: 0.04028149300857653
#island_id: 0
#version_generated: 3
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        local_energy = abs(h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        boundary_term = 2 if (i == 0 or i == N - 1 or j == 0 or j == N - 1) else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * boundary_term
        priorities[i * N * N + j * N + k][1] -= boundary_term

  return(priorities)




#score: {'data3D.txt': -0.138407}
#standard deviation: 0.05089165502319609
#island_id: 1
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2

        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8

        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0,1]:
          for l in [(i-1)%N, (i+1)%N]:
            for m in [(j-1)%N, (j+1)%N]:
              if k > 0:
                neighbor_spin = J[d,l,m,k-1]
                if neighbor_spin > 0 and h[l][m][k-1] < 0:
                  priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
                  priorities[i*N*N+j*N+k][1] -= 3
              if k < N-1:
                neighbor_spin = J[d,l,m,k+1]
                if neighbor_spin > 0 and h[l][m][k+1] < 0:
                  priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
                  priorities[i*N*N+j*N+k][1] -= 3

  return(priorities)




#score: {'data3D.txt': -0.4133014}
#standard deviation: 0.04034792383803658
#island_id: 1
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3

        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8

  return(priorities)




#score: {'data3D.txt': -0.38648140000000003}
#standard deviation: 0.041126560445045736
#island_id: 1
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors with the same spin
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin and its corners
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 6
          priorities[i*N*N+j*N+k][1] -= 6
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 12
          priorities[i*N*N+j*N+k][1] -= 12
        
  return(priorities)




#score: {'data3D.txt': -0.38787900000000003}
#standard deviation: 0.04107623594001768
#island_id: 1
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2

        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 6
          priorities[i*N*N+j*N+k][1] -= 6
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 12
          priorities[i*N*N+j*N+k][1] -= 12

  return(priorities)




#score: {'data3D.txt': -0.17701940000000013}
#standard deviation: 0.04553730408840647
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.09833940000000001}
#standard deviation: 0.04638822746818422
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin

  # Add a new term based on the local energy and the interaction with neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i][j][k])) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] = h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.17701940000000013}
#standard deviation: 0.04553730408840647
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k]) * (np.sum([J[0,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[0,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[0,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the site's own energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4721114}
#standard deviation: 0.04261623200190276
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        neighbor_sites = [J[2,i,(j+1)%N,k], J[2,i,(j-1)%N,k], J[2,i,j,(k+1)%N], J[2,i,j,(k-1)%N]]
        total_neighbor_spin = sum(neighbor_sites)
        
        if k > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + neighbor_sites if val < 0]) + total_spin + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*total_neighbor_spin
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return(priorities)




#score: {'data3D.txt': -0.4618014000000002}
#standard deviation: 0.04253684753293314
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + abs(k-1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(k-1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and the second nearest neighbors with same spin
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1.5 if k > 0 else 1) + total_spin + abs(k-1)
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
        if i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1.5 if k < N-1 else 1) + total_spin + abs(k-1)
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.450471}
#standard deviation: 0.040654590380423225
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and second nearest neighbors with same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
        
        # Add a new term based on the distance to the boundary and the magnetism
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (4 + h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 + h[i][j][k]
        if i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (4 - h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 - h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.47514660000000003}
#standard deviation: 0.04117863703961073
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the distance to the boundary and the local energy
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (4 if i == 0 else 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 2
        elif i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (4 if i == N-1 else 2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 2
        
  return(priorities)




#score: {'data3D.txt': -0.48335500000000003}
#standard deviation: 0.04079396150167326
#island_id: 3
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = np.sum([val * h[i][j][k] for val in interacting_spins]) / 3
        boltzmann_factor = np.exp(-site_energy)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += boltzmann_factor * (1 + np.sum([val < 0 for val in interacting_spins])) / 2
          priorities[i*N*N+j*N+k][1] -= boltzmann_factor * (2 - np.sum([val for val in interacting_spins]))
        else:
          priorities[i*N*N+j*N+k][0] -= boltzmann_factor * (1 + np.sum([val > 0 for val in interacting_spins])) / 2
          priorities[i*N*N+j*N+k][1] = -boltzmann_factor * (2 - np.sum([val for val in interacting_spins]))
        
  return(priorities)




#score: {'data3D.txt': 0.3707138}
#standard deviation: 0.044562214145618936
#island_id: 3
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local magnetization
        if i > 0:
          neighbor_magnetization = J[2,i-1,j,k]
          if neighbor_magnetization < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if i < N-1:
          neighbor_magnetization = J[2,i+1,j,k]
          if neighbor_magnetization < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local magnetization
        if j > 0:
          neighbor_magnetization = J[2,i,j-1,k]
          if neighbor_magnetization < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if j < N-1:
          neighbor_magnetization = J[2,i,j+1,k]
          if neighbor_magnetization < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.3530554}
#standard deviation: 0.044458210612214256
#island_id: 3
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.1869054}
#standard deviation: 0.048634840709516056
#island_id: 1
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its gradient
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k]**2)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin and its gradient
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 4
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (i + j + k)
          priorities[i*N*N+j*N+k][1] -= i + j + k
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (N - 1 - i - j - k)
          priorities[i*N*N+j*N+k][1] -= N - 1 - i - j - k
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] -= 4
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] -= 4
        
        # Add a new term based on the number of nearest neighbors with different spin and its gradient
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (N - 1 - i - j - k)
            priorities[i*N*N+j*N+k][1] -= N - 1 - i - j - k
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (N - 1 - i - j - k)
            priorities[i*N*N+j*N+k][1] -= N - 1 - i - j - k
        
  return(priorities)




#score: {'data3D.txt': -0.3027890000000003}
#standard deviation: 0.04682398017042122
#island_id: 1
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.25069900000000034}
#standard deviation: 0.04666401781887195
#island_id: 1
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.25224740000000023}
#standard deviation: 0.04454432077425809
#island_id: 1
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the site's neighbors
        if i > 0:
          site_nbr_spin = J[2,i-1,j,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if j > 0:
          site_nbr_spin = J[1,i,j-1,k]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k > 0:
          site_nbr_spin = J[2,i,j,k-1]
          if site_nbr_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.4649826000000001}
#standard deviation: 0.0419786295302741
#island_id: 1
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2,i,j,k - 1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2,i,j,k + 1] < 0
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 1
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr_energy = h[i][j][k]
        same_spin_neighbors = 0
        if k > 0:
          same_spin_neighbors += J[2, i, j, k - 1] < 0
        if k < N - 1:
          same_spin_neighbors += J[2, i, j, k + 1] < 0

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4367674000000002}
#standard deviation: 0.044010960648911086
#island_id: 1
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add a new term based on the distance to the boundary
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] -= 3
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if k > 0 and J[2,i,j,k-1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          if k < N-1 and J[2,i,j,k+1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add a new term based on the distance to the boundary
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 3
            priorities[i*N*N+j*N+k][1] = -3
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if k > 0 and J[2,i,j,k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1
          if k < N-1 and J[2,i,j,k+1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.457677}
#standard deviation: 0.04108529409654993
#island_id: 1
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and distance to the boundary
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.exp((i/N)**2) + np.exp((j/N)**2) + np.exp((k/N)**2))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (np.exp((i/N)**2) + np.exp((j/N)**2) + np.exp((k/N)**2))
  
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 0
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N+j*N+k][0] += -2 + 2*total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k]) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] += abs(h[i][j][k]) * (h[i][j][k] > 0)
        
  return priorities




#score: {'data3D.txt': 0.17753859999999985}
#standard deviation: 0.049092499121963645
#island_id: 0
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -2 + 2*np.sum(J[:,i,j,k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N*N+j*N+k][0] = -2 + 2*np.sum(J[:,i,j,k])
          priorities[i*N*N+j*N+k][1] -= 2 + 2*np.sum(J[:,i,j,k])
  
  return priorities




#score: {'data3D.txt': -0.2773670000000001}
#standard deviation: 0.04549218384513982
#island_id: 1
#version_generated: 3
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%N - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.5036898000000001}
#standard deviation: 0.04175247700388565
#island_id: 1
#version_generated: 3
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin and its gradient
        neighbor_count = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
        priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= 2 * neighbor_count
        
        # Add a new term based on the distance to the boundary and corners
        distance_to_boundary = min(i, j, k, N-1-i, N-1-j, N-1-k)
        priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * distance_to_boundary
        priorities[i*N*N+j*N+k][1] -= distance_to_boundary
        
  return priorities




#score: {'data3D.txt': -0.3361182}
#standard deviation: 0.044948529550587084
#island_id: 1
#version_generated: 3
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (2 - 4*np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] += h[i][j][k] * (2 - 4*np.abs(total_spin))
        
        # Add a new term based on the distance to the boundary and corners
        if ((i+j+k) % 2 == 0 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 16
          priorities[i*N*N+j*N+k][1] -= 16
        
        if ((i+j+k) % 4 == 3 and k > 1 and (i+j+k) % 8 != 7):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return priorities




#score: {'data3D.txt': -0.4079634}
#standard deviation: 0.04059142644007476
#island_id: 0
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
  return(priorities)




#score: {'data3D.txt': -0.16021380000000013}
#standard deviation: 0.046454721283848005
#island_id: 1
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0 and j > 0 and k > 0:
          interacting_spins.append(J[3,i-1,j-1,k-1])
        if i > 0 and j > 0 and k < N-1:
          interacting_spins.append(J[4,i-1,j-1,k+1])
        if i > 0 and j < N-1 and k > 0:
          interacting_spins.append(J[5,i-1,j,k-1])
        if i > 0 and j < N-1 and k < N-1:
          interacting_spins.append(J[5,i-1,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.16025980000000015}
#standard deviation: 0.04659084699766683
#island_id: 1
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0 and j > 0 and k > 0:
          interacting_spins.append(J[3,i-1,j-1,k-1])
        if i > 0 and j > 0 and k < N-1:
          interacting_spins.append(J[4,i-1,j-1,k+1])
        if i > 0 and j < N-1 and k > 0:
          interacting_spins.append(J[5,i-1,j,k-1])
        if i > 0 and j < N-1 and k < N-1:
          interacting_spins.append(J[5,i-1,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N):
    for j in range(N):
      if i > 0 and j > 0:
        site_nbr_spin = J[3,i-1,j-1,k]
        if site_nbr_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.16021380000000013}
#standard deviation: 0.046454721283848005
#island_id: 1
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0 and j > 0 and k > 0:
          interacting_spins.append(J[3,i-1,j-1,k-1])
        if i > 0 and j > 0 and k < N-1:
          interacting_spins.append(J[4,i-1,j-1,k+1])
        if i > 0 and j < N-1 and k > 0:
          interacting_spins.append(J[5,i-1,j,k-1])
        if i > 0 and j < N-1 and k < N-1:
          interacting_spins.append(J[5,i-1,j,k+1])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': 0.43423219999999996}
#standard deviation: 0.045767458779792436
#island_id: 3
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.2596554}
#standard deviation: 0.042983125186984716
#island_id: 3
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
        # New term based on the site energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        neighbor_energy = 0
        
        if k > 0:
          neighbor_energy += J[2,i,j,k-1] * h[i][j][k-1]
        if k < N-1:
          neighbor_energy += J[2,i,j,k+1] * h[i][j][k+1]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_energy + neighbor_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - site_energy - neighbor_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_energy + neighbor_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.14060219999999998}
#standard deviation: 0.04763942269969274
#island_id: 3
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= site_energy
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]

        # New term based on the number of nearest neighbors with the same spin
        neighbor_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(neighbor_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([s for s in neighbor_spins if s < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2, i, j, k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2, i, j, k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy

  return(priorities)




#score: {'data3D.txt': 0.4325878}
#standard deviation: 0.04605758885525815
#island_id: 3
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.048369}
#standard deviation: 0.05232764889616196
#island_id: 3
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        neighbor_energy = 0
        if k > 0:
          neighbor_energy += J[2,i,j,k-1] * h[i][j][k-1]
        if k < N-1:
          neighbor_energy += J[2,i,j,k+1] * h[i][j][k+1]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_energy + J[2,i,j,k-1] * h[i][j][k-1])
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_energy + J[2,i,j,k+1] * h[i][j][k+1])
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4858962}
#standard deviation: 0.044171140641373535
#island_id: 0
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0085042}
#standard deviation: 0.04610848926564391
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          for x in range(max(0, i-1), min(N, i+2)):
            for y in range(max(0, j-1), min(N, j+2)):
              if k > 0:
                for z in range(max(0, k-1), min(N, k+2)):
                  neighbor_spin = J[d,x,y,z]
                  if neighbor_spin < 0:
                    priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
                    priorities[i*N*N+j*N+k][1] -= 1
              else:
                for z in range(max(0, k-2), min(N, k+3)):
                  neighbor_spin = J[d,x,y,z]
                  if neighbor_spin < 0:
                    priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
                    priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2480186}
#standard deviation: 0.0422472675334157
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the second nearest neighbors with the same spin
        if k > 1:
          neighbor_spin = J[2,i,j,k-2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-2:
          neighbor_spin = J[2,i,j,k+2]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin (second order)
        if k > 2:
          neighbor_spin = J[2,i,j,k-3]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-3:
          neighbor_spin = J[2,i,j,k+3]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.46354740000000005}
#standard deviation: 0.041326089498523816
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.4977994}
#standard deviation: 0.0398544878230796
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.4017434000000002}
#standard deviation: 0.04420847018886766
#island_id: 1
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy and nearest neighbors' spin
        for d in range(3):
          if k+d >= N:
            break
          neighbor_spin = J[d,i,j,k+d]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= (h[i][j][k] + neighbor_spin)

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i*N*N+j*N+k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.37098180000000014}
#standard deviation: 0.04528188190391385
#island_id: 1
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= (h[i][j][k] + neighbor_spin)
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= (h[i][j][k] + neighbor_spin)

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i*N*N+j*N+k][1] -= 1.5

  return priorities




#score: {'data3D.txt': -0.24200100000000002}
#standard deviation: 0.04591024764690342
#island_id: 1
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the number of corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the number of neighbors that are not corners
        if i > 0 and j > 0 and k > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        
  return(priorities)




#score: {'data3D.txt': -0.24663940000000006}
#standard deviation: 0.04565445791639631
#island_id: 1
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the number of corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
  return(priorities)




#score: {'data3D.txt': -0.22339980000000006}
#standard deviation: 0.04640535701791336
#island_id: 1
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if k > 1 and (i+j+k) % 2 == 1:
          interacting_spins.append(J[2,i,j,k-2])
        if k < N-2 and (i+j+k) % 2 == 0:
          interacting_spins.append(J[2,i,j,k+2])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the number of corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 4
          priorities[i*N*N+j*N+k][1] -= 4
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 8
          priorities[i*N*N+j*N+k][1] -= 8
        
        # Add a new term based on the site's position in the lattice
        if i <= j and j <= k:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 16
          priorities[i*N*N+j*N+k][1] -= 16
        
  return(priorities)




#score: {'data3D.txt': -0.2833986}
#standard deviation: 0.04502625587410085
#island_id: 1
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) or ((i+j+k)%2==1 and i < N/2 and j < N/2):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 10
          priorities[i*N*N+j*N+k][1] -= 10
        
        # Add a new term based on the number of corners
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 5
          priorities[i*N*N+j*N+k][1] -= 5
        elif (i == N-1 or j == N-1 or k == N-1) and i < N/2 and j < N/2:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * 10
          priorities[i*N*N+j*N+k][1] -= 10
        
  return(priorities)




#score: {'data3D.txt': -0.5556778000000001}
#standard deviation: 0.03959490860148562
#island_id: 2
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.11884940000000001}
#standard deviation: 0.04430873592915961
#island_id: 2
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] = (abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.48335500000000003}
#standard deviation: 0.04079396150167326
#island_id: 3
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        neighbor_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the number of nearest neighbors with the same spin
        same_spin_neighbors = sum(1 for s in neighbor_spins if s < 0 or s > 0)
        
        boltzmann_factor = np.exp(-site_energy + same_spin_neighbors / 3)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += boltzmann_factor * (1 + sum(1 for s in interacting_spins if s < 0)) / 2
          priorities[i*N*N+j*N+k][1] -= boltzmann_factor * (2 - sum(s for s in interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= boltzmann_factor * (1 + sum(1 for s in interacting_spins if s > 0)) / 2
          priorities[i*N*N+j*N+k][1] = -boltzmann_factor * (2 - sum(s for s in interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.0009550000000000003}
#standard deviation: 0.046653861737266725
#island_id: 3
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # New term based on the number of nearest neighbors with the same spin
        neighbor_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(neighbor_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([s for s in neighbor_spins if s < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2, i, j, k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2, i, j, k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy

        # New term based on the number of nearest neighbors with the opposite spin
        opponent_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(opponent_spins) > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([s for s in opponent_spins if s > 0])
          priorities[i*N*N+j*N+k][1] += site_energy

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]

        # New term based on the number of nearest neighbors with the same spin
        neighbor_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(neighbor_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([s for s in neighbor_spins if s < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the local energy and the number of nearest neighbors with the same spin
        for d in [0,1,2]:
          if (d == 0 and k > 0):
            neighbor_energy = J[d, i, j, k-1] * h[i][j][k]
            priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
            priorities[i*N*N+j*N+k][1] -= neighbor_energy
          if (d == 2 and k < N-1):
            neighbor_energy = J[d, i, j, k+1] * h[i][j][k]
            priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
            priorities[i*N*N+j*N+k][1] -= neighbor_energy

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]

        # New term based on the number of nearest neighbors with the same spin
        neighbor_spins = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(neighbor_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * len([s for s in neighbor_spins if s < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_energy = J[2, i, j, k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy
        if k < N-1:
          neighbor_energy = J[2, i, j, k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-neighbor_energy) * 1
          priorities[i*N*N+j*N+k][1] -= neighbor_energy

        # New term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_opposite_spins = [J[2, i, j, k-1]]
          if sum(neighbor_opposite_spins) < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([s for s in neighbor_opposite_spins if s > 0])
        if k < N-1:
          neighbor_opposite_spins = [J[2, i, j, k+1]]
          if sum(neighbor_opposite_spins) < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([s for s in neighbor_opposite_spins if s > 0])

  return(priorities)




#score: {'data3D.txt': -0.24685020000000032}
#standard deviation: 0.04578522032228302
#island_id: 1
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0:
          interacting_spins.append(J[1,i-1,j,k])
        if i < N-1:
          interacting_spins.append(J[1,i+1,j,k])
        if j > 0:
          interacting_spins.append(J[0,i,j-1,k])
        if j < N-1:
          interacting_spins.append(J[0,i,j+1,k])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        # Add a new term based on the distance to the boundary and corners
        if i == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif i == N-1:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        if j == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif j == N-1:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.15489180000000022}
#standard deviation: 0.04668321853471545
#island_id: 1
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2,i,j,k]]
        
        if k > 0:
          interacting_spins.append(J[2,i,j,k-1])
        if k < N-1:
          interacting_spins.append(J[2,i,j,k+1])
        if i > 0:
          interacting_spins.append(J[1,i-1,j,k])
        if i < N-1:
          interacting_spins.append(J[1,i+1,j,k])
        if j > 0:
          interacting_spins.append(J[0,i,j-1,k])
        if j < N-1:
          interacting_spins.append(J[0,i,j+1,k])
        
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%N - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy and distance to boundary
        if (i == 0 or j == 0 or k == 0) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif (i == N-1 or j == N-1 or k == N-1) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        # Add a new term based on the local energy and distance to corners
        if (i == 0 and j == 0) or (i == N-1 and j == N-1):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif (i == 0 and k == 0) or (i == N-1 and k == N-1):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        elif (j == 0 and k == 0) or (j == N-1 and k == N-1):
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.3858662}
#standard deviation: 0.04158538562476005
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term based on the number of nearest neighbors with the same spin and its energy
        neighbor_energy = sum([J[d,i,site_nbr,k] * h[i][site_nbr][k] for d in [0,1,2]])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_energy)) * len([val for val in interacting_spins if val < 0]) + neighbor_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.2661629999999999}
#standard deviation: 0.04488879003715738
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= site_energy
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] = site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.12969940000000002}
#standard deviation: 0.045871772580095484
#island_id: 3
#version_generated: 3
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49606500000000003}
#standard deviation: 0.04194118232715907
#island_id: 0
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          if all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          if all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.548019}
#standard deviation: 0.03865090217575781
#island_id: 0
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4979002}
#standard deviation: 0.043594246408901256
#island_id: 0
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5019129999999999}
#standard deviation: 0.043582960787445356
#island_id: 2
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.27234339999999996}
#standard deviation: 0.045815209226194746
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= site_energy
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] = site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if i > 0:
          neighbor_spin = J[2, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if i < N-1:
          neighbor_spin = J[2, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if j > 0:
          neighbor_spin = J[2, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if j < N-1:
          neighbor_spin = J[2, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.002563}
#standard deviation: 0.04707734859781294
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # New term based on the number of nearest neighbors with the same spin and its energy
        neighbor_energy = sum([J[d,i,(i+(k-1)%N)%N,k] * h[(i+(k-1)%N)%N][j][k] for d in [0,1,2]])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_energy+neighbor_energy)) * len([val for val in interacting_spins if val < 0]) + site_energy + neighbor_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*(site_energy + neighbor_energy)

        # New term based on the number of nearest neighbors with opposite spin and its energy
        opposite_neighbor_energy = sum([J[d,i,(i+(k-1)%N)%N,k] * h[(i+(k-1)%N)%N][j][k] for d in [0,1,2]])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_energy+neighbor_energy)) * len([val for val in interacting_spins if val > 0]) + site_energy + neighbor_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*(site_energy + opposite_neighbor_energy)

  return(priorities)




#score: {'data3D.txt': 0.26693179999999994}
#standard deviation: 0.04489783456649107
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Improved priority calculation
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= site_energy
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] = site_energy

        # Additional term based on the number of nearest neighbors with the same spin and its energy
        for d in [0, 1, 2]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5459334000000001}
#standard deviation: 0.04057182673284505
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20477979999999998}
#standard deviation: 0.05426206660236965
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.32897180000000004}
#standard deviation: 0.05375551659839203
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(np.sum(J[:,i,j,k]))) * len([val for val in J[:,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(np.sum(J[:,i,j,k]))) * len([val for val in J[:,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*np.sum(J[:,i,j,k])
  
  return priorities




#score: {'data3D.txt': -0.17105540000000008}
#standard deviation: 0.045903897991782794
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = -np.sum(J[:,i,j,k])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = np.sum(J[:,i,j,k])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.22464980000000004}
#standard deviation: 0.05569383556516826
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4659698}
#standard deviation: 0.04166767389667919
#island_id: 0
#version_generated: 3
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[i][j][int((k+1)%N)] > 0 or val > 0 and h[i][j][int((k-1)%N)] < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i*N*N+j*N+k][1] -= neighbor_opposite_spin
        
        # Add a new term based on the sum of interactions with neighbors that have same spin
        same_spin_neighbors = [val for val in site_neighbors if h[i][j][int((k+1)%N)] == h[i][j][k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin_neighbors)
        priorities[i*N*N+j*N+k][1] -= len(same_spin_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.406087}
#standard deviation: 0.04693552759903739
#island_id: 0
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = np.sum(J[:, i, j, k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(np.abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= np.abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.43083939999999993}
#standard deviation: 0.04183924865051952
#island_id: 2
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
  return(priorities)




#score: {'data3D.txt': -0.2207062}
#standard deviation: 0.045647930528776436
#island_id: 2
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the magnetism of neighboring sites
        for d in [0,1,2]:
          for l in [i-1,i+1]:
            if 0 <= l < N:
              priorities[i*N*N+j*N+k][0] += J[d,l,j,k] * np.exp(h[l,j,k])
              priorities[i*N*N+j*N+k][1] -= J[d,l,j,k]
          for m in [j-1,j+1]:
            if 0 <= m < N:
              priorities[i*N*N+j*N+k][0] += J[d,i,m,k] * np.exp(h[i,m,k])
              priorities[i*N*N+j*N+k][1] -= J[d,i,m,k]
          for n in [k-1,k+1]:
            if 0 <= n < N:
              priorities[i*N*N+j*N+k][0] += J[d,i,j,n] * np.exp(h[i,j,n])
              priorities[i*N*N+j*N+k][1] -= J[d,i,j,n]
        
  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43083939999999993}
#standard deviation: 0.04183924865051952
#island_id: 2
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
  
  return(priorities)




#score: {'data3D.txt': -0.04082260000000001}
#standard deviation: 0.04576906651047189
#island_id: 2
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
        
  return(priorities)




#score: {'data3D.txt': -0.43083939999999993}
#standard deviation: 0.04183924865051952
#island_id: 2
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
  return(priorities)




#score: {'data3D.txt': -0.43083939999999993}
#standard deviation: 0.04183924865051952
#island_id: 2
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
  return(priorities)




#score: {'data3D.txt': 0.14736860000000002}
#standard deviation: 0.05434958706411669
#island_id: 3
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]
        neighbor_energy = 0

        if k > 0:
          neighbor_energy += J[2,i,j,k-1] * h[i][j][k-1]
        if k < N-1:
          neighbor_energy += J[2,i,j,k+1] * h[i][j][k+1]

        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]]))) * (1 + np.exp(neighbor_energy))
        priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.310427}
#standard deviation: 0.051558335417272734
#island_id: 3
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with the opposite spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.4582798}
#standard deviation: 0.0431404802008508
#island_id: 3
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + interacting_spins if val < 0]) + total_spin + total_neighbor_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2782710000000003}
#standard deviation: 0.04398518976883014
#island_id: 0
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2]) + \
                    sum(J[d, (i+1)%N, j, k] for d in [0, 1, 2]) + \
                    sum(J[d, i, j, (k+1)%N] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) - abs(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.0032333999999999996}
#standard deviation: 0.04699343746141582
#island_id: 1
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 1
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 1
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14239780000000002}
#standard deviation: 0.05347480710727248
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        for d, neighbor in [(0, (j+1)%N), (1, (i+1)%N), (2, (k+1)%N)]:
          if J[d, i, neighbor, k] > 0 and h[i][neighbor][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[d, i, neighbor, k] > 0 and h[i][neighbor][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.3899918}
#standard deviation: 0.045754580675163005
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, (i+1)%N, j, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, i, j, (k+1)%N] < 0 for d in range(3)]))]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([count * (val > 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])

  return priorities




#score: {'data3D.txt': -0.0736674}
#standard deviation: 0.04528428134838843
#island_id: 2
#version_generated: 3
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
        
        # Additional improvement: consider the total spin of all neighbors
        neighbor_spins = [J[0, i, j-1, k], J[1, (i+1)%N, j-1, k], J[2, i-1, j, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
        
  return(priorities)




#score: {'data3D.txt': -0.046750200000000006}
#standard deviation: 0.04594866048058419
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N ** 2 + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) ** (3 / 4) * np.exp(-abs(total_spin))
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N ** 2 + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) ** (3 / 4) * np.exp(-abs(total_spin))
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N ** 2 + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) ** (3 / 4) * np.exp(-abs(total_spin))
        priorities[i * N ** 2 + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spins = [J[0, i, j, k - 1], J[1, (i + 1) % N, j, k - 1], J[2, i, j - 1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N ** 2 + j * N + k][0] += (d + 1) ** (3 / 4) * np.exp(-abs(total_spin))
            priorities[i * N ** 2 + j * N + k][1] -= (d + 1)
        
        layer_neighbors = [J[0, i - 1, j, k], J[1, i, j - 1, k]]
        for d, spin in enumerate(layer_neighbors):
          if spin < 0:
            priorities[i * N ** 2 + j * N + k][0] += (d + 1) ** (3 / 4) * np.exp(-abs(total_spin))
            priorities[i * N ** 2 + j * N + k][1] -= (d + 1)
  
  return priorities




#score: {'data3D.txt': -0.4085258}
#standard deviation: 0.04372366652466373
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spin_sum = 0
        for d in [0,1]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i*N*N+j*N+k][1] += neighbor_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.48409260000000004}
#standard deviation: 0.04380295178683738
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5459334000000001}
#standard deviation: 0.04057182673284505
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.33387100000000003}
#standard deviation: 0.04091445464624941
#island_id: 0
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N*N*N)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with different spin and energy
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0 and h[i][j][k-1] != h[i][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0 and h[i][j][k+1] != h[i][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.4450718000000001}
#standard deviation: 0.047438794301288896
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.2550966}
#standard deviation: 0.05487544285415836
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.41350660000000017}
#standard deviation: 0.04581322468938418
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          if all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin

          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1

          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          if all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin

          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1

          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.49569540000000006}
#standard deviation: 0.040634786806872755
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        local_energy = h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
          priorities[i*N*N+j*N+k][1] -= local_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(local_energy)
          priorities[i*N*N+j*N+k][1] += local_energy
  
  return(priorities)




#score: {'data3D.txt': -0.33462300000000034}
#standard deviation: 0.04704790230180301
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          if all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin

          # New term: the number of nearest neighbors with the same spin as the current site
          num_same_neighbors = sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += np.exp(num_same_neighbors)
          priorities[i*N*N+j*N+k][1] -= num_same_neighbors

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          if all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin

          # New term: the number of nearest neighbors with the same spin as the current site
          num_same_neighbors = sum(val < 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] -= np.exp(num_same_neighbors)
          priorities[i*N*N+j*N+k][1] += num_same_neighbors

  return(priorities)




#score: {'data3D.txt': -0.4778098000000001}
#standard deviation: 0.041843408369299936
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_neighbor_spin
            
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_neighbor_spin
            
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2916014}
#standard deviation: 0.04237494304468149
#island_id: 0
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        
        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[int((i+1)%N), j, k] > 0 or val > 0 and h[i, int((j-1)%N), k] < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i*N*N+j*N+k][1] -= neighbor_opposite_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        if k > 0:
          neighbor_same_spin = len([val for val in site_neighbors if val < 0 and h[i, j, k-1] > 0 or val > 0 and h[i, j, k-1] < 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_same_spin
          priorities[i*N*N+j*N+k][1] -= neighbor_same_spin
        
        if k < N - 1:
          neighbor_same_spin = len([val for val in site_neighbors if val < 0 and h[i, j, k+1] > 0 or val > 0 and h[i, j, k+1] < 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_same_spin
          priorities[i*N*N+j*N+k][1] -= neighbor_same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43415699999999996}
#standard deviation: 0.039499753303027095
#island_id: 0
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2) - 1) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(abs(h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])

        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[i][j][int((k + 1) % N)] > 0 or val > 0 and h[i][j][int((k - 1) % N)] < 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_opposite_spin

        # Add a new term based on the number of neighbors with same spin
        neighbor_same_spin = len([val for val in site_neighbors if val < 0 and h[i][j][int((k - 1) % N)] < 0 or val > 0 and h[i][j][int((k + 1) % N)] > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_same_spin
        priorities[i * N * N + j * N + k][1] += neighbor_same_spin

  return (priorities)




#score: {'data3D.txt': -0.40264659999999997}
#standard deviation: 0.04010648561567069
#island_id: 0
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        
        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[int((i+1)%N),int((j+1)%N),int((k+1)%N)] > 0 or val > 0 and h[int((i-1)%N),int((j-1)%N),int((k-1)%N)] < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i*N*N+j*N+k][1] -= neighbor_opposite_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40428499999999995}
#standard deviation: 0.04133729375515528
#island_id: 0
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        
        # Add a new term based on the number of neighbors with opposite spin
        neighbor_opposite_spin = len([val for val in site_neighbors if val < 0 and h[int((i+1)%N),int((j+1)%N)][k] > 0 or val > 0 and h[i,int((j-1)%N)][int((k-1)%N)] < 0])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_opposite_spin
        priorities[i*N*N+j*N+k][1] -= neighbor_opposite_spin
        
  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.44049059999999995}
#standard deviation: 0.05568843534918179
#island_id: 3
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy

  # Add a new term based on the number of nearest neighbors with opposite spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1; priorities[i*N*N+j*N+k][1] += 1
          elif neighbor_spin < 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1; priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1; priorities[i*N*N+j*N+k][1] += 1
          elif neighbor_spin < 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1; priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.32343259999999996}
#standard deviation: 0.05307474067049221
#island_id: 3
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.34595820000000016}
#standard deviation: 0.0464078404233595
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': -0.4452854}
#standard deviation: 0.04114780609996115
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k] * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4032794000000001}
#standard deviation: 0.047795056393313315
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (4 - sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 4 - sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-4 + sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] -= -4 + sum(val for val in interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.4425118}
#standard deviation: 0.03990319411726335
#island_id: 2
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1
        
        # Additional improvements
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1
        
  return(priorities)




#score: {'data3D.txt': -0.48420700000000005}
#standard deviation: 0.0411112985808038
#island_id: 2
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N ** 2 + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N ** 2 + j * N + k][0] = -(np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin
        
        if total_neighbor_spin < 0:
          priorities[i * N ** 2 + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N ** 2 + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4650146}
#standard deviation: 0.04416337653350341
#island_id: 2
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0 and h[i][j][k-1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0 and h[i][j][k+1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0 and h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0 and h[i][j][k+1] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.42433220000000005}
#standard deviation: 0.0399693202739301
#island_id: 2
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4333642000000001}
#standard deviation: 0.045808383930891955
#island_id: 0
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0057094}
#standard deviation: 0.046506211108195
#island_id: 3
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0014341999999999996}
#standard deviation: 0.04688264999293449
#island_id: 3
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + 
                                      np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - 
                                      np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': 0.42768619999999996}
#standard deviation: 0.04493081848308574
#island_id: 3
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]]))) * (abs(total_spin) ** 2)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.41054579999999996}
#standard deviation: 0.042298954861320154
#island_id: 3
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the local energy and the number of nearest neighbors with different spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.21479700000000002}
#standard deviation: 0.05513472618051168
#island_id: 3
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] = site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.2550966}
#standard deviation: 0.05487544285415836
#island_id: 3
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.1576674}
#standard deviation: 0.05879374165028112
#island_id: 3
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(h[i][j][k]) * neighbor_spin_count
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.09487979999999999}
#standard deviation: 0.06010747966734257
#island_id: 3
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k]*h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(total_spin/3 + np.exp(total_spin)-np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(neighbor_spin_count)
          priorities[i*N*N+j*N+k][1] -= site_energy

        # Add a new term based on the energy difference between neighboring spins
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= site_energy

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(-1)
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(-1)
            priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.476415}
#standard deviation: 0.04074923968615857
#island_id: 3
#version_generated: 3
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.22464980000000004}
#standard deviation: 0.05569383556516826
#island_id: 0
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a term based on the number of nearest neighbors with different spin
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 1
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.49015780000000003}
#standard deviation: 0.044608871081434014
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Calculate the number of nearest neighbors with the same spin
        same_spin = [val for val in site_neighbors if val == J[2,i,j,k]]
        different_spin = [val for val in site_neighbors if val != J[2,i,j,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin) - len(different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3999426}
#standard deviation: 0.04859252314132289
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(val for val in site_neighbors if val == h[i][j][k])
        different_spin = len(site_neighbors) - same_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.49015780000000003}
#standard deviation: 0.044608871081434014
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Calculate the number of nearest neighbors with the same spin
        same_spin = [val for val in site_neighbors if val == J[2,i,j,k]]
        different_spin = [val for val in site_neighbors if val != J[2,i,j,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin) - len(different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.35164100000000004}
#standard deviation: 0.05177717218041171
#island_id: 3
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][0] += total_spin_term
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.365575}
#standard deviation: 0.049217042322756456
#island_id: 3
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * 1; priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * 1; priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * 1; priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * 1; priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.20127699999999998}
#standard deviation: 0.05758808306412013
#island_id: 3
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + neighbor_spin_count
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.3999426}
#standard deviation: 0.04859252314132289
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(val for val in site_neighbors if val == h[i][j][k])
        different_spin = len(site_neighbors) - same_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4613954}
#standard deviation: 0.046739047688629694
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(val == h[i][j][k] for val in site_neighbors)
        different_spin = len(site_neighbors) - same_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin == h[i][j][k]:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin == h[i][j][k]:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1

  return(priorities)




#score: {'data3D.txt': -0.3999426}
#standard deviation: 0.04859252314132289
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(val for val in site_neighbors if val == h[i][j][k])
        different_spin = len(site_neighbors) - same_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.0884242}
#standard deviation: 0.04939839688046567
#island_id: 3
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * (neighbor_spin_count)
        priorities[i * N * N + j * N + k][1] = site_energy

  return(priorities)




#score: {'data3D.txt': 0.3848438}
#standard deviation: 0.05059756636005333
#island_id: 3
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] = site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        neighbor_spin_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1

        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_opposite)
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.21479700000000002}
#standard deviation: 0.05513472618051168
#island_id: 3
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] = site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5366802}
#standard deviation: 0.04399387602792007
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        # Add a new term based on the product of the local energy and the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * 1
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * 1
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the product of the local energy and the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * 1
            priorities[i*N*N+j*N+k][1] += h[i][j][k]
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * 1
            priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0068866000000000005}
#standard deviation: 0.048286271138285264
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * (neighbor_spin_count)
        priorities[i * N * N + j * N + k][1] = site_energy

        # Calculate the interaction with the previous and next spins
        if k > 0:
          prev_spin = J[2, i, j, k - 1]
          if prev_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          else: priorities[i * N * N + j * N + k][0] -= np.exp(-site_energy) * (neighbor_spin_count)
        if k < N - 1:
          next_spin = J[2, i, j, k + 1]
          if next_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          else: priorities[i * N * N + j * N + k][0] -= np.exp(-site_energy) * (neighbor_spin_count)

  return(priorities)




#score: {'data3D.txt': 0.0884242}
#standard deviation: 0.04939839688046567
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * (neighbor_spin_count)
        priorities[i * N * N + j * N + k][1] = site_energy

  return(priorities)




#score: {'data3D.txt': 0.0884242}
#standard deviation: 0.04939839688046567
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the priority for assigning spins to -1 and 1
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * (neighbor_spin_count)
        priorities[i * N * N + j * N + k][1] = site_energy

  return(priorities)




#score: {'data3D.txt': 0.0884242}
#standard deviation: 0.04939839688046567
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the priority based on the local energy and interactions with neighboring spins
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy) * (total_spin/3 + np.exp(total_spin) - np.exp(-total_spin)) * neighbor_spin_count
        priorities[i*N*N+j*N+k][1] = site_energy

  return(priorities)




#score: {'data3D.txt': 0.288649}
#standard deviation: 0.05330687947160292
#island_id: 3
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_opposite += 1
          else: neighbor_spin_count_opposite -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_opposite += 1
          else: neighbor_spin_count_opposite -= 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][0] += total_spin_term
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count_same > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_same)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count_opposite > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_opposite)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.24679500000000001}
#standard deviation: 0.05262983882741804
#island_id: 3
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * neighbor_spin_count_same + np.exp(-site_energy) * neighbor_spin_count_opposite
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.23525780000000002}
#standard deviation: 0.05401449860139405
#island_id: 3
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        for d in [1, 2]:
          if J[d, i, j, k] < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        
        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        for d in [3, 4, 5]:
          if J[d, i, j, k] < 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 6 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count_same > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_same)
          priorities[i * N * N + j * N + k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count_opposite > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_opposite)
          priorities[i * N * N + j * N + k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': -0.4452854}
#standard deviation: 0.04114780609996115
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k] * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4326526}
#standard deviation: 0.04107102522752506
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1

        # Add a new term based on the local energy and total spin
        priorities[i * N * N + j * N + k][0] += h[i][j][k] * np.exp(-abs(total_spin)) * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] * (total_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.4452854}
#standard deviation: 0.04114780609996115
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k] * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4452854}
#standard deviation: 0.04114780609996115
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i * N * N + j * N + k][1] -= d + 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k] * np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.24679500000000001}
#standard deviation: 0.05262983882741804
#island_id: 3
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # Calculate the priority for each spin based on the interaction and magnetism
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * neighbor_spin_count_same + np.exp(-site_energy) * neighbor_spin_count_opposite
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.14736860000000002}
#standard deviation: 0.05434958706411669
#island_id: 3
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = np.sum([J[d, i, j, k] for d in [0, 1, 2]]) if k > 0 else 0
        neighbor_spin_count_same += np.sum([J[d, i, j, k] for d in [0, 1, 2]]) if k < N - 1 else 0

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = np.sum([-J[d, i, j, k] for d in [0, 1, 2]]) if k > 0 else 0
        neighbor_spin_count_opposite += np.sum([-J[d, i, j, k] for d in [0, 1, 2]]) if k < N - 1 else 0

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + neighbor_spin_count_same + neighbor_spin_count_opposite
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.24679500000000001}
#standard deviation: 0.05262983882741804
#island_id: 3
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * neighbor_spin_count_same + np.exp(-site_energy) * neighbor_spin_count_opposite
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': -0.49015780000000003}
#standard deviation: 0.044608871081434014
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Calculate the number of nearest neighbors with the same spin
        same_spin = [val for val in site_neighbors if val == J[2,i,j,k]]
        different_spin = [val for val in site_neighbors if val != J[2,i,j,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin) - len(different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.488627}
#standard deviation: 0.04476669242863493
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Calculate the number of nearest neighbors with the same spin
        same_spin = [val for val in site_neighbors if val == J[2,i,j,k]]
        different_spin = [val for val in site_neighbors if val != J[2,i,j,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin) - len(different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate the number of nearest neighbors with the opposite spin
        opposite_spin = [val for val in site_neighbors if val == -J[2,i,j,k]]
        same_opposite_spin = [val for val in opposite_spin if val < 0]
        different_opposite_spin = [val for val in opposite_spin if val > 0]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_opposite_spin) - len(different_opposite_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47106780000000004}
#standard deviation: 0.046460749059394214
#island_id: 1
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = [val for val in site_neighbors if val == J[2,i,j,k]]
        different_spin = [val for val in site_neighbors if val != J[2,i,j,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(same_spin) - len(different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.35164100000000004}
#standard deviation: 0.05177717218041171
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][0] += total_spin_term
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.35164100000000004}
#standard deviation: 0.05177717218041171
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][0] += total_spin_term
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.0277498}
#standard deviation: 0.04584437588145355
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # New term based on the number of nearest neighbors with the same spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count_same + neighbor_spin_count_opposite)
        priorities[i*N*N+j*N+k][1] -= site_energy - 2*np.log(1+np.exp(total_spin))

  return priorities




#score: {'data3D.txt': -0.5143346}
#standard deviation: 0.04074959046223655
#island_id: 1
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(1 if val == J[2,i,j,k] else -1 for val in site_neighbors)
        different_spin = len(site_neighbors) - abs(same_spin)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin + 2*different_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47106780000000004}
#standard deviation: 0.046460749059394214
#island_id: 1
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum([val == J[2,i,j,k] for val in site_neighbors])
        different_spin = len(site_neighbors) - same_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * same_spin - different_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47106780000000004}
#standard deviation: 0.046460749059394214
#island_id: 1
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin = sum(1 for val in site_neighbors if val == J[2,i,j,k])
        different_spin = 3 - same_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * same_spin - different_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        same_spin_count = sum(1 for val in site_neighbors if val < 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (same_spin_count + 2*opposite_spin_count)
        priorities[i*N*N+j*N+k][1] -= (same_spin_count - opposite_spin_count)
        
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.178507}
#standard deviation: 0.04599656020834601
#island_id: 0
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors_count = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_spin + site_neighbors_count)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - local_energy
        
  return(priorities)




#score: {'data3D.txt': 0.3566794}
#standard deviation: 0.050550109551216596
#island_id: 3
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + sum([np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.44327300000000003}
#standard deviation: 0.04303284781419886
#island_id: 3
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.4302026}
#standard deviation: 0.04424398392143276
#island_id: 3
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the total spin and number of nearest neighbors with the same spin
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the priority based on site interactions and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Calculate the priority based on nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Calculate the priority based on nearest neighbors with same spin and different spin
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return priorities




#score: {'data3D.txt': 0.1918914}
#standard deviation: 0.04565360890488286
#island_id: 0
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.178507}
#standard deviation: 0.04599656020834601
#island_id: 0
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors_count = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_spin + site_neighbors_count)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.20383620000000002}
#standard deviation: 0.04603258856027977
#island_id: 0
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        
        if h[i][j][k] > 0:
          (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (site_neighbors_count + total_spin)
          priorities[i*N*N+j*N+k][1] -= local_energy
          
          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] += 1
            
          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i+N*N+j*N+k][1] += 1
          
          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * 1
              priorities[i*N*N+j*N+k][1] -= local_energy
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] += local_energy
          
          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] -= local_energy
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] += local_energy
          
        else:
          (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(local_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] += local_energy
          
          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i+N*N+j*N+k][1] += 1
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i+N*N+j*N+k][1] -= 1
            
          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i+N*N+j*N+k][1] += 1
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i+N*N+j*N+k][1] -= 1
          
          if k > 0:
            neighbor_spin = J[2,i,j,k-1]
            if neighbor_spin < 0:
              priorities[i+N*N+j*N+k][0] -= np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] += local_energy
            elif neighbor_spin > 0:
              priorities[i+N*N+j*N+k][0] -= np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] -= local_energy
          
          if k < N-1:
            neighbor_spin = J[2,i,j,k+1]
            if neighbor_spin < 0:
              priorities[i+N*N+j*N+k][0] -= np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] += local_energy
            elif neighbor_spin > 0:
              priorities[i+N*N+j*N+k][0] -= np.exp(local_energy) * 1
              priorities[i+N*N+j*N+k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': 0.288649}
#standard deviation: 0.05330687947160292
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k]*h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin/3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin_term
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (-neighbor_spin_count)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.2760586}
#standard deviation: 0.053600506397234716
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k]*h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin/3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin_term
        priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i*N*N+j*N+k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * abs(neighbor_spin_count)
          priorities[i*N*N+j*N+k][1] += site_energy

  return priorities




#score: {'data3D.txt': 0.35164100000000004}
#standard deviation: 0.05177717218041171
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1

        # Calculate the local energy and the interaction with neighboring spins
        total_spin_term = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][0] += total_spin_term
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with opposite spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.025421800000000005}
#standard deviation: 0.04605910859710595
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] -= site_energy
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] += site_energy
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] -= site_energy
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] += site_energy
  
  return(priorities)




#score: {'data3D.txt': -0.019225399999999986}
#standard deviation: 0.04675443545632864
#island_id: 0
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        # Calculate site energy for neighboring sites
        if k > 0:
          neighbor_site_energy = (-abs(J[2, i, j, k-1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k-1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
        if k < N-1:
          neighbor_site_energy = (-abs(J[2, i, j, k+1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k+1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
  
  return(priorities)




#score: {'data3D.txt': -0.22989819999999997}
#standard deviation: 0.06576404851254217
#island_id: 0
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if J[2, i, j, k-1] < 0 else -1 if J[2, i, j, k-1] > 0 else 0 for k in range(1, N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * site_neighbors_count
        priorities[i*N*N+j*N+k][1] -= site_neighbors_count
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(interacting_spins)
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (site_neighbors_count + total_spin) + np.exp(sum(val**2 for val in interacting_spins))
        priorities[i*N*N+j*N+k][1] -= sum(val**2 for val in interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.019225399999999986}
#standard deviation: 0.04675443545632864
#island_id: 0
#version_generated: 3
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        # Calculate priority based on site energy and neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k > 0:
          neighbor_site_energy = (-abs(J[2, i, j, k-1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k-1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
        if k < N-1:
          neighbor_site_energy = (-abs(J[2, i, j, k+1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k+1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
  
  return(priorities)




#score: {'data3D.txt': -0.03974420000000001}
#standard deviation: 0.04675231894098944
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        # Simplify the calculation of `priorities[i*N*N+j*N+k][0]`
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i+N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i+N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i+N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i+N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] -= site_energy
          elif neighbor_spin > 0:
            priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] += site_energy
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] -= site_energy
          elif neighbor_spin > 0:
            priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * 1
            priorities[i+N*N+j*N+k][1] += site_energy
  
  return(priorities)




#score: {'data3D.txt': -0.019225399999999986}
#standard deviation: 0.04675443545632864
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = -abs(total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i+N*N+j*N+k][1] += 1
        
        if k > 0:
          site_energy = -abs(J[2, i, j, k-1]) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k-1]
          priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= site_energy
        
        if k < N-1:
          site_energy = -abs(J[2, i, j, k+1]) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k+1]
          priorities[i+N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= site_energy
  
  return(priorities)




#score: {'data3D.txt': 0.015384600000000014}
#standard deviation: 0.047153846532812155
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = (-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add neighbor energies
        if k > 0:
          neighbor_site_energy = (-abs(J[2, i, j, k-1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
        if k < N-1:
          neighbor_site_energy = (-abs(J[2, i, j, k+1])) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k+1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.015384600000000014}
#standard deviation: 0.047153846532812155
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[i][j][k]]
        
        # Add neighboring spins that interact with current spin
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        if k < N-1:
          interacting_spins.append(J[2, i, j, k+1])
        
        total_spin = sum(interacting_spins)
        
        # Calculate site energy
        site_energy = -abs(total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(site_energy) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add neighbor energies
        if k > 0:
          neighbor_site_energy = -abs(J[2, i, j, k-1]) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
        if k < N-1:
          neighbor_site_energy = -abs(J[2, i, j, k+1]) * len([val for val in interacting_spins if val < 0]) + J[2, i, j, k+1]
          priorities[i+N*N+j*N+k][0] += np.exp(neighbor_site_energy) * (site_neighbors_count + total_spin)
          priorities[i+N*N+j*N+k][1] -= neighbor_site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.178507}
#standard deviation: 0.04599656020834601
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors_count = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        local_energy = sum(J[d,i,j,k]**2 for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_spin + site_neighbors_count)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.14731260000000013}
#standard deviation: 0.04699361404744266
#island_id: 0
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors_count = sum(1 if val < 0 else -1 if val > 0 else 0 for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (site_neighbors_count + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 2
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.2604306}
#standard deviation: 0.04475657520007535
#island_id: 2
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= (2 - np.exp(h[i][j][k])) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= (2 - np.exp(h[i][j][k])) * len([val for val in interacting_spins if val < 0])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.389885}
#standard deviation: 0.04980248844184395
#island_id: 3
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-abs(total_spin)) * neighbor_spin_count
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.229005}
#standard deviation: 0.057102861705872504
#island_id: 3
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        neighbor_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= neighbor_count
        
  return(priorities)




#score: {'data3D.txt': 0.44330020000000003}
#standard deviation: 0.042442461756594656
#island_id: 3
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
          priorities[i*N*N+j*N+k][1] -= site_energy
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * (total_spin / 3 + np.exp(-total_spin) - np.exp(total_spin))
          priorities[i*N*N+j*N+k][1] += site_energy
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.32213180000000013}
#standard deviation: 0.04706018305064271
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  return(priorities)




#score: {'data3D.txt': -0.3697674000000001}
#standard deviation: 0.04710135387905533
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4
        
        # Add new term to prioritize spins based on their absolute value
        priorities[i*N*N+j*N+k][0] += (np.abs(sum(val for val in interacting_spins)) + np.abs(total_spin)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35302620000000007}
#standard deviation: 0.04448174989318653
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin)) + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin)) + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': 0.08137979999999999}
#standard deviation: 0.0480475609366386
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  return(priorities)




#score: {'data3D.txt': -0.48681899999999995}
#standard deviation: 0.04290858654162358
#island_id: 2
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] < 0 for d in range(3)])),
                   int(np.sum([J[d, (i+1)%N, j, k] < 0 for d in range(3)])),
                   int(np.sum([J[d, i, j, (k+1)%N] < 0 for d in range(3)]))]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([count * (val > 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])

        # Add a new term based on the local energy
        priorities[i*N*N + j*N + k][0] += np.exp(h[i][j][k])
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.3899918}
#standard deviation: 0.045754580675163005
#island_id: 2
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Count the number of neighbors with different spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, (i+1)%N, j, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, i, j, (k+1)%N] < 0 for d in range(3)]))]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([count * (val > 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])
        
  return priorities




#score: {'data3D.txt': -0.48681899999999995}
#standard deviation: 0.04290858654162358
#island_id: 2
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, (i+1)%N, j, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, i, j, (k+1)%N] < 0 for d in range(3)]))]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([count * (val > 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])

        # Add a new term based on the local energy
        priorities[i*N*N + j*N + k][0] += np.exp(h[i][j][k])
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.46581140000000004}
#standard deviation: 0.042712790473580634
#island_id: 2
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, (i+1)%N, j, k] < 0 for d in range(3)])),
                  int(np.sum([J[d, i, j, (k+1)%N] < 0 for d in range(3)]))]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([count * (val > 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])

        # Add a new term based on the number of nearest neighbors with same spin
        neighbor_counts = [int(np.sum([J[d, i, (j+1)%N, k] == 0 for d in range(3)])),
                  int(np.sum([J[d, (i+1)%N, j, k] == 0 for d in range(3)])),
                  int(np.sum([J[d, i, j, (k+1)%N] == 0 for d in range(3)]))]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([count * (val == 0) for count, val in zip(neighbor_counts, [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])])

  return priorities




#score: {'data3D.txt': 0.2550966}
#standard deviation: 0.05487544285415836
#island_id: 3
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy

        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count_same > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_same)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.36475340000000006}
#standard deviation: 0.05260019798860077
#island_id: 3
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count)
          priorities[i * N * N + j * N + k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with opposite spin
        neighbor_spin_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_opposite)
        priorities[i * N * N + j * N + k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.2746462}
#standard deviation: 0.05693169508771015
#island_id: 3
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * (neighbor_spin_count_same)
        priorities[i * N * N + j * N + k][1] = site_energy

        # New term based on the number of nearest neighbors with same spin
        if neighbor_spin_opposite > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_opposite)
          priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.3848438}
#standard deviation: 0.05059756636005333
#island_id: 3
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] = site_energy
        
        if neighbor_spin_count_same > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_count_same)
          priorities[i * N * N + j * N + k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with opposite spin
        neighbor_spin_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_opposite += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (neighbor_spin_opposite)
        priorities[i * N * N + j * N + k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 0
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.14736860000000002}
#standard deviation: 0.05434958706411669
#island_id: 3
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k]*h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            neighbor_spin_count -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            neighbor_spin_count -= 1
        
        # Calculate the priority based on the site energy and neighbor spin count
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]]))) * (1 - neighbor_spin_count/3)
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.41054579999999996}
#standard deviation: 0.042298954861320154
#island_id: 3
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # New term based on the number of nearest neighbors with same spin and local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the local energy and number of nearest neighbors with different spin
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0057094}
#standard deviation: 0.046506211108195
#island_id: 3
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.0646902}
#standard deviation: 0.05293951627999636
#island_id: 3
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k]*h[i][j][k]
        
        # Calculate the priority
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Calculate the neighbor energy
        neighbor_energy = 0
        if k > 0:
          neighbor_energy += J[2,i,j,k-1]*h[i][j][k-1]
        if k < N-1:
          neighbor_energy += J[2,i,j,k+1]*h[i][j][k+1]
        
        # Calculate the priority based on the neighbor energy
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_energy / 3 + np.exp(neighbor_energy) - np.exp(-neighbor_energy))
        priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.08548499999999999}
#standard deviation: 0.04862887881701572
#island_id: 2
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_nbr = (i + ((N-1)%2 - 1)) % N
        priorities[i*N*N+j*N+N-1][0] -= np.exp(h[i][j].sum())
        priorities[i*N*N+j*N+N-1][1] += h[i][j].sum()
      elif h[i][j].sum() < 0:
        site_nbr = (i + ((N-2)%2 - 1)) % N
        priorities[i*N*N+j*N+N-1][0] += np.exp(h[i][j].sum())
        priorities[i*N*N+j*N+N-1][1] -= h[i][j].sum()

  return(priorities)




#score: {'data3D.txt': 0.08137979999999999}
#standard deviation: 0.0480475609366386
#island_id: 2
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  return(priorities)




#score: {'data3D.txt': 0.08137979999999999}
#standard deviation: 0.0480475609366386
#island_id: 2
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  return(priorities)




#score: {'data3D.txt': 0.08137979999999999}
#standard deviation: 0.0480475609366386
#island_id: 2
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][site_nbr][j]
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 4

  return(priorities)




#score: {'data3D.txt': 0.46750379999999997}
#standard deviation: 0.04471678863201158
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        neighbor_energy = 0
        if i > 0:
          neighbor_energy += J[1,i-1,j,k] * h[(i-1)%N][j][k]
        if i < N-1:
          neighbor_energy += J[1,i+1,j,k] * h[(i+1)%N][j][k]
        if j > 0:
          neighbor_energy += J[2,i,(j-1)%N,k] * h[i][(j-1)%N][k]
        if j < N-1:
          neighbor_energy += J[2,i,(j+1)%N,k] * h[i][(j+1)%N][k]
        if k > 0:
          neighbor_energy += J[2,i,j,(k-1)%N] * h[i][j][(k-1)%N]
        if k < N-1:
          neighbor_energy += J[2,i,j,(k+1)%N] * h[i][j][(k+1)%N]

        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + sum([np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]) + np.exp(-neighbor_energy)
        priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.3566794}
#standard deviation: 0.050550109551216596
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + sum([np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.30579059999999997}
#standard deviation: 0.05183469061969986
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + sum([np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.4415382}
#standard deviation: 0.04514812577239503
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + sum([np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin (in z-direction)
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin (in z-direction)
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.44517700000000004}
#standard deviation: 0.043274604920206954
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        neighbor_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= neighbor_count
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k-1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k+1]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.43392499999999995}
#standard deviation: 0.044320535364546304
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        neighbor_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_count -= 1
          else: neighbor_count += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= neighbor_count
        
        # New term based on the number of nearest neighbors with different spin and the local energy
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * h[i][j][k]
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.20509739999999999}
#standard deviation: 0.05698895044866154
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term based on the number of nearest neighbors with the same spin and the local energy
        neighbor_count = 0
        for d in [0,1,2]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.33349860000000003}
#standard deviation: 0.04899133554048104
#island_id: 3
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.1772794}
#standard deviation: 0.048388333052916795
#island_id: 3
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the weights
        spin_weights = [np.exp(-abs(J[d,i,j,k])) for d in [0,1,2]]
        total_weight = sum(spin_weights)
        
        priorities[i*N*N+j*N+k][0] += (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * spin_weights[0] / total_weight
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin (in z-direction)
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] -= 1
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin (in z-direction)
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] += 1
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1 / total_weight
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.164609}
#standard deviation: 0.05406936395963984
#island_id: 3
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # New term: add the energy contribution from all neighboring sites
        neighbor_energy = 0
        if i > 0:
          neighbor_energy += sum([J[d,i-1,j,k] * h[i-1][j][k] for d in [0,1,2]])
        if i < N-1:
          neighbor_energy += sum([J[d,i+1,j,k] * h[i+1][j][k] for d in [0,1,2]])
        if j > 0:
          neighbor_energy += sum([J[d,i,j-1,k] * h[i][j-1][k] for d in [0,1,2]])
        if j < N-1:
          neighbor_energy += sum([J[d,i,j+1,k] * h[i][j+1][k] for d in [0,1,2]])
        if k > 0:
          neighbor_energy += sum([J[d,i,j,k-1] * h[i][j][k-1] for d in [0,1,2]])
        if k < N-1:
          neighbor_energy += sum([J[d,i,j,k+1] * h[i][j][k+1] for d in [0,1,2]])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy - neighbor_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5561822}
#standard deviation: 0.0409939630087163
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.41195539999999997}
#standard deviation: 0.04522225702947609
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        local_energy = sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
  return priorities




#score: {'data3D.txt': -0.5108738}
#standard deviation: 0.04296904506223055
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4291798}
#standard deviation: 0.04222305948128345
#island_id: 2
#version_generated: 3
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N + j*N + k][1] -= d + 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 1
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Added the following lines to improve the algorithm:
        site_nbr_xz = (i + ((k-1)%2)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2:] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2:] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.4891378}
#standard deviation: 0.04406495854031864
#island_id: 3
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d, i, j, k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d, i, j, k] for d in [0,1,2]])) - np.exp(-np.sum([J[d, i, j, k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.45258699999999996}
#standard deviation: 0.04583876297414668
#island_id: 3
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
        # Add a new term based on the number of nearest neighbors with the same spin and opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.4450718000000001}
#standard deviation: 0.047438794301288896
#island_id: 3
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d, i, j, k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d, i, j, k] for d in [0,1,2]])) - np.exp(-np.sum([J[d, i, j, k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.4450718000000001}
#standard deviation: 0.047438794301288896
#island_id: 3
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the local energy and the interaction with neighboring spins
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * 1
            priorities[i*N*N+j*N+k][1] += site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.35336860000000003}
#standard deviation: 0.0538776526404037
#island_id: 3
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k]*h[i][j][k]
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy)*(total_spin/3+np.exp(total_spin)-np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the same spin
        if neighbor_spin_count_same > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*(neighbor_spin_count_same)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # New term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*1; priorities[i*N*N+j*N+k][1] += site_energy
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0: priorities[i*N*N+j*N+k][0] += np.exp(-site_energy)*1; priorities[i*N*N+j*N+k][1] += site_energy
        
  return priorities




#score: {'data3D.txt': -0.44794940000000005}
#standard deviation: 0.045860298730383345
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.13989580000000001}
#standard deviation: 0.05216548880591459
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_energy = J[0, i, j, k] * h[i][j][k]
        
        neighbor_energy = 0
        for d in range(3):
          if i > 0 and d == 0:
            neighbor_energy += J[d, i-1, j, k] * (h[i-1][j][k]-h[i][j][k])
          elif i < N-1 and d == 0:
            neighbor_energy += J[d, i+1, j, k] * (h[i+1][j][k]-h[i][j][k])
          if j > 0 and d == 1:
            neighbor_energy += J[d, i, j-1, k] * (h[i][j-1][k]-h[i][j][k])
          elif j < N-1 and d == 1:
            neighbor_energy += J[d, i, j+1, k] * (h[i][j+1][k]-h[i][j][k])
          if k > 0 and d == 2:
            neighbor_energy += J[d, i, j, k-1] * (h[i][j][k-1]-h[i][j][k])
          elif k < N-1 and d == 2:
            neighbor_energy += J[d, i, j, k+1] * (h[i][j][k+1]-h[i][j][k])

        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
        priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy

        if total_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.0001746000000000001}
#standard deviation: 0.04677302165607863
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        neighbor_energy = 0
        if i > 0:
          neighbor_energy += sum([J[d,i-1,j,k] * h[i-1][j][k] for d in [0,1,2]])
        if i < N - 1:
          neighbor_energy += sum([J[d,i+1,j,k] * h[i+1][j][k] for d in [0,1,2]])
        if j > 0:
          neighbor_energy += sum([J[d,i,j-1,k] * h[i][j-1][k] for d in [0,1,2]])
        if j < N - 1:
          neighbor_energy += sum([J[d,i,j+1,k] * h[i][j+1][k] for d in [0,1,2]])
        if k > 0:
          neighbor_energy += J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
        if k < N - 1:
          neighbor_energy += J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
        priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
  return priorities




#score: {'data3D.txt': 0.14736860000000002}
#standard deviation: 0.05434958706411669
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the energy contribution from all neighboring sites
        neighbor_energy = 0
        if i > 0:
          neighbor_energy += J[0,i-1,j,k] * h[i-1][j][k]
        if i < N-1:
          neighbor_energy += J[0,i+1,j,k] * h[i+1][j][k]
        if j > 0:
          neighbor_energy += J[1,i,j-1,k] * h[i][j-1][k]
        if j < N-1:
          neighbor_energy += J[1,i,j+1,k] * h[i][j+1][k]
        if k > 0:
          neighbor_energy += J[2,i,j,k-1] * h[i][j][k-1]
        if k < N-1:
          neighbor_energy += J[2,i,j,k+1] * h[i][j][k+1]

        # Calculate the priority for each spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy

  return priorities




#score: {'data3D.txt': 0.4032406}
#standard deviation: 0.04888088452186601
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5148226000000001}
#standard deviation: 0.04045960268267596
#island_id: 0
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4707606000000001}
#standard deviation: 0.04574796528415225
#island_id: 0
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin != 0)
            priorities[i*N*N+j*N+k][1] -= (neighbor_spin != 0)
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin != 0)
            priorities[i*N*N+j*N+k][1] += (neighbor_spin != 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5148226000000001}
#standard deviation: 0.04045960268267596
#island_id: 0
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.23442860000000018}
#standard deviation: 0.045606862006062183
#island_id: 1
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4203134}
#standard deviation: 0.0388528977096947
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N + j*N + k][1] -= d + 1

  return(priorities)




#score: {'data3D.txt': -0.4455018}
#standard deviation: 0.04084787481326293
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N + j*N + k][1] -= d + 1

        # Add a new term based on the local energy and total spin
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += h[i][j][k] * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3710558}
#standard deviation: 0.04705992399441376
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.40893980000000013}
#standard deviation: 0.048709186976996444
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  # Add a new term based on the local energy and total spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] += 2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.4710294}
#standard deviation: 0.040641794936247595
#island_id: 1
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4913842000000001}
#standard deviation: 0.04158816118031669
#island_id: 1
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)

        # Add a new term based on the local energy and nearest neighbor interactions
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.38593299999999997}
#standard deviation: 0.04254493660824987
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)
        
        # Add site and neighbor information to the priority list
        priorities[i*N*N+j*N+k][0] += np.exp(-sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.26537459999999996}
#standard deviation: 0.04843248697764755
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(abs(val) for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(abs(val) for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        local_energy = sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
  
  return priorities




#score: {'data3D.txt': -0.42325899999999994}
#standard deviation: 0.04175696539500925
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)
        
        local_energy = sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.3831246}
#standard deviation: 0.04666838624636596
#island_id: 3
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.2513058}
#standard deviation: 0.05505790375922425
#island_id: 3
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_energy = J[0,i,j,k] * h[i][j][k]
        neighbor_count = 0
        for d in [0,1,2]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
          if i > 0:
            neighbor_spin = J[2,i-1,j,k]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
          if i < N-1:
            neighbor_spin = J[2,i+1,j,k]
            if neighbor_spin < 0: neighbor_count -= 1
            else: neighbor_count += 1
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-abs(total_spin)) * neighbor_count
        priorities[i*N*N+j*N+k][1] -= site_energy
  return(priorities)




#score: {'data3D.txt': 0.06916380000000001}
#standard deviation: 0.0626353709142047
#island_id: 3
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: total_spin -= 1
          elif neighbor_spin > 0: total_spin += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: total_spin -= 1
          elif neighbor_spin > 0: total_spin += 1
        
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0: total_spin -= 1
          elif neighbor_spin > 0: total_spin += 1
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: total_spin -= 1
          elif neighbor_spin > 0: total_spin += 1
        
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] = -site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.46959860000000014}
#standard deviation: 0.04425883999880702
#island_id: 1
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)

        # Add a new term based on the local energy and nearest neighbors' spins
        local_energy = h[i][j][k]
        neighbor_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i-1%N, j,k]]
        total_neighbor_spin = sum(neighbor_spins)
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
        else:
          neighbor_spin = 0
          
        if k < N-1:
          neighbor_spin += J[2,i,j,k+1]
          
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_neighbor_spin + total_spin)
        priorities[i*N*N+j*N+k][1] -= local_energy - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin) + sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) - sum(abs(val) for val in interacting_spins)

        # Add site and neighbor information to the priority list
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2])) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum(h[d][i][j]*J[d,i,j,k] for d in [0,1,2])) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = 2 - total_spin

  return(priorities)




#score: {'data3D.txt': -0.4312030000000002}
#standard deviation: 0.046882596675098955
#island_id: 2
#version_generated: 3
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        local_energy = sum(val for val in interacting_spins) - 2*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (4 - local_energy)
          priorities[i*N*N+j*N+k][1] -= 4 - local_energy
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (-4 + local_energy)
          priorities[i*N*N+j*N+k][1] -= -4 + local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.2547810000000001}
#standard deviation: 0.04354834094428857
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
    
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
    
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
    
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
    
  return(priorities)




#score: {'data3D.txt': 0.45115020000000006}
#standard deviation: 0.045096127105994366
#island_id: 3
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if i > 0:
          neighbor_spin = J[2,i-1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.24679500000000001}
#standard deviation: 0.05262983882741804
#island_id: 3
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * neighbor_spin_count_same + np.exp(-site_energy) * neighbor_spin_count_opposite
        priorities[i*N*N+j*N+k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.24679500000000001}
#standard deviation: 0.05262983882741804
#island_id: 3
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_energy = J[0, i, j, k] * h[i][j][k]

        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin_count_same = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: neighbor_spin_count_same -= 1
          else: neighbor_spin_count_same += 1

        # Calculate the number of nearest neighbors with opposite spin
        neighbor_spin_count_opposite = 0
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0: neighbor_spin_count_opposite -= 1
          else: neighbor_spin_count_opposite += 1

        # Calculate the local energy and the interaction with neighboring spins
        priorities[i * N * N + j * N + k][0] = np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-site_energy) * neighbor_spin_count_same + np.exp(-site_energy) * neighbor_spin_count_opposite
        priorities[i * N * N + j * N + k][1] -= site_energy

  return(priorities)




#score: {'data3D.txt': 0.12538660000000001}
#standard deviation: 0.0513709211562339
#island_id: 3
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2]]
        total_spin = sum(interacting_spins)
        
        # Calculate the local energy and the interaction with neighboring spins
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': 0.027635}
#standard deviation: 0.04839600329572681
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + 
                                       np.exp(total_spin) - 
                                       np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + 
                                       np.exp(total_spin) - 
                                       np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
    
    return(priorities)




#score: {'data3D.txt': -0.0015865999999999999}
#standard deviation: 0.046863598884848784
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + 
                      np.exp(total_spin) - np.exp(-total_spin)) 
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                      np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0016205999999999998}
#standard deviation: 0.046832006316620683
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + 
                      np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if i < N-1:
          neighbor_spin = J[2,i+1,j,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if j < N-1:
          neighbor_spin = J[2,i,j+1,k]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: 
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_spin
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                np.exp(neighbor_spin) - np.exp(-neighbor_spin))
            priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': 0.41852100000000003}
#standard deviation: 0.04764513867122227
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + 
                                      np.exp(total_spin) - 
                                      np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [0,1]:
          if k > 0:
            neighbor_spin = J[d,i,j,k-1]
            if neighbor_spin < 0: 
              priorities[i*N*N+j*N+k][0] -= 2*neighbor_spin
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
              priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
          if k < N-1:
            neighbor_spin = J[d,i,j,k+1]
            if neighbor_spin < 0: 
              priorities[i*N*N+j*N+k][0] -= 2*neighbor_spin
            elif neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 
                                            np.exp(neighbor_spin) - 
                                            np.exp(-neighbor_spin))
              priorities[i*N*N+j*N+k][1] += 2*neighbor_spin
        
        priorities[i*N*N+j*N+k][0] -= site_energy
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.46959860000000014}
#standard deviation: 0.04425883999880702
#island_id: 1
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)

        # Add a new term based on the local energy and nearest neighbors' spins
        local_energy = h[i][j][k]
        neighbor_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i-1%N, j,k]]
        total_neighbor_spin = sum(neighbor_spins)

        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
        else:
          neighbor_spin = 0

        if k < N-1:
          neighbor_spin += J[2,i,j,k+1]

        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_neighbor_spin + total_spin)
        priorities[i*N*N+j*N+k][1] -= local_energy - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.46593420000000013}
#standard deviation: 0.04471290943743205
#island_id: 1
#version_generated: 3
#generate time20:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)
          
        # Add a new term based on the local energy and nearest neighbors' spins
        local_energy = h[i][j][k]
        neighbor_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i-1%N, j,k]]
        total_neighbor_spin = sum(neighbor_spins)
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
        else:
          neighbor_spin = 0
          
        if k < N-1:
          neighbor_spin += J[2,i,j,k+1]
          
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy) * (total_neighbor_spin + total_spin)
        priorities[i*N*N+j*N+k][1] -= local_energy - 2*total_spin
        
  # Add a term based on the next neighbor's spin in x direction
  for i in range(N):
    for j in range(N):
      if i < N-1:
        neighbor_spin = J[0,i+1,j,k]
      else:
        neighbor_spin = 0
      
      priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (neighbor_spin + total_spin)
      priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4710294}
#standard deviation: 0.040641794936247595
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4710294}
#standard deviation: 0.040641794936247595
#island_id: 1
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4796850000000001}
#standard deviation: 0.04152708724435173
#island_id: 1
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin)
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin == h[i][j][k]:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        elif k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin == h[i][j][k]:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin != h[i][j][k]:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        elif k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin != h[i][j][k]:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4865942}
#standard deviation: 0.03948158059601971
#island_id: 1
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - abs(total_spin) - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(total_spin) + h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.42033339999999997}
#standard deviation: 0.040294845383001536
#island_id: 2
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spin_sum = 0
        for d in [0,1]:
          for l in [(i+1)%N if i < N-1 else i, (j+1)%N if j < N-1 else j, (k+1)%N if k < N-1 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
          for l in [(i-1)%N if i > 0 else i, (j-1)%N if j > 0 else j, (k-1)%N if k > 0 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i*N*N+j*N+k][1] += neighbor_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.0013226000000000002}
#standard deviation: 0.0468835660891959
#island_id: 3
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        neighbor_spin_count = 0
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0: neighbor_spin_count -= 1
          else: neighbor_spin_count += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        if neighbor_spin_count > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (neighbor_spin_count + 1)
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        return(priorities)




#score: {'data3D.txt': -0.4382634}
#standard deviation: 0.045457982582160425
#island_id: 0
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3770142000000001}
#standard deviation: 0.044288409300402745
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5148226000000001}
#standard deviation: 0.04045960268267596
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0031866}
#standard deviation: 0.04689213090103712
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.3441918}
#standard deviation: 0.04589527353399259
#island_id: 3
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * (total_spin / 3 + np.exp(abs(total_spin)) - np.exp(-abs(total_spin)))
          priorities[i*N*N+j*N+k][1] += site_energy
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k]) * (np.exp(-abs(total_spin)) + np.exp(abs(total_spin)))
            priorities[i*N*N+j*N+k][1] += abs(J[d,i,j,k])
        
  return priorities




#score: {'data3D.txt': 0.45726300000000003}
#standard deviation: 0.041958663360502794
#island_id: 3
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        # Calculate the total spin and number of nearest neighbors with the same spin
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the priority based on site interactions and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (np.sum([J[d,i,j,k] for d in [0,1,2]]) / 3 + np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]])) - np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]])))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Calculate the priority based on nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Calculate the priority based on nearest neighbors with same spin and different spin
        site_energy = J[0,i,j,k] * h[i][j][k]
        if k > 0:
          neighbor_energy = J[2,i,j,k-1] * (h[i][j][k]-h[i][j][k-1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        if k < N-1:
          neighbor_energy = J[2,i,j,k+1] * (h[i][j][k]-h[i][j][k+1])
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
        
        # Calculate the priority based on nearest neighbors with same spin and different spin (newly added)
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
  
  return priorities




#score: {'data3D.txt': 0.4082694}
#standard deviation: 0.044572041726176286
#island_id: 3
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority based on site interactions and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Calculate the priority based on nearest neighbors with different spin
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            neighbor_spin = J[d,(i+((d-1)%3 - 1)) % N, j, k]
            if neighbor_spin < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Calculate the priority based on nearest neighbors with same spin and different spin
        for d in [0,1,2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          if k > 0:
            neighbor_energy = J[d,i,j,k-1] * (h[i][j][k]-h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
            priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
          
          if k < N-1:
            neighbor_energy = J[d,i,j,k+1] * (h[i][j][k]-h[site_nbr][j][k+1])
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * np.exp(-neighbor_energy)
            priorities[i*N*N+j*N+k][1] -= site_energy - neighbor_energy
  
  return priorities




#score: {'data3D.txt': 0.4032406}
#standard deviation: 0.04888088452186601
#island_id: 3
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 1
#version_generated: 2
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors.sort()
        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N+j*N+k][1] -= d + 1
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2949254}
#standard deviation: 0.05047045942766917
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += sum(val for val in site_neighbors) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (d + 1)
            priorities[i*N*N + j*N + k][1] -= d + 1

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2949254}
#standard deviation: 0.05047045942766917
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.273519}
#standard deviation: 0.041418428253616774
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] = (abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spin_sum = 0
        for d in [0,1]:
          for l in [(i+1)%N if i < N-1 else i, (j+1)%N if j < N-1 else j, (k+1)%N if k < N-1 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
          for l in [(i-1)%N if i > 0 else i, (j-1)%N if j > 0 else j, (k-1)%N if k > 0 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i*N*N+j*N+k][1] += neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.11884940000000001}
#standard deviation: 0.04430873592915961
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] = (abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        priorities[i*N*N+j*N+k][0] += abs(neighbor_spin_sum)
        priorities[i*N*N+j*N+k][1] -= neighbor_spin_sum
  
  return(priorities)




#score: {'data3D.txt': -0.4113058}
#standard deviation: 0.04033251946457102
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spin_sum = 0
        for d in [0,1]:
          for l in [(i+1)%N if i < N-1 else i, (j+1)%N if j < N-1 else j, (k+1)%N if k < N-1 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
          for l in [(i-1)%N if i > 0 else i, (j-1)%N if j > 0 else j, (k-1)%N if k > 0 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i*N*N+j*N+k][1] += neighbor_spin_sum

  # Add a new term based on the number of nearest neighbors with the same spin and different z-coordinate
  for i in range(N):
    for j in range(N):
      if i < N-1:
        neighbor_spin = J[2,i+1,j,k]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1

      if i > 0:
        neighbor_spin = J[2,i-1,j,k]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1

      if j < N-1:
        neighbor_spin = J[2,i,j+1,k]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1

      if j > 0:
        neighbor_spin = J[2,i,j-1,k]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3213918}
#standard deviation: 0.04604184849416887
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spin_sum = 0
        for d in [0,1]:
          for l in [(i+1)%N if i < N-1 else i, (j+1)%N if j < N-1 else j, (k+1)%N if k < N-1 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
          for l in [(i-1)%N if i > 0 else i, (j-1)%N if j > 0 else j, (k-1)%N if k > 0 else k]:
            neighbor_spin = J[d,l,j,k]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i*N*N+j*N+k][1] += neighbor_spin_sum

        # New term: Add the energy contribution from each of the 26 nearest neighbors
        for d in [0,1]:
          for l in [(i+1)%N if i < N-1 else i, (j+1)%N if j < N-1 else j, (k+1)%N if k < N-1 else k]:
            neighbor_spin = J[d,l,j,k]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= neighbor_spin
          for l in [(i-1)%N if i > 0 else i, (j-1)%N if j > 0 else j, (k-1)%N if k > 0 else k]:
            neighbor_spin = J[d,l,j,k]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.4939914}
#standard deviation: 0.042949431265617476
#island_id: 3
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_energy = J[0, i, j, k] * h[i][j][k]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if interacting_spins[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
        priorities[i * N * N + j * N + k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 3
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.49298939999999997}
#standard deviation: 0.04303742845059402
#island_id: 3
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) + np.exp(-abs(site_energy)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_energy)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 3
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 3
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority for -1 spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        
        # Calculate the priority for 1 spin
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.484605}
#standard deviation: 0.04009687886856034
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.511283}
#standard deviation: 0.04269646110627906
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0][i][j][(k+1)%N], J[1][(i+1)%N][j][k], J[2][i][j][k-1]]
        if all([neighbor < 0 for neighbor in site_neighbors]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] -= 3
        elif all([neighbor > 0 for neighbor in site_neighbors]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i*N*N+j*N+k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.493201}
#standard deviation: 0.041356438422572125
#island_id: 0
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if any(J[d,i,(j+1)%N,k] < 0 for d in [0,1]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        elif any(J[d,i,(j+1)%N,k] > 0 for d in [0,1]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        if i < N-1:
          site_neighbors = [J[2,i+1,j,k], J[2,i,j,(k+1)%N]]
          if any(J[d,i+1,j,k] < 0 for d in [2]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
          elif any(J[d,i+1,j,k] > 0 for d in [2]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3126918}
#standard deviation: 0.051511046706119265
#island_id: 0
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0 and h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k-1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0 and h[i][j][k+1] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
          elif neighbor_spin > 0 and h[i][j][k+1] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4382634}
#standard deviation: 0.045457982582160425
#island_id: 0
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3281006000000001}
#standard deviation: 0.04764484189962225
#island_id: 0
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3281006000000001}
#standard deviation: 0.04764484189962225
#island_id: 0
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3427738000000002}
#standard deviation: 0.045751639900226515
#island_id: 0
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        for d in [0,1]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.3281006000000001}
#standard deviation: 0.04764484189962225
#island_id: 0
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif all(val < 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins) and h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])
        
        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.484605}
#standard deviation: 0.04009687886856034
#island_id: 0
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.484605}
#standard deviation: 0.04009687886856034
#island_id: 0
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        
        edge_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in edge_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.28761100000000006}
#standard deviation: 0.04600240862172328
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.26649019999999995}
#standard deviation: 0.043868680216756016
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
          
          # Add a bias to favor the direction of the magnetism
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([val for val in interacting_spins if val > 0]) + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2 * site_energy
          
  return priorities




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

  return(priorities)




#score: {'data3D.txt': -0.5291414000000001}
#standard deviation: 0.03888161578484105
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if i > 0:
          site_neighbors = [J[0,i-1,j,k], J[1,i-1,j,k]]
          if any(J[d,i-1,j,k] < 0 for d in [0,1]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
          elif any(J[d,i-1,j,k] > 0 for d in [0,1]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.35952379999999995}
#standard deviation: 0.04359711450956359
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][site_nbr][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][site_nbr][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.493201}
#standard deviation: 0.041356438422572125
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if any(J[d,i,(j+1)%N,k] < 0 for d in [0,1]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        elif any(J[d,i,(j+1)%N,k] > 0 for d in [0,1]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        if i < N-1:
          site_neighbors = [J[2,i+1,j,k], J[2,i,j,(k+1)%N]]
          if any(J[d,i+1,j,k] < 0 for d in [2]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
          elif any(J[d,i+1,j,k] > 0 for d in [2]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3564862}
#standard deviation: 0.041163281326444326
#island_id: 0
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][site_nbr][j][k] for d in [0,1]]
        total_spin = sum(J[d][site_nbr][j][k] for d in [0,1])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return priorities




#score: {'data3D.txt': -0.35952379999999995}
#standard deviation: 0.04359711450956359
#island_id: 0
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][site_nbr][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][site_nbr][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return priorities




#score: {'data3D.txt': 0.26649019999999995}
#standard deviation: 0.043868680216756016
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
          
          # Add a bias to favor the direction of the magnetism
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([val for val in interacting_spins if val > 0]) + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2 * site_energy
          
  return(priorities)




#score: {'data3D.txt': 0.27044979999999996}
#standard deviation: 0.043339927549085736
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy
          
          # Add a bias to favor the direction of the magnetism
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin))
            priorities[i*N*N+j*N+k][1] -= site_energy
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([val for val in interacting_spins if val > 0]) + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2 * site_energy
          
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

  return(priorities)




#score: {'data3D.txt': -0.5332178}
#standard deviation: 0.039430475056230305
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy

        # New term: interaction with neighbor sites
        if i > 0:
          site_nbr = J[1, (i - 1) % N, j, k]
          if site_nbr < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          site_nbr = J[1, (i + 1) % N, j, k]
          if site_nbr > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        if j > 0:
          site_nbr = J[0, i, (j - 1) % N, k]
          if site_nbr < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if j < N - 1:
          site_nbr = J[0, i, (j + 1) % N, k]
          if site_nbr > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        if k > 0:
          site_nbr = J[2, i, j, (k - 1) % N]
          if site_nbr < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          site_nbr = J[2, i, j, (k + 1) % N]
          if site_nbr > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.28761100000000006}
#standard deviation: 0.04600240862172328
#island_id: 3
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.09614420000000012}
#standard deviation: 0.04712445104571511
#island_id: 3
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2,3]]
        total_spin = sum(J[d,i,j,k] for d in [1,2,3])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
        
  return priorities




#score: {'data3D.txt': 0.2560838}
#standard deviation: 0.04475772980793374
#island_id: 3
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Calculate the energy of placing a spin on this site
        energy_plus = 0
        energy_minus = 0
        if i > 0:
          energy_plus += J[1, i-1, j, k]
          energy_minus += J[1, i-1, j, k]
        if j > 0:
          energy_plus += J[0, i, j-1, k]
          energy_minus += J[0, i, j-1, k]
        if k > 0:
          energy_plus += J[2, i, j, k-1]
          energy_minus += J[2, i, j, k-1]

        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (energy_plus - energy_minus)
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (energy_minus - energy_plus)

  return(priorities)




#score: {'data3D.txt': -0.5507758}
#standard deviation: 0.0394448071913148
#island_id: 1
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, max(0, k-1)]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, min(N-1, k+1)]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.03518180000000001}
#standard deviation: 0.044388907947369015
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(val for val in interacting_spins if val < 0) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.06802420000000008}
#standard deviation: 0.04634269925630142
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.08081540000000001}
#standard deviation: 0.050543375855199864
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with different spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N], J[0, i, (j - 1) % N, k],
                  J[1, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[1, i, (j - 1) % N, k],
                  J[2, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N], J[2, i, (j - 1) % N, k]]

        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.2593854}
#standard deviation: 0.05291579562701482
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N],
                  J[1, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N],
                  J[2, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]

        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': 0.13425419999999996}
#standard deviation: 0.049476748300186425
#island_id: 2
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0, 1, 2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.33819780000000005}
#standard deviation: 0.04285845021883083
#island_id: 1
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + ((j-1)%2 - 1)) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.014523}
#standard deviation: 0.04696959389860636
#island_id: 3
#version_generated: 3
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority for -1 spin
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_energy) * len([val for val in interacting_spins if val > 0]) + site_energy
        
        # Calculate the priority for 1 spin
        if total_spin < 0:
          priorities[i*N*N+j*N+k][1] -= np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
        else:
          priorities[i*N*N+j*N+k][1] += np.exp(-site_energy) * len([val for val in interacting_spins if val < 0]) + site_energy
        
  return priorities




#score: {'data3D.txt': -0.12790580000000012}
#standard deviation: 0.047069846466288805
#island_id: 3
#version_generated: 3
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += site_energy * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= site_energy * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += site_energy
  
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 3
#version_generated: 3
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority for -1 spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        
        # Calculate the priority for 1 spin
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.5167338}
#standard deviation: 0.041872252119512274
#island_id: 0
#version_generated: 3
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        edge_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in edge_neighbors if val < 0]) + sum(val for val in edge_neighbors)
        priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34544860000000005}
#standard deviation: 0.04377623736732064
#island_id: 0
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][site_nbr][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][site_nbr][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        edge_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + edge_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + edge_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -3 + 3*total_spin
  
  return priorities




#score: {'data3D.txt': -0.4683434}
#standard deviation: 0.04602667005595778
#island_id: 0
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        edge_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors + edge_neighbors if val < 0]) + len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 5 - 5*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors + edge_neighbors if val > 0]) + len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -5 + 5*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49642020000000014}
#standard deviation: 0.042813263738706024
#island_id: 0
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        spin_product = h[i][j][k]
        for d in [0,1]:
          if J[d,i,j,k] > 0:
            spin_product *= np.exp(J[d,i,j,k])
          elif J[d,i,j,k] < 0:
            spin_product /= np.exp(-J[d,i,j,k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.007139799999999998}
#standard deviation: 0.0469172515814812
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
        
        edge_neighbors = [J[0,i,j-1,k], J[2,i,(j+1)%N,k]]
        total_edge_neighbor_spin = sum(val for val in edge_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in edge_neighbors if val < 0) + total_edge_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        face_neighbors = [J[0,(i+1)%N,j,k-1], J[2,i,(j+1)%N,k]]
        total_face_neighbor_spin = sum(val for val in face_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in face_neighbors if val < 0) + total_face_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.04082260000000001}
#standard deviation: 0.04576906651047189
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  # Calculate site interactions and total spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate site priority
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate site neighbor interactions
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Calculate neighbor spins
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
  
  return(priorities)




#score: {'data3D.txt': -0.0389098}
#standard deviation: 0.046056882047746134
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin)) * np.exp(-total_spin**2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin)) * np.exp(-total_spin**2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin)) * np.exp(-total_neighbor_spin**2)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        neighbor_spins = [J[0, i, j, k-1], J[1, (i+1)%N, j, k-1], J[2, i, j-1, k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin)) * np.exp(-(d+1)**2)
            priorities[i*N*N+j*N+k][1] -= (d + 1)

  return(priorities)




#score: {'data3D.txt': -0.0910542}
#standard deviation: 0.04514656822350952
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin)**(3/4)*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] += (sum(val for val in site_neighbors if val < 0) + total_neighbor_spin)**(3/4)*np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbor_spins = [J[0,i,j,k-1], J[1,(i+1)%N,j,k-1], J[2,i,j-1,k]]
        for d, spin in enumerate(neighbor_spins):
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += (d + 1)**(3/4)*np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= (d + 1)
        
        neighbor_spin_sum = sum(val for val in neighbor_spins if val < 0)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum**3/4)
        priorities[i*N*N+j*N+k][1] += 3*neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0379754}
#standard deviation: 0.04708035338482497
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4039266}
#standard deviation: 0.03973071371672047
#island_id: 2
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        
        local_energy = sum(J[0,i,j,k] + J[1,i,j,k] + J[2,i,j,k] for k in range(N)) / N**3
        priorities[i*N*N+j*N+k][0] += np.exp(local_energy)
        priorities[i*N*N+j*N+k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.3308898}
#standard deviation: 0.04067252704172683
#island_id: 2
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if any(val > 0 for val in site_opposite_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.42433220000000005}
#standard deviation: 0.0399693202739301
#island_id: 2
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.39906020000000003}
#standard deviation: 0.039981955129283014
#island_id: 2
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -(np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        # Add a new term based on the magnetism of the nearest neighbors
        site_neighbors_magnetism = [h[i, (j+1)%N, k], h[(i+1)%N, j, k], h[i, j, (k+1)%N]]
        if any(val > 0 for val in site_neighbors_magnetism):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.38436620000000016}
#standard deviation: 0.04927723467850038
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

  # Add a new term based on the local energy and total spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] += 2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2

  # Add a new term based on the interaction with neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -2 * np.sum([J[d, (i+1)%N, j, k] for d in [0, 1]]) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] += 2 * np.sum([J[d, (i+1)%N, j, k] for d in [0, 1]]) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.495163}
#standard deviation: 0.041978901736467567
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy and total spin
        priorities[i*N*N + j*N + k][0] += -2 * abs(total_spin) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.27291580000000026}
#standard deviation: 0.09524293144564587
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy and total spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] += 2 * abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2

  # Add a new term based on the total spin and local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-2 * abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] += -np.exp(2 * abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.13072219999999998}
#standard deviation: 0.04604745190735313
#island_id: 2
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = (sum(val for val in interacting_spins if val < 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -(sum(val for val in interacting_spins if val > 0) + total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        priorities[i*N*N + j*N + k][0] += (sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)) * np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy and total spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2 * abs(total_spin)
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(abs(total_spin)) * (1 + abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 2 * abs(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.4335338}
#standard deviation: 0.04077433969496012
#island_id: 0
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d][i][j][k] > 0:
            spin_product *= np.exp(J[d][i][j][k])
          elif J[d][i][j][k] < 0:
            spin_product /= np.exp(-J[d][i][j][k])
        
        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2][i][j][k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2][i][j][k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2][i][j][k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2][i][j][k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.35525340000000005}
#standard deviation: 0.04565991139325612
#island_id: 0
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d][i][j][k] > 0:
            spin_product *= np.exp(J[d][i][j][k])
          elif J[d][i][j][k] < 0:
            spin_product /= np.exp(-J[d][i][j][k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        if k > 0:
          neighbor_spin = J[2][i][j][k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

        if k < N-1:
          neighbor_spin = J[2][i][j][k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4191538}
#standard deviation: 0.04131617292973782
#island_id: 0
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d][i][j][k] > 0:
            spin_product *= np.exp(J[d][i][j][k])
          elif J[d][i][j][k] < 0:
            spin_product /= np.exp(-J[d][i][j][k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.5098198000000002}
#standard deviation: 0.04289099635074942
#island_id: 0
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        spin_product = h[i][j][k]
        for d in [0,1,2]:
          if J[d][i][j][k] > 0:
            spin_product *= np.exp(J[d][i][j][k])
          elif J[d][i][j][k] < 0:
            spin_product /= np.exp(-J[d][i][j][k])

        priorities[i*N*N+j*N+k][0] += spin_product
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        if k > 0:
          neighbor_spin = J[2][i][j][k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

        if k < N-1:
          neighbor_spin = J[2][i][j][k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4676106}
#standard deviation: 0.04157135561465371
#island_id: 0
#version_generated: 3
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0,1,2]]
        total_spin = sum(J[d][i][j][k] for d in [0,1,2])
        
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
        
        if i > 0:
          site_neighbors = [J[0,i-1,j,k], J[1,i-1,j,k]]
          if any(J[d,i-1,j,k] < 0 for d in [0,1]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) > 0)
            priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
          elif any(J[d,i-1,j,k] > 0 for d in [0,1]):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) > 0)
            priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

        # Calculate the energy of placing a spin on this site
        energy_plus = 0
        energy_minus = 0
        if i > 0:
          energy_plus += J[1, i-1, j, k]
          energy_minus += J[1, i-1, j, k]
        if j > 0:
          energy_plus += J[0, i, j-1, k]
          energy_minus += J[0, i, j-1, k]
        if k > 0:
          energy_plus += J[2, i, j, k-1]
          energy_minus += J[2, i, j, k-1]

        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (energy_plus - energy_minus)
        priorities[i*N*N+j*N+k][1] += np.exp(-abs(total_spin)) * (energy_minus - energy_plus)

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 3
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.47208940000000005}
#standard deviation: 0.04327517310930137
#island_id: 3
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        for d in [0,1,2]:
          priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          
  return priorities




#score: {'data3D.txt': -0.5091918000000001}
#standard deviation: 0.0430959920730455
#island_id: 0
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Added a new term to prioritize spins based on the magnetism at each site
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.5085754}
#standard deviation: 0.04049796334187684
#island_id: 0
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Adding interactions with neighbors
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.16366220000000004}
#standard deviation: 0.050082738854419696
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        # Add a term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a term based on the number of nearest neighbors with same spin
        neighbor_spin_sum = 0
        for d in [0, 1, 2]:
          if k > 0:
            neighbor_spin = J[d, i, j, k-1]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
            elif neighbor_spin > 0:
              neighbor_spin_sum += 1
          if k < N-1:
            neighbor_spin = J[d, i, j, k+1]
            if neighbor_spin < 0:
              neighbor_spin_sum -= 1
            elif neighbor_spin > 0:
              neighbor_spin_sum += 1

        # Add a term based on the number of nearest neighbors with different spin
        for d in [0, 1, 2]:
          if k > 0:
            neighbor_spin = J[d, i, j, k-1]
            if neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          if k < N-1:
            neighbor_spin = J[d, i, j, k+1]
            if neighbor_spin > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(val for val in interacting_spins if val < 0) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.449307}
#standard deviation: 0.04203635606234204
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(val for val in interacting_spins if val < 0) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0019658}
#standard deviation: 0.04539679537544473
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(val for val in interacting_spins if val < 0) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the number of nearest neighbors with different spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin * J[2, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val * J[2, i, j, k] > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.41080500000000003}
#standard deviation: 0.048716040222908104
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((j+k)%N)) % N
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(val for val in interacting_spins if val < 0) + total_spin)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5507758}
#standard deviation: 0.0394448071913148
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, max(0, k-1)]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        neighbor_spin = J[2, i, j, min(N-1, k+1)]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5507758}
#standard deviation: 0.0394448071913148
#island_id: 1
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, max(0, k-1)]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, min(N-1, k+1)]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

        # Calculate the energy of placing a spin on this site
        energy_plus = 0
        energy_minus = 0
        if i > 0:
          energy_plus += J[1, i-1, j, k]
          energy_minus += J[1, i-1, j, k]
        if j > 0:
          energy_plus += J[0, i, j-1, k]
          energy_minus += J[0, i, j-1, k]
        if k > 0:
          energy_plus += J[2, i, j, k-1]
          energy_minus += J[2, i, j, k-1]

        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (energy_plus - energy_minus)
        priorities[i*N*N+j*N+k][1] += np.exp(-abs(total_spin)) * (energy_minus - energy_plus)

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.16080499999999998}
#standard deviation: 0.046925975056465265
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.33819780000000005}
#standard deviation: 0.04285845021883083
#island_id: 1
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + ((j-1)%2 - 1)) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33819780000000005}
#standard deviation: 0.04285845021883083
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + ((j-1)%2 - 1)) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3826114000000001}
#standard deviation: 0.04326446752289921
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2139126}
#standard deviation: 0.05241392945811257
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Compute local energies
  local_energies = np.sum(J[:, :, :, :], axis=0) + h
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = J[[0, 1, 2], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k] + J[[0, 1, 2], i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5186122000000001}
#standard deviation: 0.04199908059898455
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 2
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09559980000000003}
#standard deviation: 0.046067659371407194
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.510527}
#standard deviation: 0.04139179231441906
#island_id: 2
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 3
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0]) + np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0]) + np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 3
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(1 for val in interacting_spins if val > 0) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 * (np.sum(1 for val in interacting_spins if val < 0) + total_spin)
  return priorities




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        # Improved calculation of site neighbors
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




